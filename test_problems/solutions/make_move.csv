upi,time,try,answer,rawfraction
aahk798,1695952263,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
 int i, j; 
 FindTile (board , tile , &i, &j );
// if upper row has the space replace the value 
if (i>0){ 
    if (board[i-1][j]==-1){
    board[i-1][j]=board[i][j];
    board[i][j]=-1; 
    }
}
// if the value is not in the left most col. check the colum same row to the left. If the left col. is a space
// swap 
if (j>0){ 
    if (board[i][j-1]==-1){
    board[i][j-1]=board[i][j];
    board[i][j]=-1; 
    }
}  
// if the col is not the right most. Check the col. to the right of the value. and if it is a space then swap
if (j<(NUM_COLS-1)){ 
    if (board[i][(j+1)]==-1){ 
    board[i][j+1]=board[i][j];
    board[i][j]=-1;
    }
}
// if the row is not the bottom most. check if the space is in the below row. And if space is there swap. 
if (i<(NUM_ROWS-1)){  
    if (board[(i+1)][j]==-1){
    board[i+1][j]=board[i][j];
    board[i][j]=-1; 
    }
}
 
  
}",1
aana675,1696124129,1,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4


void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos) {
    for (int row = 0; row < NUM_ROWS; row++) {
        for (int col = 0; col < NUM_COLS; col++) {
            if (board[row][col] == tile) {
                *rowPos = row;
                *colPos = col;
                return;
            }
        }
    }
    *rowPos = -1; 
    *colPos = -1;
}
",0
aana675,1696124316,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRow, tileCol;
    int emptyRow, emptyCol;

    
    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol);

    
    if ((abs(tileRow - emptyRow) == 1 && tileCol == emptyCol) ||
        (abs(tileCol - emptyCol) == 1 && tileRow == emptyRow)) {
        
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}
",1
aaza463,1695630248,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tilerow, tilecol, spacerow, spacecol, diffrow, diffcol;

	FindTile(board, -1, &spacerow, &spacecol);
	FindTile(board, tile, &tilerow, &tilecol);

	diffrow = tilerow - spacerow;
	diffrow = diffrow * diffrow;

	diffcol = tilecol - spacecol;
	diffcol = diffcol * diffcol;

	if ((diffcol == 1 && diffrow == 0) || (diffcol == 0 && diffrow == 1)){
		board[tilerow][tilecol] = -1;
		board[spacerow][spacecol] = tile;
	}

}",1
abha257,1695960280,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row1, col1, row2, col2;
	FindTile(board, tile, &row1, &col1);
	if (col1 == 0) {
		if ((board[row1 + 1][col1] == -1) || (board[row1 - 1][col1] == -1) || (board[row1][col1 + 1] == -1)) {
			FindTile(board, -1, &row2, &col2);
			board[row2][col2] = board[row1][col1];
			board[row1][col1] = -1;
		}
	}
	else if (col1 == 3) {
		if ((board[row1 + 1][col1] == -1) || (board[row1 - 1][col1] == -1) || (board[row1][col1 - 1] == -1)) {
			FindTile(board, -1, &row2, &col2);
			board[row2][col2] = board[row1][col1];
			board[row1][col1] = -1;
		}
	}
	else if ((board[row1 + 1][col1] == -1) || (board[row1 - 1][col1] == -1) || (board[row1][col1 + 1] == -1) || (board[row1][col1 - 1] == -1)) {
		FindTile(board, -1, &row2, &col2);
		board[row2][col2] = board[row1][col1];
		board[row1][col1] = -1;
	}
}",1
abro522,1695601992,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row = -1;
    int col = -1;
    FindTile(board, tile, &row, &col);
    
    if (row >= 0 && col >= 0) {
        for (int row_offset = row + 1; row_offset >= row - 1; row_offset -= 2) {
            for (int col_offset = col + 1; col_offset >= col - 1; col_offset -= 2) {
                if (row_offset >= 0 && col_offset >= 0 && row_offset < NUM_ROWS && col_offset < NUM_COLS && board[row_offset][col_offset] < 0) {
                    int space = board[row_offset][col_offset];
                    board[row_offset][col_offset] = board[row][col];
                    board[row][col] = space;
                    return;
                }
            }
        }
    }
}
",0
abro522,1695602447,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row = -1;
    int col = -1;
    FindTile(board, tile, &row, &col);
    
    int offsets[4][2] = {
        { 1, 0},
        { 0, 1},
        {-1, 0},
        { 0,-1}
    };
    
    if (row >= 0 && col >= 0) {
        for (int offset = 0; offset < 4; offset++) {
            int row_offset = row + offsets[offset][0];
            int col_offset = col + offsets[offset][1];

            if (row_offset >= 0 && col_offset >= 0 && row_offset < NUM_ROWS && col_offset < NUM_COLS && board[row_offset][col_offset] < 0) {
                int space = board[row_offset][col_offset];
                board[row_offset][col_offset] = board[row][col];
                board[row][col] = space;
                return;
            }
        }
    }
}
",1
acam267,1695858892,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col,y,x;
    FindTile(board, -1, &row, &col);
    FindTile(board, tile, &y, &x);
    board[row][col] = tile;
    board[y][x] = -1;
}",0
acam267,1696127755,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col, y, x; 
    FindTile(board, -1, &row, &col);
    FindTile(board, tile, &y, &x);
    if((col==x && (row==y+1 || row == y-1)) || (row==y && (col == x+1 || col == x-1))) {
        board[row][col] = tile;
        board[y][x] = -1;   
    }
}",1
ache725,1696164375,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row_empty, col_empty;
	int row_value, col_value;
	int row_adjacent, col_adjacent;
	FindTile(board, -1, &row_empty, &col_empty);
	
	
	FindTile(board, tile, &row_value, &col_value);
	if (row_value == row_empty + 1 || row_value == row_empty - 1 || row_value == row_empty){
		row_adjacent = 1;
	}
	else{
		row_adjacent = 0;
	}

	if (col_value == col_empty + 1 || col_value == col_empty - 1 || col_value == col_empty){
		col_adjacent = 1;
	}
	else{
		col_adjacent = 0;		
	}

	if ((row_adjacent == 1) && (col_adjacent == 1)){
		board[row_empty][col_empty] = tile;
		board[row_value][col_value] = -1;
	}

}",1
achi359,1696240235,1," void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
        int row, col, rowPosTile, colPosTile;
        FindTile(board, -1, &row, &col);
//iterate over the array
 for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            //define a location for the tile you wish to swap
            if (board[i][j] == tile){
                rowPosTile = i;
                colPosTile = j;
            }}}
            
            /*
if (rowPos == (row + 1) || (row - 1)) && (colPos == (col + 1) || (col -1)) {
            board[row][col] = tile;
            board[rowPos][colPos] = -1;
            return
            
            */
            
//check if the tile is adjacent to the empty tile and swap positions           
if (col + 1 < NUM_COLS && board[row][col + 1] == tile){
    board[row][col] = tile;
    board[rowPosTile][colPosTile] = -1;
    }
            
if (row + 1 < NUM_ROWS && board[row + 1][col] == tile){
    board[row][col] = tile;
    board[rowPosTile][colPosTile] = -1;
    }
            
if (row -1 >= 0 && board[row -1][col] == tile){
    board[row][col] = tile;
    board[rowPosTile][colPosTile] = -1;
    }

if (col -1 >= 0 && board[row][col - 1] == tile){
    board[row][col] = tile;
    board[rowPosTile][colPosTile] = -1;
    }            
            
            
}",1
acoc261,1695767447,1,"#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row1;
    int row2;
    int col1;
    int col2;
    int temp;
    FindTile(board, -1, &row1, &col1);
    FindTile(board, tile, &row2, &col2);
    if ((row1 == row2) && ((col1 + 1 == col2) || (col1 - 1 == col2)))
    {
        temp = board[row1][col1];
        board[row1][col1] = board[row1][col2];
        board[row1][col2] = temp;
        
    }
    else if ((col1 == col2) && ((row1 + 1 == row2) + (row1 - 1 == row2)))
    {
        temp = board[row1][col1];
        board[row1][col1] = board[row2][col1];
        board[row2][col1] = temp;
    }
    else 
    {
    return;
    }
}",1
adav221,1696153375,1,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos) {
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == tile) {
                *rowPos = i;
                *colPos = j;
            }
        }
    }

    *rowPos = -1;
    *colPos = -1;
}
",0
adav221,1696153397,2,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos) {
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == tile) {
                *rowPos = i;
                *colPos = j;
                return;
            }
        }
    }

    *rowPos = -1;
    *colPos = -1;
}
",0
adav221,1696155497,3,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos);

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol, tileRow, tileCol;
    
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);

    if ((tileRow == emptyRow && (tileCol == emptyCol + 1 || tileCol == emptyCol - 1)) ||
        (tileCol == emptyCol && (tileRow == emptyRow + 1 || tileRow == emptyRow - 1))) {
        
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}
",1
adey750,1696240624,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    
      int rowPos = 0;
      
      int colPos = 0;
        
      FindTile(board, -1, &rowPos, &colPos);
       
        if(rowPos>0 &&board[rowPos-1][colPos] == tile){
            
            board[rowPos-1][colPos]=-1;
            board[rowPos][colPos]=tile;
        }
      
        if (colPos<NUM_COLS-1 &&board[rowPos][colPos+1]==tile) {
           
            board[rowPos][colPos+1]=-1;
            board[rowPos][colPos]=tile;
         
         }
        if (colPos>0 &&board[rowPos][colPos-1]==tile) {
            
            board[rowPos][colPos-1]=-1;
            board[rowPos][colPos]=tile;
            
        }
          if(rowPos<NUM_ROWS-1 &&board[rowPos+1][colPos]==tile){
            
            board[rowPos+1][colPos]=-1;
            board[rowPos][colPos]=tile;
        }
    
}",1
afal438,1695796517,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i;
	int j;
	int x;
	int y;
	int checked = 0;

	/* SWAPPING MISSING TILE FIRST */
	for (i = 0; i < NUM_ROWS; i++)
	{
		for (j = 0; j < NUM_COLS; j++)
		{
			/* FIND TILE*/
			if (board[i][j] == -1)
			{

				/*TO THE RIGHT*/
				if (board[i][j + 1] == tile && checked == 0 && j != 3)
				{
					board[i][j + 1] = -1;
					board[i][j] = tile;
					checked++;
				}

				/*TO THE LEFT*/
				if (board[i][j - 1] == tile && checked == 0 && j != 0)
				{
					board[i][j - 1] = -1;
					board[i][j] = tile;
					checked++;
				}

				/*TO THE UP*/
				if (board[i][j - 4] == tile && checked == 0)
				{
					board[i][j - 4] = -1;
					board[i][j] = tile;
					checked++;
				}

				/*TO THE DOWN*/
				if (board[i][j + 4] == tile && checked == 0)
				{
					board[i][j + 4] = -1;
					board[i][j] = tile;
					checked++;
				}



				


			}
		}
	}


}",0
afal438,1695796552,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i;
	int j;
	int checked = 0;

	/* SWAPPING MISSING TILE FIRST */
	for (i = 0; i < NUM_ROWS; i++)
	{
		for (j = 0; j < NUM_COLS; j++)
		{
			/* FIND TILE*/
			if (board[i][j] == -1)
			{

				/*TO THE RIGHT*/
				if (board[i][j + 1] == tile && checked == 0 && j != 3)
				{
					board[i][j + 1] = -1;
					board[i][j] = tile;
					checked++;
				}

				/*TO THE LEFT*/
				if (board[i][j - 1] == tile && checked == 0 && j != 0)
				{
					board[i][j - 1] = -1;
					board[i][j] = tile;
					checked++;
				}

				/*TO THE UP*/
				if (board[i][j - 4] == tile && checked == 0)
				{
					board[i][j - 4] = -1;
					board[i][j] = tile;
					checked++;
				}

				/*TO THE DOWN*/
				if (board[i][j + 4] == tile && checked == 0)
				{
					board[i][j + 4] = -1;
					board[i][j] = tile;
					checked++;
				}



				


			}
		}
	}


}",1
afit324,1696148764,1,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col;
    int row1, col1;
    FindTile(board, tile, &row, &col);
    FindTile(board, -1, &row1, &col1);
    
    if (board[row+1][col] == -1 || board[row-1][col] == -1 || board[row][col+1] == -1 || board[row][col-1] == -1) {
        board[row][col] = -1;
        board[row1][col1] = tile;
    }
    
}",0
afit324,1696154198,2,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col;
    int row1, col1;
    FindTile(board, tile, &row, &col);
    FindTile(board, -1, &row1, &col1);
    
    if (row > 0 && row1 == row - 1 && col1 == col) {
        board[row][col] = -1;
        board[row1][col1] = tile;
    }
    if (col > 0 && col1 == col - 1 && row1 == row) {
        board[row][col] = -1;
        board[row1][col1] = tile;
    }
    if (row < (NUM_ROWS - 1) && row1 == row + 1 && col1 == col) {
        board[row][col] = -1;
        board[row1][col1] = tile;
    }
    if (col < (NUM_COLS - 1) && col1 == col + 1 && row1 == row) {
        board[row][col] = -1;
        board[row1][col1] = tile;
    }
    
}",1
agan859,1695960435,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int swapSlot, swapTileRow, swapTileColumn, emptyRow, emptyColumn, emptySlot;

	FindTile(board, tile, &swapTileRow, &swapTileColumn);
	swapSlot = board[swapTileRow][swapTileColumn];
	

	FindTile(board, -1, &emptyRow, &emptyColumn);
	emptySlot = board[emptyRow][emptyColumn];
	

	 if (((swapTileRow == emptyRow + 1 || swapTileRow == emptyRow - 1) || (swapTileColumn == emptyColumn + 1 || swapTileColumn == emptyColumn - 1)) && ~((swapTileRow == emptyRow + 1 || swapTileRow == emptyRow - 1) && (swapTileColumn == emptyColumn + 1 || swapTileColumn == emptyColumn - 1))) {
		 board[swapTileRow][swapTileColumn] = emptySlot;
		 board[emptyRow][emptyColumn] = swapSlot;
	 } else {
		 return;
	 }

}",0
agan859,1695960547,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int swapSlot, swapTileRow, swapTileColumn, emptyRow, emptyColumn, emptySlot;

	FindTile(board, tile, &swapTileRow, &swapTileColumn);
	swapSlot = board[swapTileRow][swapTileColumn];
	

	FindTile(board, -1, &emptyRow, &emptyColumn);
	emptySlot = board[emptyRow][emptyColumn];
	

	 if (((swapTileRow == emptyRow + 1 || swapTileRow == emptyRow - 1) || (swapTileColumn == emptyColumn + 1 || swapTileColumn == emptyColumn - 1)) && !((swapTileRow == emptyRow + 1 || swapTileRow == emptyRow - 1) && (swapTileColumn == emptyColumn + 1 || swapTileColumn == emptyColumn - 1))) {
		 board[swapTileRow][swapTileColumn] = emptySlot;
		 board[emptyRow][emptyColumn] = swapSlot;
	 } else {
		 return;
	 }

}",0
agan859,1695961650,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int swapSlot, swapTileRow, swapTileColumn, emptyRow, emptyColumn, emptySlot;

	FindTile(board, tile, &swapTileRow, &swapTileColumn);
	swapSlot = board[swapTileRow][swapTileColumn];
	

	FindTile(board, -1, &emptyRow, &emptyColumn);
	emptySlot = board[emptyRow][emptyColumn];
	
	if (swapTileRow == emptyRow) {
		if (swapTileColumn == emptyRow + 1 || swapTileColumn == emptyRow - 1) {
			board[swapTileRow][swapTileColumn] = emptySlot;
			board[emptyRow][emptyColumn] = swapSlot;
		}
	} else if (swapTileColumn == emptyColumn) {
		if (swapTileRow == emptyColumn + 1 || swapTileRow == emptyColumn - 1);
			board[swapTileRow][swapTileColumn] = emptySlot;
			board[emptyRow][emptyColumn] = swapSlot;
	} 

}",0
agan859,1695961706,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int swapSlot, swapTileRow, swapTileColumn, emptyRow, emptyColumn, emptySlot;

	FindTile(board, tile, &swapTileRow, &swapTileColumn);
	swapSlot = board[swapTileRow][swapTileColumn];
	

	FindTile(board, -1, &emptyRow, &emptyColumn);
	emptySlot = board[emptyRow][emptyColumn];
	
	if (swapTileRow == emptyRow) {
		if (swapTileColumn == emptyRow + 1 || swapTileColumn == emptyRow - 1) {
			board[swapTileRow][swapTileColumn] = emptySlot;
			board[emptyRow][emptyColumn] = swapSlot;
		}
	} else if (swapTileColumn == emptyColumn) {
		if (swapTileRow == emptyColumn + 1 || swapTileRow == emptyColumn - 1) {;
			board[swapTileRow][swapTileColumn] = emptySlot;
			board[emptyRow][emptyColumn] = swapSlot;
		}
	} 

}",0
agan859,1695962614,5,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int swapSlot, swapTileRow, swapTileColumn, emptyRow, emptyColumn, emptySlot;

	FindTile(board, tile, &swapTileRow, &swapTileColumn);
	swapSlot = board[swapTileRow][swapTileColumn];
	

	FindTile(board, -1, &emptyRow, &emptyColumn);
	emptySlot = board[emptyRow][emptyColumn];
	
	if (swapTileRow == emptyRow) {
		if (swapTileColumn == emptyColumn + 1 || swapTileColumn == emptyColumn - 1) {
			board[swapTileRow][swapTileColumn] = emptySlot;
			board[emptyRow][emptyColumn] = swapSlot;
		}
	} else if (swapTileColumn == emptyColumn) {
		if (swapTileRow == emptyRow + 1 || swapTileRow == emptyRow - 1) {
			board[swapTileRow][swapTileColumn] = emptySlot;
			board[emptyRow][emptyColumn] = swapSlot;;
		}
	} 

}",1
agay279,1696214982,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
     int col;
    int row;
    int rowPos;
    int colPos;
    int i;
    int j;
    FindTile(board, -1, &row, &col);// position of blank
    for ( j=0;j<NUM_COLS; j++) {
        for ( i=0; i<NUM_ROWS; i++){
            if (board[i][j]==tile){
                rowPos=i; //row pos of tile to switch
                colPos=j; // col position of tile to switch
            }
        }

    }

    if ((rowPos-1!=-1)&&(colPos==col)){
		if ((rowPos==row+1||rowPos==row-1)){
            board[row][col]=board[rowPos][colPos];
            board[rowPos][colPos]=-1;
			return;
		}
	}
	if ((rowPos+1!=5)&&(colPos==col)){
		if ((rowPos==row+1||rowPos==row-1)){
            board[row][col]=board[rowPos][colPos];
            board[rowPos][colPos]=-1;
			return;
		}
		
    
	}
	if ((colPos-1!=-1)&&(rowPos==row)){
		if ((colPos==col+1||colPos==col-1)){
			board[row][col]=board[rowPos][colPos];
            board[rowPos][colPos]=-1;
			return;
		}

	}
	if ((colPos+1!=5)&&(rowPos==row)){
		if ((colPos==col+1||colPos==col-1)){
			board[row][col]=board[rowPos][colPos];
            board[rowPos][colPos]=-1;
			return;
		}

	}

        
    
    return;
    // if position is one adjacent AND is between and equal to 0 to 4,
    //then move, else don't move
}
",1
agou682,1696238252,1,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos) {
    for (int row = 0; row < NUM_ROWS; row++) {
        for (int col = 0; col < NUM_COLS; col++) {
            if (board[row][col] == tile) {
                *rowPos = row;
                *colPos = col;
                return; 
            }
        }
    }
}

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol;
    int tileRow, tileCol;

    
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);

    
    if ((tileRow==emptyRow&&(tileCol==emptyCol - 1 || tileCol == emptyCol + 1)) ||
        (tileCol==emptyCol&&(tileRow==emptyRow - 1 || tileRow == emptyRow + 1))) {
       
        int temp = board[emptyRow][emptyCol];
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = temp;
    }
}

void PrintBoard(int board[NUM_ROWS][NUM_COLS]) {
    for (int i = 0; i<NUM_ROWS; i++) {
        for (int j = 0; j<NUM_COLS; j++) {
            printf(""%2d "",board[i][j]);
        }
        printf(""\n"");
    }
}
",0
ahac139,1695793089,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int iRow,iCol;
    FindTile(board, 9, &iRow, &iCol);
    int eRow,eCol;
    FindTile(board, -1, &eRow, &eCol);

    if ((abs(iRow-eRow) == 1)^(abs(iCol-eCol) == 1)){
        int store[2] = {eRow,eCol};

        board[eRow][eCol] = board[iRow][iCol];
        board[iRow][iCol] = -1;
    }
}",0
ahac139,1695793171,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int iRow,iCol;
    FindTile(board, 9, &iRow, &iCol);
    int eRow,eCol;
    FindTile(board, -1, &eRow, &eCol);

    if ((abs(iRow-eRow) == 1)^(abs(iCol-eCol) == 1)){
        board[eRow][eCol] = board[iRow][iCol];
        board[iRow][iCol] = -1;    
    }   
}",0
ahac139,1695793356,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int iRow,iCol;
    FindTile(board, tile, &iRow, &iCol);
    int eRow,eCol;
    FindTile(board, -1, &eRow, &eCol);

    if ((abs(iRow-eRow) == 1)^(abs(iCol-eCol) == 1)){
        board[eRow][eCol] = board[iRow][iCol];
        board[iRow][iCol] = -1;    
    }   
}",0
ahac139,1696135182,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int iRow,iCol;
    FindTile(board, tile, &iRow, &iCol);
    int eRow,eCol;
    FindTile(board, -1, &eRow, &eCol);
    if (!((iCol == 0)&&(eCol == 3))&&!((iCol == 3)&&(eCol == 0))){
        if ((abs(iRow-eRow) == 1)^(abs(iCol-eCol) == 1)){
            board[eRow][eCol] = board[iRow][iCol];
            board[iRow][iCol] = -1;    
        }   
    }
}",1
ahac223,1696233022,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int spaceRow;
    int spaceCol;
    int tileRow;
    int tileCol;
    FindTile(board, -1, &spaceRow, &spaceCol);
    FindTile(board,tile, &tileRow, &tileCol);
    
    
    if ((spaceRow - tileRow) + (spaceCol - tileCol) == -1){
    int temp = board[spaceRow][spaceCol];
    board[spaceRow][spaceCol] = board[tileRow][tileCol];
    board[tileRow][tileCol] = temp;
    return;
    }
    

}",0
ahac223,1696233403,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int spaceRow;
    int spaceCol;
    int tileRow;
    int tileCol;
    FindTile(board, -1, &spaceRow, &spaceCol);
    FindTile(board,tile, &tileRow, &tileCol);
    
    
    if ((spaceRow - tileRow) + (spaceCol - tileCol) == -1){
    int temp = board[spaceRow][spaceCol];
    board[spaceRow][spaceCol] = board[tileRow][tileCol];
    board[tileRow][tileCol] = temp;
    return;
    
    }
    
     if ((spaceCol - tileCol) + (spaceRow - tileRow) > 0){
    int temp = board[spaceRow][spaceCol];
    board[spaceRow][spaceCol] = board[tileRow][tileCol];
    board[tileRow][tileCol] = temp;
    return;
    
    }
    

}",0
ahac223,1696233507,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int spaceRow;
    int spaceCol;
    int tileRow;
    int tileCol;
    FindTile(board, -1, &spaceRow, &spaceCol);
    FindTile(board,tile, &tileRow, &tileCol);
    
    
    if (abs(spaceRow - tileRow) + abs(spaceCol - tileCol) == 1){
    int temp = board[spaceRow][spaceCol];
    board[spaceRow][spaceCol] = board[tileRow][tileCol];
    board[tileRow][tileCol] = temp;
    return;
    
    }
    

}",1
ahai431,1696133253,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int empty,row1,row2,col1,col2;

	FindTile(board, -1, &row1, &col1);
	FindTile(board, tile, &row2, &col2);

	if ( ((row1-row2)==-1) || ((row1 - row2) == -1) || ((col1 - col2) == -1) || ((col1 - col2) == -1) ) {
		board[row1][col1] = tile;
		board[row2][col2] = -1;
	}
}",0
ahai431,1696133279,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row1,row2,col1,col2;

	FindTile(board, -1, &row1, &col1);
	FindTile(board, tile, &row2, &col2);

	if ( ((row1-row2)==-1) || ((row1 - row2) == -1) || ((col1 - col2) == -1) || ((col1 - col2) == -1) ) {
		board[row1][col1] = tile;
		board[row2][col2] = -1;
	}
}",0
ahai431,1696133457,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row1,row2,col1,col2;

	FindTile(board, -1, &row1, &col1);
	FindTile(board, tile, &row2, &col2);

	if ( ((row1-row2)==-1) || ((row1 - row2) == 1) || ((col1 - col2) == -1) || ((col1 - col2) == 1) ) {
		board[row1][col1] = tile;
		board[row2][col2] = -1;
	}
}",0
ahai431,1696134107,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row1,row2,col1,col2;

	FindTile(board, -1, &row1, &col1);
	FindTile(board, tile, &row2, &col2);

	if (( ((row1-row2)==-1) || ((row1 - row2) == 1) || ((row1 - row2) == 0) ) && ( ((col1 - col2) == -1) || ((col1 - col2) == 1) || ((col1 - col2) == 0))) {
		
			board[row1][col1] = tile;
			board[row2][col2] = -1;
		
	}
}",1
ahas673,1695862193,1,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col;
    FindTile(board, tile, &row, &col);
    
    int temp;
    int i = row;
    int j = col;
    
    /* checks if downward tile is empty,
    swap tiles if empty */
    if(row < 3 && board[i+1][j] == -1)
    {
	    temp = board[i][j];
	    board[i][j] = -1;
	    board[i+1][j] = temp;
    }
    
    /* checks if upward tile is empty,
    swap tiles if empty */
    if(row > 0 && board[i-1][j] == -1)
    {
	    temp = board[i][j];
	    board[i][j] = -1;
	    board[i-1][j] = temp;
    }
    
    /* checks if right tile is empty,
    swap tiles if empty */
    if(col < 3 && board[i][j+1] == -1)
    {
	    temp = board[i][j];
	    board[i][j] = -1;
	    board[i][j+1] = temp;
    }
    
     /* checks if left tile is empty,
    swap tiles if empty */
    if(col > 0 && board[i][j-1] == -1)
    {
	    temp = board[i][j];
	    board[i][j] = -1;
	    board[i][j-1] = temp;
    }
}",1
ahij206,1696232453,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row, col;

    // Find the specified tile
    if (FindTile(board, tile, &row, &col)) {

        if ((row > 0 && board[row - 1][col] == -1) ||
            (row < NUM_ROWS - 1 && board[row + 1][col] == -1) ||
            (col > 0 && board[row][col - 1] == -1) ||
            (col < NUM_COLS - 1 && board[row][col + 1] == -1)) {

            int emptyRow, emptyCol;
            FindTile(board, -1, &emptyRow, &emptyCol);
            board[emptyRow][emptyCol] = tile;
            board[row][col] = -1;
            }
    }
}
",0
ahij206,1696232742,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row, col;

    if (int FindTile(board, tile, &row, &col)) {

        if ((row > 0 && board[row - 1][col] == -1) ||
            (row < NUM_ROWS - 1 && board[row + 1][col] == -1) ||
            (col > 0 && board[row][col - 1] == -1) ||
            (col < NUM_COLS - 1 && board[row][col + 1] == -1)) {

            int emptyRow, emptyCol;
            FindTile(board, -1, &emptyRow, &emptyCol);
            board[emptyRow][emptyCol] = tile;
            board[row][col] = -1;
            }
    }
}
",0
ahij206,1696232947,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row, col;

    if (bool FindTile(board, tile, &row, &col)) {

        if ((row > 0 && board[row - 1][col] == -1) ||
            (row < NUM_ROWS - 1 && board[row + 1][col] == -1) ||
            (col > 0 && board[row][col - 1] == -1) ||
            (col < NUM_COLS - 1 && board[row][col + 1] == -1)) {

            int emptyRow, emptyCol;
            FindTile(board, -1, &emptyRow, &emptyCol);
            board[emptyRow][emptyCol] = tile;
            board[row][col] = -1;
            }
    }
}
",0
ahij206,1696233164,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row, col;

    if (bool FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *row, int *col)) {

        if ((row > 0 && board[row - 1][col] == -1) ||
            (row < NUM_ROWS - 1 && board[row + 1][col] == -1) ||
            (col > 0 && board[row][col - 1] == -1) ||
            (col < NUM_COLS - 1 && board[row][col + 1] == -1)) {

            int emptyRow, emptyCol;
            FindTile(board, -1, &emptyRow, &emptyCol);
            board[emptyRow][emptyCol] = tile;
            board[row][col] = -1;
            }
    }
}
",0
ahij206,1696233986,5,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row, col;
    
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == tile) {
                row = i;
                col = j;
            }
        }
    }


        if ((row > 0 && board[row - 1][col] == -1) ||
            (row < NUM_ROWS - 1 && board[row + 1][col] == -1) ||
            (col > 0 && board[row][col - 1] == -1) ||
            (col < NUM_COLS - 1 && board[row][col + 1] == -1)) {

            int emptyRow, emptyCol;
            FindTile(board, -1, &emptyRow, &emptyCol);
            board[emptyRow][emptyCol] = tile;
            board[row][col] = -1;
            }
}
",1
ahua579,1695706256,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int currentRow, currentCol, moveRow, moveCol;
	FindTile(board, -1, &currentRow, &currentCol);
	FindTile(board, tile, &moveRow, &moveCol);
	// check if tile above is moveable
	if (moveRow + 1 == currentRow && moveCol == currentCol) {
		board[currentRow][currentCol] = tile;
		board[moveRow][moveCol] = -1;
	}
	// check right
	if (moveRow == currentRow && moveCol - 1 == currentCol) {
		board[currentRow][currentCol] = tile;
		board[moveRow][moveCol] = -1;
	}
	// check bot
	if (moveRow - 1 == currentRow && moveCol == currentCol) {
		board[currentRow][currentCol] = tile;
		board[moveRow][moveCol] = -1;
	}
	// check left
	if (moveRow == currentRow && moveCol + 1 == currentCol) {
		board[currentRow][currentCol] = tile;
		board[moveRow][moveCol] = -1;
	}
}",1
ahus071,1696156259,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int ri, ci, rt,ct,temp;
	FindTile(board, -1, &ri,&ci);
	FindTile(board,tile,&rt,&ct);
	int rowDiff = ri - rt;
	int colDiff = ci - ct;
	
	if (((rowDiff >= -1 && rowDiff <= 1 && colDiff == 0) || (colDiff >= -1 && colDiff <= 1 && rowDiff == 0)) && !(rowDiff == 0 && colDiff == 0));
	{
		temp = board[ri][ci];
		board[ri][ci] = board[rt][ct];
		board[rt][ct] = temp;
	}
}",0
ahus071,1696156289,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int ri, ci, rt,ct,temp;
	FindTile(board, -1, &ri,&ci);
	FindTile(board,tile,&rt,&ct);
	int rowDiff = ri - rt;
	int colDiff = ci - ct;
	
	if (((rowDiff >= -1 && rowDiff <= 1 && colDiff == 0) || (colDiff >= -1 && colDiff <= 1 && rowDiff == 0)) && !(rowDiff == 0 && colDiff == 0))
	{
		temp = board[ri][ci];
		board[ri][ci] = board[rt][ct];
		board[rt][ct] = temp;
	}
}",1
ajam744,1696128389,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{

    
    int rowPos 
    int colPos 
    FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int &rowPos, int &colPos)    
    // rowPos = i position of tile
    // colPos = j position of tile
    int row 
    int col 
    FindTile(int board[NUM_ROWS][NUM_COLS], int -1, int &row, int &col)
       // row = i position of -1
    // col = j position of -1
    if (rowPos == row) {
       if ((colPos + 1 == col) || (colPos - 1 == col)) {
           board[rowPos][colpos] = -1;
           board[row][col] = tile;
       }
    }
    
    if (colPos == col) {
        if ((rowPos + 1 == row) || (rowPos - 1 == row)) {
            board[rowPos][colPos] = -1;
            board[row][col] = tile;
        }
    }
    
}",0
ajam744,1696128455,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{

    
    int rowPos; 
    int colPos; 
    FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int &rowPos, int &colPos)    
    // rowPos = i position of tile
    // colPos = j position of tile
    int row; 
    int col; 
    FindTile(int board[NUM_ROWS][NUM_COLS], int -1, int &row, int &col)
       // row = i position of -1
    // col = j position of -1
    if (rowPos == row) {
       if ((colPos + 1 == col) || (colPos - 1 == col)) {
           board[rowPos][colpos] = -1;
           board[row][col] = tile;
       }
    }
    
    if (colPos == col) {
        if ((rowPos + 1 == row) || (rowPos - 1 == row)) {
            board[rowPos][colPos] = -1;
            board[row][col] = tile;
        }
    }
    
}",0
ajam744,1696231507,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowPos; 
    int colPos; 
    
    FindTile(board, rows, cols, tile, &rowPos, &colPos)
    
    int row; 
    int col; 
    
    FindTile(board, rows, cols  -1, &row, &col)
    
    if (rowPos == row && (colPos + 1 == col) || (colPos - 1 == col)) {
           board[rowPos][colpos] = -1;
           board[row][col] = tile;
    }
    
    if (colPos == col && (rowPos + 1 == row) || (rowPos - 1 == row)) {
            board[rowPos][colPos] = -1;
            board[row][col] = tile;
    }
    
}",0
ajam744,1696231882,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowPos; 
    int colPos; 
    
    FindTile(board, int tile, int *rowPos, int *colPos)
    
    int row; 
    int col; 
    
    FindTile(board, -1, &row, &col)
    
    if (rowPos == row && (colPos + 1 == col) || (colPos - 1 == col)) {
           board[rowPos][colpos] = -1;
           board[row][col] = tile;
    }
    
    if (colPos == col && (rowPos + 1 == row) || (rowPos - 1 == row)) {
            board[rowPos][colPos] = -1;
            board[row][col] = tile;
    }
    
}",0
ajam744,1696231928,5,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowPos; 
    int colPos; 
    
    FindTile(board, int tile, int &rowPos, int &colPos)
    
    int row; 
    int col; 
    
    FindTile(board, int -1, int &row, int &col)
    
    if (rowPos == row && (colPos + 1 == col) || (colPos - 1 == col)) {
           board[rowPos][colpos] = -1;
           board[row][col] = tile;
    }
    
    if (colPos == col && (rowPos + 1 == row) || (rowPos - 1 == row)) {
            board[rowPos][colPos] = -1;
            board[row][col] = tile;
    }
    
}",0
ajam744,1696233848,6,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowPos; 
    int colPos; 
    
    FindTile(board, int tile, int &rowPos, int &colPos)
    
    int row; 
    int col; 
    
    FindTile(board, int -1, int &row, int &col)
    
    if ((rowPos == row) && (colPos + 1 == col) || (colPos - 1 == col)) {
           board[rowPos][colpos] = -1;
           board[row][col] = tile;
    }
    
    if ((colPos == col) && (rowPos + 1 == row) || (rowPos - 1 == row)) {
            board[rowPos][colPos] = -1;
            board[row][col] = tile;
    }
    
}",0
ajeo563,1696052389,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j, tile_row, tile_col;


	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {

			if (board[i][j] == tile) {

				tile_row = i;
				tile_col = j;
			}
		}
	}
	
	if (tile_row > 0) {
		if (board[tile_row - 1][tile_col] == -1) {

			board[tile_row - 1][tile_col] = board[tile_row][tile_col];
			board[tile_row][tile_col] = -1;
		}
	}

	if (tile_col > 0) {
		if (board[tile_row][tile_col - 1] == -1) {

			board[tile_row][tile_col - 1] = board[tile_row][tile_col];
			board[tile_row][tile_col] = -1;
		}
	}

	if (tile_row < 3) {
		if (board[tile_row + 1][tile_col] == -1) {

			board[tile_row + 1][tile_col] = board[tile_row][tile_col];
			board[tile_row][tile_col] = -1;
		}
	}

	if (tile_col < 3) {
		if (board[tile_row][tile_col + 1] == -1) {
            
			board[tile_row][tile_col + 1] = board[tile_row][tile_col];
			board[tile_row][tile_col] = -1;
		}
	}
}",1
ajhz010,1695711308,1,"void MakeMove(int board[4][4], int tile)
{
    int i, j;
    for (i = 0; i < 4; i++) {
        for (j = 0; i < 4; j++) {
            if (board[i][j] == tile) {
                // = board[j+4];
               // minusOne = board[j-1];
                //plusOne = board[j+1];
               // mineFour = board[j-4]
                if (board[i][j+4] == -1) {
                    board[i][j] = -1;
                    board[i][j+4] = tile;
                    return;
                }
                else if (board[i][j-1] == -1) {
                    board[i][j] = -1;
                    board[i][j-1] = tile;
                    return;
                }
                else if (board[i][j+1] == -1) {
                    board[i][j] = -1;
                    board[i][j+1] = tile;
                    return;
                }
                else if (board[i][j-4] == -1) {
                    board[i][j] = -1;
                    board[i][j-4] = tile;
                    return;
                }
            }
        }
    }       
    
    return;
}",0
ajhz010,1695711990,2,"void MakeMove(int board[4][4], int tile)
{
    int i, j;
    for (i = 0; i < 4; i++) {
        for (j = 0; i < 4; j++) {
            if (board[i][j] == tile) {
                // = board[j+4];
               // minusOne = board[j-1];
                //plusOne = board[j+1];
               // mineFour = board[j-4]
                if (board[i][j+4] == -1) {
                    board[i][j] = -1;
                    board[i][j+4] = tile;
                    return;
                }
                else if (board[i][j-1] == -1) {
                    board[i][j] = -1;
                    board[i][j-1] = tile;
                    return;
                }
                else if (board[i][j+1] == -1) {
                    board[i][j] = -1;
                    board[i][j+1] = tile;
                    return;
                }
                else if (board[i][j-4] == -1) {
                    board[i][j] = -1;
                    board[i][j-4] = tile;
                    return;
                }
                else {
                    return;
                }
            }
        }
    }       
}",0
ajhz010,1695712485,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int i, j;
    for (i = 0; i < NUM_ROWS; i++) {
        for (j = 0; i < NUM_COLS; j++) {
            if (tile > (NUM_COLS*NUM_ROWS)) {
                return;
            }
            
            if (board[i][j] == tile) {
                if (board[i][j+NUM_COLS] == -1) {
                    board[i][j] = -1;
                    board[i][j+NUM_COLS] = tile;
                    return;
                }
                else if (board[i][j-1] == -1) {
                    board[i][j] = -1;
                    board[i][j-1] = tile;
                    return;
                }
                else if (board[i][j+1] == -1) {
                    board[i][j] = -1;
                    board[i][j+1] = tile;
                    return;
                }
                else if (board[i][j-NUM_COLS] == -1) {
                    board[i][j] = -1;
                    board[i][j-NUM_COLS] = tile;
                    return;
                }
                else {
                    return;
                }
            }
        }
    }       
}",0
ajhz010,1695713740,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int i, j;
    for (i = 0; i < NUM_ROWS; i++) {
        for (j = 0; i < NUM_COLS; j++) {
            if (tile >= (NUM_COLS*NUM_ROWS)) {
                return;
            }
            if (tile < 0) {
                return;
            }
            
            if (board[i][j] == tile) {
                if (board[i][j+NUM_COLS] == -1) {
                    board[i][j] = -1;
                    board[i][j+NUM_COLS] = tile;
                    return;
                }
                else if (board[i][j-1] == -1) {
                    board[i][j] = -1;
                    board[i][j-1] = tile;
                    return;
                }
                else if (board[i][j+1] == -1) {
                    board[i][j] = -1;
                    board[i][j+1] = tile;
                    return;
                }
                else if (board[i][j-NUM_COLS] == -1) {
                    board[i][j] = -1;
                    board[i][j-NUM_COLS] = tile;
                    return;
                }
                else {
                    return;
                }
            }
        }
    }       
}",0
ajhz010,1695717964,5,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int i, j;

    if (tile>0 && tile<(NUM_ROWS*NUM_COLS))
    for (i = 0; i < NUM_ROWS; i++) {
        for (j = 0; i < NUM_COLS; j++) {
            if (board[i][j] == tile) {
                if (board[i][j+NUM_COLS] == -1) {
                    board[i][j] = -1;
                    board[i][j+NUM_COLS] = tile;
                    return;
                }
                else if (board[i][j-1] == -1) {
                    if (j%NUM_COLS == 0) {
                        return;
                    }
                    else {
                    board[i][j] = -1;
                    board[i][j-1] = tile;
                    return;
                    }
                }
                else if (board[i][j+1] == -1) {
                    if ((j+1)%NUM_COLS == 0) {
                        return;
                    }
                    else {
                    board[i][j] = -1;
                    board[i][j+1] = tile;
                    return;
                    }
                }
                else if (board[i][j-NUM_COLS] == -1) {
                    board[i][j] = -1;
                    board[i][j-NUM_COLS] = tile;
                    return;
                }
                else {
                    return;
                }
            }
        }
    }
    else {
        return;
    }
}",1
ajhz011,1695689251,1,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile);

	int row, col;

	FindTile(board, -1, &row, &col);

	if (tile == board[row++][col] || tile == board[row--][col] || tile == board[row][col--] || tile == board[row][col++])
		board[row][col] = tile;

}
",0
ajhz011,1695699755,2,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, row2, col2;

	FindTile(board, -1, &row, &col);

	if (tile == board[row + 1][col] || tile == board[row - 1][col] || tile == board[row][col - 1] || tile == board[row][col + 1]) {
		for (row2 = 0; row2 < 4; row2++) {
			for (col2 = 0; col2 < 4; col2++) {
				if (tile == board[row2][col2]) {
					board[row2][col2] = -1;
					board[row][col] = tile;
					break;
				}
			}
		}
	}
}",0
ajhz011,1695707872,3,"void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int* rowPos, int* colPos)
{
	int rows, cols;

	for (rows = 0; rows < 4; rows++) {
		for (cols = 0; cols < 4; cols++) {
			if (board[rows][cols] == -1) {
				*colPos = cols;
				*rowPos = rows;
			}
		}
	}
}

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, row2, col2, tempArray[4] = { 0 };

	FindTile(board, -1, &row, &col);

	if (tile == board[row + 1][col] || tile == board[row - 1][col] || tile == board[row][col - 1] || tile == board[row][col + 1]) {
		for (row2 = 0; row2 < 4; row2++) {
			for (col2 = 0; col2 < 4; col2++) {
				if (col == 3) {
					if (tile == board[row + 1][col] || tile == board[row - 1][col] || tile == board[row][col - 1]) {
						if (tile == board[row2][col2]) {
							board[row2][col2] = -1;
							board[row][col] = tile;
							break;
						}
					}
				}

				else if (col == 0) {
					if (tile == board[row + 1][col] || tile == board[row - 1][col] || tile == board[row][col + 1]) {
						if (tile == board[row2][col2]) {
							board[row2][col2] = -1;
							board[row][col] = tile;
							break;
						}
					}
				}
				else if (tile == board[row2][col2]) {
						board[row2][col2] = -1;
						board[row][col] = tile;
						break;
				}
			}
		}
	}
}",0
ajhz011,1695707923,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, row2, col2;

	FindTile(board, -1, &row, &col);

	if (tile == board[row + 1][col] || tile == board[row - 1][col] || tile == board[row][col - 1] || tile == board[row][col + 1]) {
		for (row2 = 0; row2 < 4; row2++) {
			for (col2 = 0; col2 < 4; col2++) {
				if (col == 3) {
					if (tile == board[row + 1][col] || tile == board[row - 1][col] || tile == board[row][col - 1]) {
						if (tile == board[row2][col2]) {
							board[row2][col2] = -1;
							board[row][col] = tile;
							break;
						}
					}
				}

				else if (col == 0) {
					if (tile == board[row + 1][col] || tile == board[row - 1][col] || tile == board[row][col + 1]) {
						if (tile == board[row2][col2]) {
							board[row2][col2] = -1;
							board[row][col] = tile;
							break;
						}
					}
				}
				else if (tile == board[row2][col2]) {
						board[row2][col2] = -1;
						board[row][col] = tile;
						break;
				}
			}
		}
	}
}",1
ajhz216,1695873795,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int erow;
	int ecol;
	int trow;
	int tcol;

	for (int i = 0; i < NUM_ROWS; i++) {
		for (int j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == -1) {
				erow = i;
				ecol = j;
			}
		}
	}

	for (int x = 0; x < NUM_ROWS; x++) {
		for (int y = 0; y < NUM_COLS; y++) {
			if (board[x][y] == tile) {
				trow = x;
				tcol = y;
			}
		}
	}

	if (((erow == trow + 1 || erow == trow -1) && tcol == ecol) || ((ecol == tcol + 1 || ecol == tcol - 1) && trow == erow)) {
		board[trow][tcol] = -1;
		board[erow][ecol] = tile;
	}
}",1
ajhz318,1695707281,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row;
	int col;
	int newPos;
	int temp;

	FindTile(board, tile, &row, &col);

	newPos = board[row][col];

	if (0 < row < 2 && board[row + 1][col]  == -1) {
		temp = board[row][col];
		board[row][col] = -1;
		board[row + 1][col] = temp;
	}
	else if (1 < row < 3 && board[row - 1][col]  == -1) {
		temp = board[row][col];
		board[row][col] = -1;
		board[row - 1][col] = temp;
	}
	else if (0  < col < 2 && board[row][col + 1]  == -1) {
		temp = board[row][col];
		board[row][col] = -1;
		board[row][col + 1] = temp;
	}
	else if (1 < col < 3 && board[row][col - 1]  == -1) {
		temp = board[row][col];
		board[row][col] = -1;
		board[row][col - 1] = temp;
	}
	else {

	}

}",0
ajhz318,1695710133,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row;
	int col;
	int temp;
	int row2;
	int col2;

	FindTile(board, tile, &row, &col);
	FindTile(board, -1, &row2, &col2);

	if (board[row + 1][col]  == -1) {
		temp = board[row][col];
		board[row][col] = -1;
		board[row + 1][col] = temp;
	}
	else if (board[row - 1][col]  == -1) {
		temp = board[row][col];
		board[row][col] = -1;
		board[row - 1][col] = temp;
	}
	else if (row == row2 && board[row][col + 1]  == -1) {
		temp = board[row][col];
		board[row][col] = -1;
		board[row][col + 1] = temp;
	}
	else if (row == row2 && board[row][col - 1]  == -1) {
		temp = board[row][col];
		board[row][col] = -1;
		board[row][col - 1] = temp;
	}
	else {

	}
}",1
ajhz444,1695782451,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, temp;
	FindTile(board, tile, &row, &col);
	if ((board[row - 1][col] == -1) && (row - 1 >= 0)) {
		temp = board[row][col];
		board[row][col] = -1;
		board[row - 1][col]= temp;
	}
	else if ((board[row][col + 1] == -1) && (col + 1 <= NUM_COLS - 1)) {
		temp = board[row][col];
		board[row][col] = -1;
		board[row][col + 1] = temp;
	}
	else if ((board[row + 1][col] == -1) && (row + 1 <= NUM_ROWS - 1)) {
		temp = board[row][col];
		board[row][col] = -1;
		board[row + 1][col] = temp;
	}
	else if ((board[row][col - 1] == -1) && (col - 1 >= 0)) {
		temp = board[row][col];
		board[row][col] = -1;
		board[row][col - 1] = temp;
	}
}",1
ajhz488,1696230682,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;
	FindTile(board, tile, &row, &col);
	if (row > 0) {
		if (board[row-1][col] == -1) {
			board[row-1][col] = tile;
			board[row][col] = -1;
		} else {
			if (board[row+1][col] == -1) {
				board[row+1][col] = tile;
				board[row][col] = -1;
			}
		}
	} 

	if (col > 0) {
		if (board[row][col-1] == -1) {
			board[row][col-1] = tile;
			board[row][col] = -1;
		} else {
			if (board[row][col+1] == -1) {
				board[row][col+1] = tile;
				board[row][col] = -1;
			}
		}
	} 
}",0
ajhz488,1696230813,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;
	FindTile(board, tile, &row, &col);
	
		if (board[row-1][col] == -1) {
			board[row-1][col] = tile;
			board[row][col] = -1;
		} else {
			if (board[row+1][col] == -1) {
				board[row+1][col] = tile;
				board[row][col] = -1;
			}
		}
	

	
		if (board[row][col-1] == -1) {
			board[row][col-1] = tile;
			board[row][col] = -1;
		} else {
			if (board[row][col+1] == -1) {
				board[row][col+1] = tile;
				board[row][col] = -1;
			}
		}
	
}",0
ajhz488,1696231849,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;
	row = 0;
	col = 0;
	FindTile(board, tile, &row, &col);
	
	if (board[row-1][col] == -1) {
		board[row-1][col] = tile;
		board[row][col] = -1;
	}
	if (board[row+1][col] == -1) {
		board[row+1][col] = tile;
		board[row][col] = -1;
	}
	
	if (board[row][col-1] == -1) {
		board[row][col-1] = tile;
		board[row][col] = -1;
	}
	if (board[row][col+1] == -1) {
		board[row][col+1] = tile;
		board[row][col] = -1;
	}
	
}",0
ajhz488,1696239135,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;
	row = 0;
	col = 0;
	FindTile(board, tile, &row, &col);
	
	if (board[row-1][col] == -1) {

			board[row-1][col] = tile;
			board[row][col] = -1;
		
	}
	if (board[row+1][col] == -1) {

		board[row+1][col] = tile;
		board[row][col] = -1;
	
	}
	if (board[row][col-1] == -1) {
		if (col == 0) {
		} else {
			board[row][col-1] = tile;
			board[row][col] = -1;
		}
	}
	if (board[row][col+1] == -1) {
		if (col == 3) {
		} else {
			board[row][col+1] = tile;
			board[row][col] = -1;
		}
	}
}",1
ajin489,1695798419,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    int t_row, t_col, g_row, g_col, temp;
    FindTile(board, tile, &t_row, &t_col);
    FindTile(board, -1, &g_row, &g_col);
    if (t_row == g_row){
        if ((t_col - g_col == -1) || (t_col - g_col == 1)){
            temp = board[t_row][t_col];
            board[t_row][t_col] = -1;
            board[g_row][g_col] = temp;
        }
    }
    if (t_col == g_col){
        if ((t_row - g_row == -1) || (t_row - g_row == 1)){
            temp = board[t_row][t_col];
            board[t_row][t_col] = -1;
            board[g_row][g_col] = temp;
        }
    }
}",1
ajoh511,1695784514,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row_num, col_num;
	int row_tile, col_tile;

	FindTile(board, tile, &row_num, &col_num);
	FindTile(board, -1, &row_tile, &col_tile);

	if (row_num == row_tile && (col_tile + 1 == col_num || col_tile + 1 == col_num)) {

		board[row_tile][col_tile] = tile;
		board[row_num][col_num] = -1;
	}

	if (col_num == col_tile && (row_tile + 1 == row_num || row_tile -1 == row_num)) {

		board[row_tile][col_tile] = tile;
		board[row_num][col_num] = -1;
	}

}",0
ajoh511,1695786199,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row_num, col_num;
	int row_tile, col_tile;

	FindTile(board, tile, &row_num, &col_num); // finding the posn. of the chosen #tile
	FindTile(board, -1, &row_tile, &col_tile); // finding where the empty space is


    if (row_num == row_tile) {
        if (col_tile - col_num == 1 || col_num - col_tile == 1) {

            board[row_tile][col_tile] = tile;
            board[row_num][col_num] = -1;
        }
    }

        if (col_num == col_tile) {
            if (row_tile - row_num == 1 || row_num - row_tile == 1) {

                board[row_tile][col_tile] = tile;
                board[row_num][col_num] = -1;
        }
    }

}",1
akam256,1696244182,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{ 
int gg;
int ff;
int kk;
int jj;
int omegalul;

FindTile(board, -1, &gg, &ff);
Findtile(board, tile, &kk, &jj);

if ((gg - kk == 1 || kk - gg == 1) && (ff == jj) || (gg == kk) && (ff - jj == 1) || (jj - ff == -1)) {
omegalul = board[gg][kk];
board[gg][kk] = bpard[ff][jj];
board[ff][jj] = omegalul;
}


}
/*",0
akam256,1696244208,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{ 
int gg;
int ff;
int kk;
int jj;
int omegalul;


if ((gg - kk == 1 || kk - gg == 1) && (ff == jj) || (gg == kk) && (ff - jj == 1) || (jj - ff == -1)) {
omegalul = board[gg][kk];
board[gg][kk] = bpard[ff][jj];
board[ff][jj] = omegalul;
}


}
/*",0
akam256,1696244221,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{ 
int gg;
int ff;
int kk;
int jj;
int omegalul;


if ((gg - kk == 1 || kk - gg == 1) && (ff == jj) || (gg == kk) && (ff - jj == 1) || (jj - ff == -1)) {
omegalul = board[gg][kk];
board[gg][kk] = bpard[ff][jj];
board[ff][jj] = omegalul;
}


}
",0
aker238,1695626435,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int nrow, ncol,r,c;
    FindTile(board,tile,&nrow,&ncol);
    FindTile(board,-1,&r,&c);
    if (nrow == r - 1 || nrow == r + 1){
        if (ncol == c || ncol == c){
            board[r][c] = tile;
            board[nrow][ncol] = -1;
        }
    }
    if (ncol == c - 1 || ncol == c + 1){
        if (nrow == r || nrow == r){
            board[r][c] = tile;
            board[nrow][ncol] = -1;
        }
    }
}",1
akin699,1696239050,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tile_row;
	int tile_col;
	FindTile(board, tile, &tile_row, &tile_col);
	int emptytile_row;
	int emptytile_col;
	int empty_tile;
	empty_tile = -1;
	FindTile(board, empty_tile, &emptytile_row, &emptytile_col);
	
	if (((tile_row + 1 <= NUM_ROWS) && (tile_row - 1 >= 0)) && ((tile_col + 1 <= NUM_COLS) && (tile_col - 1 >= 0)))  {
		if ((emptytile_row == tile_row && (tile_col + 1 == emptytile_col || tile_col - 1 == emptytile_col)) || (emptytile_col == tile_col && (tile_row + 1 == emptytile_row || tile_row - 1 == emptytile_row))) {
			board[tile_row][tile_col] = empty_tile;
			board[emptytile_row][emptytile_col] = tile;
		}
	}
	else if (((emptytile_row + 1 <= NUM_ROWS) && (emptytile_row - 1 >= 0)) && ((emptytile_col + 1 <= NUM_COLS) && (emptytile_col - 1 >= 0)))  {
		if ((emptytile_row == tile_row && (tile_col + 1 == emptytile_col || tile_col - 1 == emptytile_col)) || (emptytile_col == tile_col && (tile_row + 1 == emptytile_row || tile_row - 1 == emptytile_row))) {
			board[tile_row][tile_col] = empty_tile;
			board[emptytile_row][emptytile_col] = tile;
		}
	}
	else {
		if ((emptytile_row == tile_row && (tile_col + 1 == emptytile_col || tile_col - 1 == emptytile_col)) || (emptytile_col == tile_col && (tile_row + 1 == emptytile_row || tile_row - 1 == emptytile_row))) {
			board[tile_row][tile_col] = empty_tile;
			board[emptytile_row][emptytile_col] = tile;
		}
	}
}",1
akmu146,1696229705,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowPos, colPos, emptyRow, emptyCol;
    for (int i = 0; i < NUM_ROWS; i++) {
		for (int j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == tile) {
				rowPos = i;
				colPos = j;
				break;
			}
			if (board[i][j] == -1) {
                emptyRow = i;
                emptyCol = j;
            }
		}
	}
    if ((rowPos == emptyRow && (colPos == emptyCol - 1 || colPos == emptyCol + 1)) ||
       (colPos == emptyCol && (rowPos == emptyRow - 1 || rowPos == emptyRow + 1))) {
        board[emptyRow][emptyCol] = tile;
        board[rowPos][colPos] = -1;
    }
}",0
akmu146,1696230539,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowPos, colPos, emptyRow, emptyCol;
   FindTile(board, -1, &emptyRow, &emptyCol);
   FindTile(board, tile, &rowPos, &colPos);
    if ((rowPos == emptyRow && (colPos == emptyCol - 1 || colPos == emptyCol + 1)) ||
       (colPos == emptyCol && (rowPos == emptyRow - 1 || rowPos == emptyRow + 1))) {
        board[emptyRow][emptyCol] = tile;
        board[rowPos][colPos] = -1;
    }
}",1
akod059,1696055548,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowInput, colInput;
	int rowEmpty, colEmpty;

	FindTile(board, tile, &rowInput, &colInput);
	FindTile(board, -1, &rowEmpty, &colEmpty);
	
	if ((rowInput == rowEmpty && (colInput == colEmpty + 1)) || (rowInput == rowEmpty && (colInput == colEmpty - 1)) || (colInput == colEmpty && (rowInput == rowEmpty + 1)) || (colInput == colEmpty && (rowInput == rowEmpty - 1))) {
		board[rowEmpty][colEmpty] = tile;
		board[rowInput][colInput] = -1;
	}
	else {
		return;
	}
}",1
akri368,1696238775,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int x = 0;
	int row1;
	int col1;
	int row2;
	int col2;

	FindTile(board, tile, &row1, &col1);
	FindTile(board, -1, &row2, % col2);

	if ((row1 - row2 == 1 || row2 - row1 == 1) && (col1 == col2)) {
		x = 1
	}
	
	if ((col1 - col2 == 1 || col2 - col1 == 1) && (row1 == row2)) {
		x = 1
	}

	if (x == 1) {
		board[row1][col1] = -1;
		board[row2][col2] = tile;
	}
}",0
akri368,1696238791,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int x = 0;
	int row1;
	int col1;
	int row2;
	int col2;

	FindTile(board, tile, &row1, &col1);
	FindTile(board, -1, &row2, & col2);

	if ((row1 - row2 == 1 || row2 - row1 == 1) && (col1 == col2)) {
		x = 1
	}
	
	if ((col1 - col2 == 1 || col2 - col1 == 1) && (row1 == row2)) {
		x = 1
	}

	if (x == 1) {
		board[row1][col1] = -1;
		board[row2][col2] = tile;
	}
}",0
akri368,1696238799,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int x = 0;
	int row1;
	int col1;
	int row2;
	int col2;

	FindTile(board, tile, &row1, &col1);
	FindTile(board, -1, &row2, & col2);

	if ((row1 - row2 == 1 || row2 - row1 == 1) && (col1 == col2)) {
		x = 1;
	}
	
	if ((col1 - col2 == 1 || col2 - col1 == 1) && (row1 == row2)) {
		x = 1;
	}

	if (x == 1) {
		board[row1][col1] = -1;
		board[row2][col2] = tile;
	}
}",1
akwo440,1696172608,1,"#include <stdio.h>
#include <stdlib.h>
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tileRow; int tileCol;
	int emptRow; int emptCol;
	int tempBoard;
	FindTile(board, tile, &tileRow,&tileCol);
	FindTile(board, -1, &emptRow,&emptCol);
	if ((abs(board[tileRow][tileCol+1]) == 1) | (abs(board[tileRow][tileCol-1]) == 1) | (abs(board[tileRow+1][tileCol]) == 1) | (abs(board[tileRow-1][tileCol]) == 1))
    {
	tempBoard = board[tileRow][tileCol];
	board[tileRow][tileCol] = board[emptRow][emptCol];
	board[emptRow][emptCol] = tempBoard;
    }
	
}",0
akwo440,1696173861,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tileRow; int tileCol;
	int emptRow; int emptCol;
	int tempBoard;
	FindTile(board, tile, &tileRow,&tileCol);
	FindTile(board, -1, &emptRow,&emptCol);
    //*printf(""E%d\nW%d\nS%d\nN%d\n"",board[tileRow][tileCol+1],board[tileRow][tileCol-1],board[tileRow+1][tileCol],board[tileRow-1][tileCol]);
	if (((board[tileRow][tileCol+1] == -1) && tileCol+1 < NUM_COLS)  | ((board[tileRow][tileCol-1] == -1) && tileCol-1 >= 0) | ((board[tileRow+1][tileCol] == -1) && tileRow+1 < NUM_ROWS) | ((board[tileRow-1][tileCol] == -1)) && tileRow-1 >= 0)
    {
	tempBoard = board[tileRow][tileCol];
	board[tileRow][tileCol] = board[emptRow][emptCol];
	board[emptRow][emptCol] = tempBoard;
    }
	
}",0
akwo440,1696174403,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tileRow; int tileCol;
	int emptRow; int emptCol;
	int tempBoard;
	FindTile(board, tile, &tileRow,&tileCol);
	FindTile(board, -1, &emptRow,&emptCol);
    //*printf(""E%d\nW%d\nS%d\nN%d\n"",board[tileRow][tileCol+1],board[tileRow][tileCol-1],board[tileRow+1][tileCol],board[tileRow-1][tileCol]);
	if (((board[tileRow][tileCol+1] == -1) && tileCol+1 <= NUM_COLS)  || ((board[tileRow][tileCol-1] == -1) && tileCol-1 >= 0) || ((board[tileRow+1][tileCol] == -1) && tileRow+1 <= NUM_ROWS) || ((board[tileRow-1][tileCol] == -1)) && tileRow-1 >= 0)
    {
	tempBoard = board[tileRow][tileCol];
	board[tileRow][tileCol] = board[emptRow][emptCol];
	board[emptRow][emptCol] = tempBoard;
    }
	
}",0
akwo440,1696174540,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tileRow; int tileCol;
	int emptRow; int emptCol;
	int tempBoard;
	FindTile(board, tile, &tileRow,&tileCol);
	FindTile(board, -1, &emptRow,&emptCol);
    //*printf(""E%d\nW%d\nS%d\nN%d\n"",board[tileRow][tileCol+1],board[tileRow][tileCol-1],board[tileRow+1][tileCol],board[tileRow-1][tileCol]);
	if (((board[tileRow][tileCol+1] == -1) && tileCol+1 <= NUM_COLS)  || ((board[tileRow][tileCol-1] == -1) && tileCol-1 >= 0) || ((board[tileRow+1][tileCol] == -1) && tileRow+1 <= NUM_ROWS) || ((board[tileRow-1][tileCol] == -1) && tileRow-1 >= 0))
    {
	tempBoard = board[tileRow][tileCol];
	board[tileRow][tileCol] = board[emptRow][emptCol];
	board[emptRow][emptCol] = tempBoard;
    }
	
}",1
alum086,1696195329,1,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos) {
    // Implementation as described earlier
    // ...
}

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol, tileRow, tileCol;
    
    // Find the positions of the empty tile and the tile to be moved
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);
    
    // Check if the tile can be moved (is adjacent to the empty tile)
    if ((emptyRow == tileRow && (emptyCol == tileCol + 1 || emptyCol == tileCol - 1)) ||
        (emptyCol == tileCol && (emptyRow == tileRow + 1 || emptyRow == tileRow - 1))) {
        // Swap the tile and the empty tile
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}

int main() {
    int board[NUM_ROWS][NUM_COLS] = {
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9, 10, 11, 12},
        {-1, 13, 14, 15}
    };

    // Perform a move (e.g., moving tile 13)
    MakeMove(board, 13);

    // Display the updated board
    for (int row = 0; row < NUM_ROWS; row++) {
        for (int col = 0; col < NUM_COLS; col++) {
            printf(""%2d "", board[row][col]);
        }
        printf(""\n"");
    }

    return 0;
}
",0
amac853,1696200236,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rPos, cPos;
    int eRow, eCol;
    FindTile(board,tile,&rPos,&cPos);
    FindTile(board,-1,&eRow,&eCol);
    if (((rPos == eRow)) && (cPos == (eCol-1) || cPos == (eCol+1) || cPos == eCol))
    {
        printf(""first, row: %d col: %d\n"",rPos,cPos);
        board[eRow][eCol] = board[rPos][cPos];
        board[rPos][cPos] = -1;
    }
    else if ((rPos == (eRow-1) || rPos == (eRow+1) || rPos == eRow) && (cPos == eCol))
    {
        printf(""second, row: %d col: %d\n"",rPos,cPos);
        board[eRow][eCol] = board[rPos][cPos];
        board[rPos][cPos] = -1;
    }
   
}",0
amac853,1696200274,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rPos, cPos;
    int eRow, eCol;
    FindTile(board,tile,&rPos,&cPos);
    FindTile(board,-1,&eRow,&eCol);
    if (((rPos == eRow)) && (cPos == (eCol-1) || cPos == (eCol+1) || cPos == eCol))
    {
        board[eRow][eCol] = board[rPos][cPos];
        board[rPos][cPos] = -1;
    }
    else if ((rPos == (eRow-1) || rPos == (eRow+1) || rPos == eRow) && (cPos == eCol))
    {
        board[eRow][eCol] = board[rPos][cPos];
        board[rPos][cPos] = -1;
    }
   
}",1
amag544,1696242710,1,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {

    for (int row = 0; row < NUM_ROWS; row++) {
        for (int columns = 0; columns < NUM_COLS; columns++) {
            if (board[row][columns] == -1) {
                emptyrow = row;
                emptycolumn = columns;
                break;
            }
        }
    }

    if (emptyrow >= 0 && emptycolumn >= 0) {
        if (
            (emptyrow > 0 && board[emptyrow - 1][emptycolumn] == tile) || 
            (emptyrow < NUM_ROWS - 1 && board[emptyrow + 1][emptycolumn] == tile) ||
            (emptycolumn > 0 && board[emptyrow][emptycolumn - 1] == tile) ||
            (emptycolumn < NUM_COLS - 1 && board[emptyrow][emptycolumn + 1] == tile)) { 
            board[emptyrow][emptycolumn] = tile;
        }
    }
}",0
amag544,1696242812,2,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    
    int emptyrow;
    int emptycolumn;

    for (int row = 0; row < NUM_ROWS; row++) {
        for (int columns = 0; columns < NUM_COLS; columns++) {
            if (board[row][columns] == -1) {
                emptyrow = row;
                emptycolumn = columns;
                break;
            }
        }
    }

    if (emptyrow >= 0 && emptycolumn >= 0) {
        if (
            (emptyrow > 0 && board[emptyrow - 1][emptycolumn] == tile) || 
            (emptyrow < NUM_ROWS - 1 && board[emptyrow + 1][emptycolumn] == tile) ||
            (emptycolumn > 0 && board[emptyrow][emptycolumn - 1] == tile) ||
            (emptycolumn < NUM_COLS - 1 && board[emptyrow][emptycolumn + 1] == tile)) { 
            board[emptyrow][emptycolumn] = tile;
        }
    }
}
",0
amag544,1696243022,3,"#include <stdio.h>


void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyrow;
    int emptycolumn;

    for (int row = 0; row < NUM_ROWS; row++) {
        for (int col = 0; col < NUM_COLS; col++) {
            if (board[row][col] == -1) {
                emptyrow = row;
                emptycolumn = col;
                break;
            }
        }
    }

    if (emptyrow >= 0 && emptycolumn >= 0) {
        if ((emptyrow > 0 && board[emptyrow - 1][emptycolumn] == tile) ||
            (emptyrow < NUM_ROWS - 1 && board[emptyrow + 1][emptycolumn] == tile) ||
            (emptycolumn > 0 && board[emptyrow][emptycolumn - 1] == tile) ||
            (emptycolumn < NUM_COLS - 1 && board[emptyrow][emptycolumn + 1] == tile)) {
            board[emptyrow][emptycolumn] = tile;
            board[emptyrow][emptycolumn] = -1; 
        }
    }
}

",0
amah664,1696232987,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col; 
	FindTile(board, tile, &row, &col);
	if (row >= 0 && col >= 0 && board[row][col] == tile){
		if (row > 0 && board[row-1][col] == -1){
			board[row-1][col] = tile; 
			board[row][col] = -1; 
		}
		else if(row > 0 && board[row+1][col] == -1){
			board[row+1][col] = tile; 
			board[row][col] =  -1; 
		}
		else if(col > 0 && board[row][col-1] == -1){
			board[row][col-1] = tile; 
			board[row][col] = -1; 
		}
		else if(col > 0 && board[row][col+1] == -1){
			board[row][col+1] = tile; 
			board[row][col] = -1;
		}
	} 
	return; 
}",0
amah664,1696233591,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col; 

	FindTile(board, tile, &row, &col);
	if (row >= 0 && col >= 0 && board[row][col] == tile){
		if (row >= 0 && board[row-1][col] == -1){
			board[row-1][col] = tile; 
			board[row][col] = -1; 
		}
		else if(row >= 0 && board[row+1][col] == -1){
			board[row+1][col] = tile; 
			board[row][col] =  -1; 
		}
		else if(col >= 0 && board[row][col-1] == -1){
			board[row][col-1] = tile; 
			board[row][col] = -1; 
		}
		else if(col >= 0 && board[row][col+1] == -1){
			board[row][col+1] = tile; 
			board[row][col] = -1;
		}
	} 
	return; 
}",0
amah664,1696235529,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col; 

	FindTile(board, tile, &row, &col);
	if (row >= 0 && col >= 0 && board[row][col] == tile){
		if (row >= 0 && board[row-1][col] == -1){
			board[row-1][col] = tile; 
			board[row][col] = -1; 
		}
		else if(row < NUM_ROWS - 1 && board[row+1][col] == -1){
			board[row+1][col] = tile; 
			board[row][col] =  -1; 
		}
		else if(col > 0 && board[row][col-1] == -1){
			board[row][col-1] = tile; 
			board[row][col] = -1; 
		}
		else if(col < NUM_COLS - 1 && board[row][col+1] == -1){
			board[row][col+1] = tile; 
			board[row][col] = -1;
		}
	} 
	return; 
}",1
amal783,1695864917,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
	int emptyrow, emptycol, row, col;
	FindTile(board, -1, &emptyrow, &emptycol);
	FindTile(board, tile, &row, &col);

	int rowdiff, coldiff;

	rowdiff = row - emptyrow;
	rowdiff -= (rowdiff < 0) * rowdiff * 2;

	coldiff = col - emptycol;
	coldiff -= (coldiff < 0) * coldiff * 2;

	if (coldiff == 1 || rowdiff == 1) {
		board[emptyrow][emptycol] = board[row][col];
		board[row][col] = -1;
	}
}",0
amal783,1696126646,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
	int emptyrow, emptycol, row, col;
	FindTile(board, -1, &emptyrow, &emptycol);
	FindTile(board, tile, &row, &col);

	int rowdiff, coldiff;

	rowdiff = row - emptyrow;
	rowdiff -= (rowdiff < 0) * rowdiff * 2;

	coldiff = col - emptycol;
	coldiff -= (coldiff < 0) * coldiff * 2;

	if ((coldiff == 1 && rowdiff == 0) || (rowdiff == 1 && coldiff == 0)) {
		board[emptyrow][emptycol] = tile;
		board[row][col] = -1;
	}
}",1
amar516,1695700889,1,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
int row;
int col;

FindTile(board, -1, &row, &col);
int negative_1_row = row;
int negative_1_col = col;

FindTile(board, tile, &row, &col);

if (row == negative_1_row + 1  && col == negative_1_col){
	board[negative_1_row][negative_1_col] = tile;
	board[row][col] = -1;
elseif (row == negative_1_row - 1  && col == negative_1_col)
	board[negative_1_row][negative_1_col] = tile;
	board[row][col] = -1;
elseif (row == negative_1_row  && col == negative_1_col + 1)
	board[negative_1_row][negative_1_col] = tile;
	board[row][col] = -1;
elseif (row == negative_1_row  && col == negative_1_col - 1)
	board[negative_1_row][negative_1_col] = tile;
	board[row][col] = -1;
	}
return;
}",0
amar516,1695701082,2,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
int row;
int col;

FindTile(board, -1, &row, &col);
int negative_1_row = row;
int negative_1_col = col;

FindTile(board, tile, &row, &col);

if (row == negative_1_row + 1  && col == negative_1_col){
	board[negative_1_row][negative_1_col] = tile;
	board[row][col] = -1;
	}
else if (row == negative_1_row - 1  && col == negative_1_col){
	board[negative_1_row][negative_1_col] = tile;
	board[row][col] = -1;
	}
else if (row == negative_1_row  && col == negative_1_col + 1){
	board[negative_1_row][negative_1_col] = tile;
	board[row][col] = -1;
	}
else if (row == negative_1_row  && col == negative_1_col - 1){
	board[negative_1_row][negative_1_col] = tile;
	board[row][col] = -1;
	}
return;
}",1
amar704,1695629269,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int tileRow, tileCol, spaceRow, spaceCol;
    
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == tile) {
                tileRow = i;
                tileCol = j;
            }
            if (board[i][j] == -1) {
                spaceRow = i;
                spaceCol = j;
            }
        }
    }
    
    board[spaceRow][spaceCol] = tile;
    board[tileRow][tileCol] = -1;
}",0
amar704,1695630168,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    
    int tileRow, tileCol, spaceRow, spaceCol;
    
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == tile) {
                tileRow = i;
                tileCol = j;
            }
            if (board[i][j] == -1) {
                spaceRow = i;
                spaceCol = j;
            }
        }
    }
    
    if ((abs(spaceRow - tileRow) == 1 && spaceCol == tileCol) ||
        (abs(spaceCol - tileCol) == 1 && spaceRow == tileRow)) {
        board[spaceRow][spaceCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}",1
amat407,1695866329,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {

int emptyrow;
int emptycol;
int row;
int col;

FindTile(board, -1, &emptyrow, &emptycol);
FindTile(board, tile, &row, &col);

if (emptycol==0) {
 if (board[emptyrow+1][emptycol]==tile) {
    board[emptyrow][emptycol]=tile;
    board[row][col]=-1;
 } else if (board[emptyrow][emptycol+1]==tile) {
    board[emptyrow][emptycol]=tile;
    board[row][col]=-1;
 } else if (board[emptyrow-1][emptycol]==tile) {
    board[emptyrow][emptycol]=tile;
    board[row][col]=-1;
 }

} else if (emptycol==3) {
          if (board[emptyrow-1][emptycol]==tile) {
             board[emptyrow][emptycol]=tile;
             board[row][col]=-1;
          } else if (board[emptyrow][emptycol-1]==tile) {
                    board[emptyrow][emptycol]=tile;
                    board[row][col]=-1;
          } else if (board[emptyrow+1][emptycol]==tile) {
                    board[emptyrow][emptycol]=tile;
                    board[row][col]=-1;
         }
} else {
  if (board[emptyrow-1][emptycol]==tile) {
      board[emptyrow][emptycol]=tile;
      board[row][col]=-1;
  } else if (board[emptyrow][emptycol+1]==tile) {
                    board[emptyrow][emptycol]=tile;
                    board[row][col]=-1;
  } else if (board[emptyrow+1][emptycol]==tile) {
                    board[emptyrow][emptycol]=tile;
                    board[row][col]=-1;
  } else if (board[emptyrow][emptycol-1]==tile) {
                    board[emptyrow][emptycol]=tile;
                    board[row][col]=-1;
  }
}

}",1
amcm539,1696073024,1,"void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos)
{
/*We need to use a nested for loop to examine each element of the array/board*/
int i = 0;
int j =0;

for (i = 0; i < NUM_ROWS; i++) {
	for (j = 0; j < NUM_COLS; j++) {
		/*If element is -1, record the index position onto the two pointers*/
		if (board[i][j] == tile) {
			*rowPos = i;
			*colPos = j;
		}
	}
}
}",0
amcm539,1696237630,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
/*Find the position of the tile entered by the user*/
int userrow =0, usercol =0; //The coordinates of the numbered tile chosen by the user
int oguserrow =0, ogusercol =0; //These variables will remember the original user tile position
FindTile (board, tile, &userrow, &usercol);

//Find position of the -1 tile
int negativetilerow =0, negativetilecol=0;
int ognegativetilerow=0, ognegativetilecol=0; //These variables remember the original empty position
FindTile(board, -1, &negativetilerow, &negativetilecol);

/*Assign the remembering variables to their values*/
oguserrow = userrow;
ogusercol = usercol;
ognegativetilerow = negativetilerow;
ognegativetilecol = negativetilecol;


//Check if the users number and the empty tile are in the same column.
if(usercol == negativetilecol) {
	//If they are, now check if one is in the row above or below the other.
	if ((negativetilerow == userrow -1) || (negativetilerow == userrow +1)){

		//Now swap them around. Columns are the same so need to just swap the rows
		int temp_row = userrow;
		userrow = negativetilerow;
		negativetilerow = temp_row;

		/*Now we need to feed back the new variables into the main array*/

//New empty spot. is the old user number spot
board[userrow][usercol] = board[negativetilerow][negativetilecol];

//New user number spot is the old negative tile spot
board[negativetilerow][negativetilecol] = -1;
	}
	
}

if (userrow == negativetilerow){
	if ((negativetilecol == usercol -1) || (negativetilecol == usercol +1)){

		int temp_col = usercol;
		usercol = negativetilecol;
		negativetilecol = temp_col;

		/*Now we need to feed back the new variables into the main array*/

//New empty spot. is the old user number spot
board[userrow][usercol] = board[negativetilerow][negativetilecol];

//New user number spot is the old negative tile spot
board[negativetilerow][negativetilecol] = -1;
	}
	
}

}",0
amcm539,1696237731,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
/*Find the position of the tile entered by the user*/
int userrow =0, usercol =0; //The coordinates of the numbered tile chosen by the user
FindTile (board, tile, &userrow, &usercol);

//Find position of the -1 tile
int negativetilerow =0, negativetilecol=0;

FindTile(board, -1, &negativetilerow, &negativetilecol);

//Check if the users number and the empty tile are in the same column.
if(usercol == negativetilecol) {
	//If they are, now check if one is in the row above or below the other.
	if ((negativetilerow == userrow -1) || (negativetilerow == userrow +1)){

		//Now swap them around. Columns are the same so need to just swap the rows
		int temp_row = userrow;
		userrow = negativetilerow;
		negativetilerow = temp_row;

		/*Now we need to feed back the new variables into the main array*/

//New empty spot. is the old user number spot
board[userrow][usercol] = board[negativetilerow][negativetilecol];

//New user number spot is the old negative tile spot
board[negativetilerow][negativetilecol] = -1;
	}
	
}

if (userrow == negativetilerow){
	if ((negativetilecol == usercol -1) || (negativetilecol == usercol +1)){

		int temp_col = usercol;
		usercol = negativetilecol;
		negativetilecol = temp_col;

		/*Now we need to feed back the new variables into the main array*/

//New empty spot. is the old user number spot
board[userrow][usercol] = board[negativetilerow][negativetilecol];

//New user number spot is the old negative tile spot
board[negativetilerow][negativetilecol] = -1;
	}
	
}

}",1
amhk647,1695701036,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
	int row = 0; // empty tile row position
	int col = 0; // empty tile column position

	for (int i = 0; i < NUM_ROWS; i++) { // go through rows
		for (int j = 0; j < NUM_COLS; j++) { // go through columns
			if (board[i][j] == tile) { // find empty tile
				row = i;
				col = j;
			}
		}
	}

	if (row > 0 && board[row - 1][col] == -1) { // find empty tile above
		board[row - 1][col] = board[row][col]; // swap empty tile and chosen tile
		board[row][col] = -1;
	}
	else if (row < NUM_ROWS && board[row + 1][col] == -1) { // find empty tile below
		board[row + 1][col] = board[row][col]; // swap empty tile and chosen tile
		board[row][col] = -1;
	}
	else if (col > 0 && board[row][col - 1] == -1) { // find empty tile on left
		board[row][col - 1] = board[row][col]; // swap empty tile and chosen tile
		board[row][col] = -1;
	}
	else if (col < NUM_COLS && board[row][col + 1] == -1) { // find empty tile on right
		board[row][col + 1] = board[row][col]; // swap empty tile and chosen tile
		board[row][col] = -1;
	}
}",1
amok249,1695621565,1,"#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int i, j, rows, cols;
    for (i = 0; i < NUM_ROWS;i++) {
        for (j = 0; j < NUM_COLS;j++){
            if (board[i][j] == tile) {
                rows = i;
                cols = j;
                break;
            }
        }
    }
    if (board[rows][cols+1] == -1) {
        board[rows][cols] = board[rows][cols+1];
        board[rows][cols+1] =  tile;
        
    } else if (board[rows][cols-1] == -1) {
        board[rows][cols] = board[rows][cols-1];
        board[rows][cols-1] = tile;
        
    } else if (board[rows-1][cols] == -1) {
        board[rows][cols] = board[rows][cols-1];
        board[rows][cols-1] = tile;
        
    } else if (board[rows+1][cols] == -1) {
        board[rows][cols] = board[rows+1][cols];
        board[rows+1][cols] = tile;
    } 
    

}",0
amok249,1695622222,2,"#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int i, j, rows, cols;
    for (i = 0; i < NUM_ROWS;i++) {
        for (j = 0; j < NUM_COLS;j++){
            if (board[i][j] == tile) {
                rows = i;
                cols = j;
                break;
            }
        }
    }
    if (board[rows][cols+1] == -1) {
        board[rows][cols] = -1;
        board[rows][cols+1] =  tile;
        
    } else if (board[rows][cols-1] == -1) {
        board[rows][cols] = -1;
        board[rows][cols-1] = tile;
        
    } else if (board[rows-1][cols] == -1) {
        board[rows][cols] = -1;
        board[rows-1][cols] = tile;
        
    } else if (board[rows+1][cols] == -1) {
        board[rows][cols] = -1;
        board[rows+1][cols] = tile;
    } 
    

}",0
amok249,1695696757,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int i, j, rows, cols, negrows, negcols;
    for (i = 0; i < NUM_ROWS;i++) {
        for (j = 0; j < NUM_COLS;j++){
            if (board[i][j] == tile) {
                rows = i;
                cols = j;
            } else if (board[i][j] == -1){
                negrows = i;
                negcols = j;
            }
        }
    }
    
    if ((cols == 0 && negcols == NUM_ROWS-1 || cols == NUM_ROWS-1 && negcols == 0))
        {
        
    }
    else {
        if (board[rows][cols+1] == -1) {
        board[rows][cols] = -1;
        board[rows][cols+1] =  tile;
        
    }   else if (board[rows][cols-1] == -1) {
        board[rows][cols] = -1;
        board[rows][cols-1] = tile;
        
    }   else if (board[rows-1][cols] == -1) {
        board[rows][cols] = -1;
        board[rows-1][cols] = tile;
        
    }   else if (board[rows+1][cols] == -1) {
        board[rows][cols] = -1;
        board[rows+1][cols] = tile;
    } 
    }

}",0
amok249,1695697026,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int i, j, rows, cols, negcols;
    for (i = 0; i < NUM_ROWS;i++) {
        for (j = 0; j < NUM_COLS;j++){
            if (board[i][j] == tile) {
                rows = i;
                cols = j;
            } else if (board[i][j] == -1){
                negcols = j;
            }
        }
    }
    
    if (((cols == 0) && (negcols == NUM_ROWS-1)) || ((cols == NUM_ROWS-1) && (negcols == 0)))
        {
        
    }
    else {
        if (board[rows][cols+1] == -1) {
        board[rows][cols] = -1;
        board[rows][cols+1] =  tile;
        
    }   else if (board[rows][cols-1] == -1) {
        board[rows][cols] = -1;
        board[rows][cols-1] = tile;
        
    }   else if (board[rows-1][cols] == -1) {
        board[rows][cols] = -1;
        board[rows-1][cols] = tile;
        
    }   else if (board[rows+1][cols] == -1) {
        board[rows][cols] = -1;
        board[rows+1][cols] = tile;
    } 
    }

}",1
amur986,1696214856,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int rowPos;
    int colPos;
    FindTile(board, -1, &rowPos, &colPos);
    int tilerow;
    int colrow;
    FindTile(board, tile, &tilerow, &colrow);

    if (tilerow + 1 == rowPos && colrow == colPos) {
        board[tilerow][colrow] = -1;
        board[rowPos][colPos] = tile;
    }
    else if (tilerow - 1 == rowPos && colrow == colPos) {
        board[tilerow][colrow] = -1;
        board[rowPos][colPos] = tile;
    }
    else if (tilerow == rowPos && colrow + 1 == colPos) {
        board[tilerow][colrow] = -1;
        board[rowPos][colPos] = tile;
    
    }
    else if (tilerow == rowPos && colrow - 1 == colPos) {
        board[tilerow][colrow] = -1;
        board[rowPos][colPos] = tile;
    }
    return;
}",1
apan786,1696226375,1,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol;
    int tileRow, tileCol;
    

    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);
    

    if ((abs(tileRow - emptyRow) == 1 && tileCol == emptyCol) ||
        (abs(tileCol - emptyCol) == 1 && tileRow == emptyRow)) {
            
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }

    
}",1
apat750,1696144289,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int blankrow, blankcol;
    int tilerow, tilecol;

    /* locating postion of the empty square*/
    FindTile(board, -1, &blankrow, &blankcol);

    /* locating postion of the inputted tile value*/
    FindTile(board, tile, &tilerow, &tilecol);

    /*checking if the tile is adjacent to an empty square, replae the empty square with the tile, 
    and the tiel with the empty square if so*/
   if ((blankrow - 1 == tilerow && blankcol == tilecol) ||
    (blankrow + 1 == tilerow && blankcol == tilecol) ||
    (blankrow == tilerow && blankcol - 1 == tilecol) ||
    (blankrow == tilerow && blankcol + 1 == tilecol)) {
    /*changing the empty square to the tile value adn the tile value to the empty square*/
    board[blankrow][blankcol] = tile;
    board[tilerow][tilecol] = -1;  
} else {
    ;
}
}",1
apat824,1695960265,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int tileRow, tileCol;
    int emptyRow, emptyCol;
    
    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol);
    
   if (((tileRow == emptyRow) && (tileCol == emptyCol - 1) || (tileCol == emptyCol + 1)) ||
    ((tileCol == emptyCol) && (tileRow == emptyRow - 1) || (tileRow == emptyRow + 1))){
    board[emptyRow][emptyCol] = tile;
    board[tileRow][tileCol] = -1;
    }
}",0
apat824,1695960630,2,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4


void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int tRow, tCol;
    int emptyRow, emptyCol;
    
    FindTile(board, tile, &tRow, &tCol);
    FindTile(board, -1, &emptyRow, &emptyCol);
    
   if (((tRow == emptyRow) && (tCol == emptyCol - 1) || (Col == emptyCol + 1)) ||
    ((tCol == emptyCol) && (tRow == emptyRow - 1) || (tRow == emptyRow + 1))){
    board[emptyRow][emptyCol] = tile;
    board[tRow][tCol] = -1;
    } else {
        return;
        
    }
    
}",0
apat824,1695961726,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    
    int tRow, tCol;
    int emptyRow, emptyCol;
    
    FindTile(board, tile, &tRow, &tCol);
    FindTile(board, -1, &emptyRow, &emptyCol);
    
   if (((tRow == emptyRow) && (tCol == emptyCol - 1) || (tCol == emptyCol + 1)) ||
    ((tCol == emptyCol) && (tRow == emptyRow - 1) || (tRow == emptyRow + 1))){
    board[emptyRow][emptyCol] = tile;
    board[tRow][tCol] = -1;
    } else {
        return;
        
    }
}",0
apat824,1695962209,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    
    int tRow, tCol;
    int emptyRow, emptyCol;
    
    FindTile(board, tile, &tRow, &tCol);
    FindTile(board, -1, &emptyRow, &emptyCol);
    
   if (((tRow == emptyRow) && ((tCol == emptyCol - 1) || (tCol == emptyCol + 1))) ||
    ((tCol == emptyCol) && ((tRow == emptyRow - 1) || (tRow == emptyRow + 1)))) {
        board[emptyRow][emptyCol] = tile;
        board[tRow][tCol] = -1;
    }
}",1
apen181,1696066359,1,"#include <stdio.h>

/* The dimensions of the puzzle */
#define NUM_ROWS 4
#define NUM_COLS 4


void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row, col;
    FindTile(board, tile, &row, &col);

    if (row < NUM_ROWS - 1 && board[row + 1][col] == -1) {
        board[row + 1][col] = tile;
        board[row][col] = -1;
    }

    else if (row > 0 && board[row - 1][col] == -1) {
        board[row - 1][col] = tile;
        board[row][col] = -1;
    }
    else if (col < NUM_COLS - 1 && board[row][col + 1] == -1) {
        board[row][col + 1] = tile;
        board[row][col] = -1;
    }

    else if (col > 0 && board[row][col - 1] == -1) {
        board[row][col - 1] = tile;
        board[row][col] = -1;
    }
}",1
apur448,1696107285,1,"#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col, x, y;

    FindTile(board, tile, &x,  &y);
    FindTile(board, -1, &row, &col);
    
    if ((row <= NUM_ROWS -1) && ((x == row-1) || (x == row) || (x == row+1))) {
        if ((col <= NUM_COLS -1) && ((y == col-1) || (y == col) || (y == col+1))) {
            board[row][col] = board[x][y];
            board[x][y] = -1;
    }
    }
}",1
aqu284,1696232037,1,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
	// Finding position of blank tile
	int r, c;
	FindTile(board, -1, &r, &c);

	// Finding position of Input tile
	int R, C;
	FindTile(board, tile, &R, &C);

	// Checking for tile adjacency
	if (r == R + 1 || r == R - 1 || c == C + 1 || c == C - 1) {
		board[R][C] = -1;
		board[r][c] = tile;
	}
}",0
aqu284,1696233055,2,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
	// Finding position of blank tile
	int r, c;
	FindTile(board, -1, &r, &c);

	// Finding position of Input tile
	int R, C;
	FindTile(board, tile, &R, &C);

	// Checking for tile adjacency
	if ((r != 0 && r == R - 1)||( r != 4 && r == R + 1)|| r == R-4 || r == R+4 ) {
		board[R][C] = -1;
		board[r][c] = tile;
	}
}
}",0
aqu284,1696233072,3,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
	// Finding position of blank tile
	int r, c;
	FindTile(board, -1, &r, &c);

	// Finding position of Input tile
	int R, C;
	FindTile(board, tile, &R, &C);

	// Checking for tile adjacency
	if ((r != 0 && r == R - 1)||( r != 4 && r == R + 1)|| r == R-4 || r == R+4 ) {
		board[R][C] = -1;
		board[r][c] = tile;
	}
}",0
aqu284,1696233390,4,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
	// Finding position of blank tile
	int r, c;
	FindTile(board, -1, &r, &c);

	// Finding position of Input tile
	int R, C;
	FindTile(board, tile, &R, &C);

	// Checking for tile adjacency
	if ((r == R && +(c == C + 1 || c == C - 1)) || (c == C && (r == R+1 || r == R-1))){
		board[R][C] = -1;
		board[r][c] = tile;
	}
}",1
arah160,1695819455,1,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) 
{
    int tile_row, tile_col;
    FindTile(board, tile, &tile_row, &tile_col);

    int empty_row = tile_row;
    int empty_col = tile_col;

    if (tile_row - 1 >= 0 && board[tile_row - 1][tile_col] == -1) {
        empty_row = tile_row - 1; empty_col = tile_col;
    }
    else if (tile_row + 1 < NUM_ROWS && board[tile_row + 1][tile_col == -1]) {
        empty_row = tile_row + 1; empty_col = tile_col;
    }
    else if (tile_col - 1 >= 0 && board[tile_row][tile_col - 1] == -1 {
        empty_row = tile_row; empty_col = tile_col - 1;
    }
    else if (tile_col + 1 < NUM_COLS && board[tile_row][tile_col + 1] == -1){
        empty_row = tile_row; empty_col = tile_col + 1;
    }

    board[tile_row][tile_col] = -1;
    board[empty_row][empty_col] = tile;

}",0
arah160,1695820314,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) 
{
    int tile_row, tile_col;
    FindTile(board, tile, &tile_row, &tile_col);

    int empty_row = tile_row;
    int empty_col = tile_col;

    if (tile_row - 1 >= 0 && board[tile_row - 1][tile_col] == -1) 
        { empty_row = tile_row - 1; empty_col = tile_col; }
    else if (tile_row + 1 < NUM_ROWS && board[tile_row + 1][tile_col] == -1)
        { empty_row = tile_row + 1; empty_col = tile_col; }
    else if (tile_col - 1 >= 0 && board[tile_row][tile_col - 1] == -1)
        { empty_row = tile_row; empty_col = tile_col - 1; }
    else if (tile_col + 1 < NUM_COLS && board[tile_row][tile_col + 1] == -1)
        { empty_row = tile_row; empty_col = tile_col + 1; } 

    board[tile_row][tile_col] = -1;
    board[empty_row][empty_col] = tile;
}",1
arus530,1695624171,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row1, col1, row2, col2;

    FindTile(board, tile, &row1, &col1);
    FindTile(board, -1, &row2, &col2);

    if (col2 - col1 == 1 || col2 - col1 == -1){
        if (row2 - row1 == 0){
        board[row2][col2] = board[row1][col1];
        board[row1][col1] = -1;
        }
    }
    if (row2 - row1 == 1 || row2 - row1 == -1){
        if (col2 - col1 == 0){
        board[row2][col2] = board[row1][col1];
        board[row1][col1] = -1;
        }
    }
}",1
aryu462,1696230876,1,"#include <stdio.h>

#define NUM_ROWS 4 
#define NUM_COLS 4 

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int EmptyRow, EmptyCol;
    int TileRow, TileCol;
    int FoundTile = 0; 
    
    for(int 1-0; i <NUM_ROWS; i++) {
        for(int j= 0; j < NUM_COLS; j++) {
            if (board[i][j] ==  tile) {
                TileRow = i; 
                TileCol = j; 
                FoundTile = 1;
            }
            if (board[i][j] == -1) {
                EmptyRow = i; 
                EmptyCol = j; 
            }
        }
    }
    if (FoundTile) {
        if ((TileRow == EmptyRow && (TileCol == EmptyCol - 1 || TileCol == EmptyCol + 1)) ||
            (TileCol == EmptyCol && (TileRow == EmptyRow - 1 || TileRow == EmptyRow + 1))) { 
            board[EmptyRow][EmptyCol} = tile;
            board[TileRow][TileCol] = -1; 
        }
    }
}
",0
aryu462,1696231002,2,"#include <stdio.h>

#define NUM_ROWS 4 
#define NUM_COLS 4 

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int EmptyRow, EmptyCol;
    int TileRow, TileCol;
    int FoundTile = 0; 
    
    for(int i = 0; i < NUM_ROWS; i++) {
        for(int j= 0; j < NUM_COLS; j++) {
            if (board[i][j] ==  tile) {
                TileRow = i; 
                TileCol = j; 
                FoundTile = 1;
            }
            if (board[i][j] == -1) {
                EmptyRow = i; 
                EmptyCol = j; 
            }
        }
    }
    if (FoundTile) {
        if ((TileRow == EmptyRow && (TileCol == EmptyCol - 1 || TileCol == EmptyCol + 1)) ||
            (TileCol == EmptyCol && (TileRow == EmptyRow - 1 || TileRow == EmptyRow + 1))) { 
            board[EmptyRow][EmptyCol} = tile;
            board[TileRow][TileCol] = -1; 
        }
    }
}
",0
aryu462,1696231131,3,"#include <stdio.h>

#define NUM_ROWS 4 
#define NUM_COLS 4 

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol;
    int tileRow, tileCol;
    int foundTile = 0; 
    
    for(int i = 0; i < NUM_ROWS; i++) {
        for(int j= 0; j < NUM_COLS; j++) {
            if (board[i][j] ==  tile) {
                tileRow = i; 
                tileCol = j; 
                foundTile = 1;
            }
            if (board[i][j] == -1) {
                emptyRow = i; 
                emptyCol = j; 
            }
        }
    }
    if (foundTile) 
        if ((tileRow == emptyRow && (tileCol == emptyCol - 1 || tileCol == emptyCol + 1)) ||
            (tileCol == emptyCol && (tileRow == emptyRow - 1 || tileRow == emptyRow + 1))) { 
            board[emptyRow][emptyCol] = tile;
            board[tileRow][tileCol] = -1; 
        }
    }
}
",0
aryu462,1696231156,4,"#include <stdio.h>

#define NUM_ROWS 4 
#define NUM_COLS 4 

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol;
    int tileRow, tileCol;
    int foundTile = 0; 
    
    for(int i = 0; i < NUM_ROWS; i++) {
        for(int j= 0; j < NUM_COLS; j++) {
            if (board[i][j] ==  tile) {
                tileRow = i; 
                tileCol = j; 
                foundTile = 1;
            }
            if (board[i][j] == -1) {
                emptyRow = i; 
                emptyCol = j; 
            }
        }
    }
    if (foundTile) {
        if ((tileRow == emptyRow && (tileCol == emptyCol - 1 || tileCol == emptyCol + 1)) ||
            (tileCol == emptyCol && (tileRow == emptyRow - 1 || tileRow == emptyRow + 1))) { 
            board[emptyRow][emptyCol] = tile;
            board[tileRow][tileCol] = -1; 
        }
    }
}
",1
asaa285,1696229658,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int x;
    int y;
    FindTile(board, tile, &row, &col);
    for (int i = 0; i < NUM_ROWS; i++)
    {
        for (int j = 0; j < NUM_COLS; j++)
        {
            if (board[i][j] == -1)
            {
                x = i;
                y = j;
            }
        }
    }
    if ((row-x<=1)&&(col-y==0)||
        (row-x>=-1)&&(col-y==0)||
        (row-x==0)&&(col-y<=1)||
        (row-x==0)&&(col-y>=-1))
        {
        board[x][y] = tile;
        board[row][col] = -1;
    }
}",0
asaa285,1696229730,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col;
    int x;
    int y;
    FindTile(board, tile, &row, &col);
    for (int i = 0; i < NUM_ROWS; i++)
    {
        for (int j = 0; j < NUM_COLS; j++)
        {
            if (board[i][j] == -1)
            {
                x = i;
                y = j;
            }
        }
    }
    if ((row-x<=1)&&(col-y==0)||
        (row-x>=-1)&&(col-y==0)||
        (row-x==0)&&(col-y<=1)||
        (row-x==0)&&(col-y>=-1))
        {
        board[x][y] = tile;
        board[row][col] = -1;
    }
}",0
asaa285,1696229764,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col;
    int x;
    int y;
    FindTile(board, tile, &row, &col);
    for (int i = 0; i < NUM_ROWS; i++)
    {
        for (int j = 0; j < NUM_COLS; j++)
        {
            if (board[i][j] == -1)
            {
                x = i;
                y = j;
            }
        }
    }
    if (((row-x<=1)&&(col-y==0))||
        ((row-x>=-1)&&(col-y==0))||
        ((row-x==0)&&(col-y<=1))||
        ((row-x==0)&&(col-y>=-1)))
        {
        board[x][y] = tile;
        board[row][col] = -1;
    }
}",0
asaa285,1696229951,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int x;
    int y;
    FindTile(board, tile, &row, &col);
    for (int i = 0; i < NUM_ROWS; i++)
    {
        for (int j = 0; j < NUM_COLS; j++)
        {
            if (board[i][j] == -1)
            {
                x = i;
                y = j;
            }
        }
    }
    if ((row-x==1)&&(col-y==0)||
        (row-x==-1)&&(col-y==0)||
        (row-x==0)&&(col-y==1)||
        (row-x==0)&&(col-y==-1))
        {
        board[x][y] = tile;
        board[row][col] = -1;
    }
}
",0
asaa285,1696229967,5,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col;
    int x;
    int y;
    FindTile(board, tile, &row, &col);
    for (int i = 0; i < NUM_ROWS; i++)
    {
        for (int j = 0; j < NUM_COLS; j++)
        {
            if (board[i][j] == -1)
            {
                x = i;
                y = j;
            }
        }
    }
    if ((row-x==1)&&(col-y==0)||
        (row-x==-1)&&(col-y==0)||
        (row-x==0)&&(col-y==1)||
        (row-x==0)&&(col-y==-1))
        {
        board[x][y] = tile;
        board[row][col] = -1;
    }
}
",0
asaa285,1696229984,6,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col;
    int x;
    int y;
    FindTile(board, tile, &row, &col);
    for (int i = 0; i < NUM_ROWS; i++)
    {
        for (int j = 0; j < NUM_COLS; j++)
        {
            if (board[i][j] == -1)
            {
                x = i;
                y = j;
            }
        }
    }
    if (((row-x==1)&&(col-y==0))||
        ((row-x==-1)&&(col-y==0))||
        ((row-x==0)&&(col-y==1))||
        ((row-x==0)&&(col-y==-1)))
        {
        board[x][y] = tile;
        board[row][col] = -1;
    }
}
",1
asah845,1696119274,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{

int i, j;
int row, col;


FindTile(board, int tile, &row, &col)

if (board[row + 1][col] == -1) {
	board[row][col] = -1;
	board[row + 1][col] = tile;

} else if (board[row - 1][col] == -1) {
	board[row][col] = -1;
	board[row - 1][col] = tile;

} else if (board[row][col + 1] == -1) {
	board[row][col] = -1;
	board[row][col + 1] = tile;

} else if (board[row][col - 1] == -1) {
	board[row][col] = -1;
	board[row][col - 1] = tile;
}


}
}",0
asah845,1696119619,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{

int row, col;


FindTile(board, tile, &row, &col);

if (board[row + 1][col] == -1) {
	board[row][col] = -1;
	board[row + 1][col] = tile;

} else if (board[row - 1][col] == -1) {
	board[row][col] = -1;
	board[row - 1][col] = tile;

} else if (board[row][col + 1] == -1) {
	board[row][col] = -1;
	board[row][col + 1] = tile;

} else if (board[row][col - 1] == -1) {
	board[row][col] = -1;
	board[row][col - 1] = tile;
}
}

",0
asah845,1696184454,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{

int row, col;


FindTile(board, tile, &row, &col);

if (row < NUM_ROWS - 1 && board[row + 1][col] == -1) {
	board[row][col] = -1;
	board[row + 1][col] = tile;

} else if (row > 0 && board[row - 1][col] == -1) {
	board[row][col] = -1;
	board[row - 1][col] = tile;

} else if (col < NUM_COLS - 1 && board[row][col + 1] == -1) {
	board[row][col] = -1;
	board[row][col + 1] = tile;

} else if (col > 0 && board[row][col - 1] == -1) {
	board[row][col] = -1;
	board[row][col - 1] = tile;
}
}",1
ashi565,1695808752,1,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

// Function to find the position of a tile in the board
void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos) {
    for (int row = 0; row < NUM_ROWS; ++row) {
        for (int col = 0; col < NUM_COLS; ++col) {
            if (board[row][col] == tile) {
                *rowPos = row;
                *colPos = col;
                return;
            }
        }
    }
    // If the tile is not found, set rowPos and colPos to -1.
    *rowPos = -1;
    *colPos = -1;
}

// Function to swap the specified tile with the empty square
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol, tileRow, tileCol;
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);

    // Check if the specified tile is adjacent to the empty square (horizontally or vertically)
    if ((emptyRow == tileRow && (emptyCol == tileCol - 1 || emptyCol == tileCol + 1)) ||
        (emptyCol == tileCol && (emptyRow == tileRow - 1 || emptyRow == tileRow + 1))) {
        // Swap the specified tile and the empty square
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}

",0
ashi565,1695809150,2,"#include <stdio.h>

// Constants for board dimensions
#define NUM_ROWS 4
#define NUM_COLS 4

// Function to find the position of a specific tile
void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos) {
    for (int row = 0; row < NUM_ROWS; ++row) {
        for (int col = 0; col < NUM_COLS; ++col) {
            if (board[row][col] == tile) {
                *rowPos = row;
                *colPos = col;
                return;
            }
        }
    }
    // If the tile is not found, set rowPos and colPos to -1.
    *rowPos = -1;
    *colPos = -1;
}

// Function to swap the specified tile with the empty square if they are adjacent
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol;
    int tileRow, tileCol;

    // Find the positions of the empty square and the specified tile
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);

    // Check if the tile and empty square are adjacent
    if (tileRow == emptyRow && (tileCol == emptyCol - 1 || tileCol == emptyCol + 1) ||
        tileCol == emptyCol && (tileRow == emptyRow - 1 || tileRow == emptyRow + 1)) {
        // Swap the tile and empty square
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}

int main() {
    int board[NUM_ROWS][NUM_COLS] = {
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9, 10, 11, 12},
        {-1, 13, 14, 15}
    };

    // Perform a move
    MakeMove(board, 6);

    // Print the updated board
    for (int row = 0; row < NUM_ROWS; ++row) {
        for (int col = 0; col < NUM_COLS; ++col) {
            printf(""%2d "", board[row][col]);
        }
        printf(""\n"");
    }

    return 0;
}




    
",0
ashi565,1695811695,3,"#include <stdio.h>
#include <stdbool.h>

#define NUM_ROWS 4
#define NUM_COLS 4

// Function to find the row and column position of a tile on the board
void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos) {
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == tile) {
                *rowPos = i;
                *colPos = j;
                return; // Tile found, exit the function
            }
        }
    }
    // If the tile is not found, you can set rowPos and colPos to -1 or some other suitable value.
    *rowPos = -1;
    *colPos = -1;
}

// Function to print the current state of the board
void PrintBoard(int board[NUM_ROWS][NUM_COLS]) {
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == -1) {
                printf("" _ "");
            } else {
                printf(""%2d "", board[i][j]);
            }
        }
        printf(""\n"");
    }
}

// Function to check if two positions are adjacent
bool AreAdjacent(int row1, int col1, int row2, int col2) {
    return (row1 == row2 && (col1 == col2 - 1 || col1 == col2 + 1)) || 
           (col1 == col2 && (row1 == row2 - 1 || row1 == row2 + 1));
}

// Function to make a move by swapping the specified tile with the empty square
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol;
    int tileRow, tileCol;

    // Find the positions of the empty square and the specified tile
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);

    // Check if the tile and empty square are adjacent
    if (AreAdjacent(tileRow, tileCol, emptyRow, emptyCol)) {
        // Swap the tile and empty square
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}

    
   ",0
ashi565,1696238066,4,"#include <stdio.h>

#define NUM_ROWS 3
#define NUM_COLS 3

// Function to find the row and column of a given tile on the board
bool FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *row, int *col) {
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == tile) {
                *row = i;
                *col = j;
                return true; // Tile found
            }
        }
    }
    return false; // Tile not found
}

// Function to swap the specified tile with the empty square if they are adjacent
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol, tileRow, tileCol;

    // Find the positions of the empty square and the specified tile
    if (!FindTile(board, -1, &emptyRow, &emptyCol) || !FindTile(board, tile, &tileRow, &tileCol)) {
        // Tile or empty square not found, or tile not adjacent to empty square
        return; // Cannot make the move
    }

    // Check if the tile is adjacent to the empty square (horizontal or vertical)
    if ((abs(tileRow - emptyRow) == 1 && tileCol == emptyCol) ||
        (emptyRow == tileRow && abs(emptyCol - tileCol) == 1)) {
        // Swap the tile and the empty square
        int temp = board[emptyRow][emptyCol];
        board[emptyRow][emptyCol] = board[tileRow][tileCol];
        board[tileRow][tileCol] = temp;
    }
}



   ",0
ashi565,1696238901,5,"#include <stdio.h>

// Function to make a move on the board
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol, tileRow, tileCol;

    // Find the positions of the empty square and the specified tile
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);

    // Check if the tile can be moved (adjacent to the empty square)
    if ((abs(emptyRow - tileRow) == 1 && emptyCol == tileCol) ||
        (emptyRow == tileRow && abs(emptyCol - tileCol) == 1)) {
        // Swap the tile with the empty square
        Swap(&board[emptyRow][emptyCol], &board[tileRow][tileCol]);
    }
}

",0
ashi565,1696240259,6,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    int emptyRow, emptyCol;
    int tileRow, tileCol;
    
    //Find the positions of the empty square and the specified tile.
    Findtile(board, -1, &emptyRow, &emptyCol);
    Findtile(board, tile, &tileRow, &tileCol);
    
    //Check if the tile can be moved (adjacent to the empty square)
    if ((abs(emptyRow - tileRow) == 1 && emptyCol == tileCol) ||
       ((abs(emptyCol - tileCol) == 1 && emptyRow == tileRow) {
       // Swap the tile and empty square
       board[emptyRow][emptyCol] = tile;
       board[tileRow][tileCol] = -1;
    }
    
    //If the tile cannot be moved (not adjacent to the empty square), do nothing.
}
",0
ashi565,1696240730,7,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol;
    int tileRow, tileCol;
    
    //Find the positions of the empty square and the specified tile.
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);
    
    //Check if the tile can be moved (adjacent to the empty square)
    if ((abs(emptyRow - tileRow) == 1 && emptyCol == tileCol) ||
        (abs(emptyCol - tileCol) == 1 && emptyRow == tileRow)) {
        // Swap the tile and empty square
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
    //If the tile cannot be moved (not adjacent to the empty square), do nothing.
}
",1
asim819,1695888300,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{

	int row, col;
	FindTile(board, -1, &row, &col);

	if (board[row - 1][col] == tile || board[row][col - 1] == tile || board[row + 1][col] == tile || board[row][col + 1] == tile) {
		int row1, col1;

		FindTile(board, tile, &row1, &col1);
		board[row][col] = tile;
		board[row1][col1] = -1;

	}

}",0
asim819,1695890145,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{

	int row, col;
	FindTile(board, -1, &row, &col);


	if (board[row - 1][col] == tile && row - 1 >= 0 || board[row][col - 1] == tile && col - 1 >= 0 || board[row + 1][col] == tile && row + 1 <= 3 || board[row][col + 1] == tile && col + 1 <= 3) {
		int row1, col1;

		FindTile(board, tile, &row1, &col1);
		board[row][col] = tile;
		board[row1][col1] = -1;

	}

}",0
asim819,1695890227,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{

	int row, col;
	FindTile(board, -1, &row, &col);


	if ((board[row - 1][col] == tile && row - 1 >= 0) || (board[row][col - 1] == tile && col - 1 >= 0) || (board[row + 1][col] == tile && row + 1 <= 3) || (board[row][col + 1] == tile && col + 1 <= 3)) {
		int row1, col1;

		FindTile(board, tile, &row1, &col1);
		board[row][col] = tile;
		board[row1][col1] = -1;

	}

}",1
aski294,1695806344,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int pointRow = -1, pointCol = -1;
	// find pointer 
	FindTile(board, -1, &pointRow, &pointCol);

	// find move
	int moveRow = -1, moveCol = -1;
	FindTile(board, tile , &moveRow, &moveCol);
	
	// check is adjacent
	int adjRow = moveRow - pointRow;
	int adjCol = moveCol - pointCol;
	
	if ((adjRow <= 1 && adjRow >= -1 ) == 1  && (adjCol == 0)) {
		// swap pointer and moved tile
		board[pointRow][pointCol] = tile;
		board[moveRow][moveCol] = -1;
	}
	else if ((adjCol <= 1 && adjCol >= -1) && (adjRow == 0)) {
		board[pointRow][pointCol] = tile;
		board[moveRow][moveCol] = -1;
	}
	
}",1
asmi629,1696240154,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRow, tileCol;
    FindTile(board, tile, &tileRow, &tileCol);

    int emptyRow, emptyCol;
    FindTile(board, -1, &emptyRow, &emptyCol);

    if ((abs(tileRow - emptyRow) == 1 && tileCol == emptyCol) || (abs(tileCol - emptyCol) == 1 && tileRow == emptyRow)) {
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }",0
asmi629,1696240289,2,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRow, tileCol;
    FindTile(board, tile, &tileRow, &tileCol);

    int emptyRow, emptyCol;
    FindTile(board, -1, &emptyRow, &emptyCol);

    if ((abs(tileRow - emptyRow) == 1 && tileCol == emptyCol) || (abs(tileCol - emptyCol) == 1 && tileRow == emptyRow)) {
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}",1
atay777,1696065914,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row;
	int col;

	FindTile(board, tile, &row, &col);
	if (row!=3)
	{
		if (board[row+1][col]==-1)
		{
			board[row+1][col]=tile;
			board[row][col]=-1;
		}
	}
	if (row!=0)
	{
		if (board[row-1][col]==-1)
		{
			board[row-1][col]=tile;
			board[row][col]=-1;
		}
	}
	if (col!=3)
	{
		if (board[row][col+1]==-1)
		{
			board[row][col+1]=tile;
			board[row][col]=-1;
		}
	}	
	if (col!=0)
	{
		if (board[row][col-1]==-1)
		{
			board[row][col-1]=tile;
			board[row][col]=-1;
		}
	}
}",1
atee059,1695607106,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {

    int row, col;
    
    FindTile(board, -1, &row, &col);
    
    if (board[row-1][col] == tile){
        board[row][col] = tile;
        board[row-1][col] = -1;
    }
    else if (board[row][col+1] == tile){
        board[row][col] = tile;
        board[row][col+1] = -1;
    }
    else if (board[row+1][col] == tile){
        board[row][col] = tile;
        board[row+1][col] = -1;
    }
    else if (board[row][col-1] == tile){
        board[row][col] = tile;
        board[row][col-1] = -1;
    }
    
}",0
atee059,1695608218,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {

    int row, col;
    
    FindTile(board, -1, &row, &col);
    
    if (board[row-1][col] == tile){
        board[row][col] = tile;
        board[row-1][col] = -1;
    }
    else if (board[row][col+1] == tile && col != 3){
        board[row][col] = tile;
        board[row][col+1] = -1;
    }
    else if (board[row+1][col] == tile){
        board[row][col] = tile;
        board[row+1][col] = -1;
    }
    else if (board[row][col-1] == tile && col != 0){
        board[row][col] = tile;
        board[row][col-1] = -1;
    }
    
}",1
atho643,1695896075,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    FindTile(board,tile,*tilerowPos,*tilecolPos);
    
    
    FindTile(board,-1,*blankrowPos, *blankcolPos);
    
    
    if ((blankcolPos == tilecolPos && (blankcolPos == tilecolPos + 1 || blankcolPos == tilecolPos - 1)) ||
        (blankrowPos == tilerowPos && (blankrowPos == tilerowPos + 1 || blankrowPos == tilerowPos - 1))) {
            
        int position = board[blankrowPos[blankcolPos];
        
        board[blankrowPos][blankcolPos] = board[tilerowPos][tilecolPos];
        
        board[tilerowPos][tilecolPos] = position;
        
        }

}
",0
atho643,1695896138,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
     int emptyRow, emptyCol, tileRow, tileCol;
     
    FindTile(board,tile,*tilerowPos,*tilecolPos);
    
    
    FindTile(board,-1,*blankrowPos, *blankcolPos);
    
    
    if ((blankcolPos == tilecolPos && (blankcolPos == tilecolPos + 1 || blankcolPos == tilecolPos - 1)) ||
        (blankrowPos == tilerowPos && (blankrowPos == tilerowPos + 1 || blankrowPos == tilerowPos - 1))) {
            
        int position = board[blankrowPos[blankcolPos];
        
        board[blankrowPos][blankcolPos] = board[tilerowPos][tilecolPos];
        
        board[tilerowPos][tilecolPos] = position;
        
        }

}
",0
atho643,1695896356,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
     int emptyRow, emptyCol, tileRow, tileCol;
     
    FindTile(board,tile,&tilerowPos,&tilecolPos);
    
    
    FindTile(board,-1,&blankrowPos, &blankcolPos);
    
    
    if ((blankcolPos == tilecolPos && (blankcolPos == tilecolPos + 1 || blankcolPos == tilecolPos - 1)) ||
        (blankrowPos == tilerowPos && (blankrowPos == tilerowPos + 1 || blankrowPos == tilerowPos - 1))) {
            
        int position = board[blankrowPos][blankcolPos];
        
        board[blankrowPos][blankcolPos] = board[tilerowPos][tilecolPos];
        
        board[tilerowPos][tilecolPos] = position;
        
        }

}
",0
atho643,1696117093,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
     int blankrowPos, blankcolPos;
     int tilerowPos, tilecolPos;
     
    
    FindTile(board,-1,&blankrowPos, &blankcolPos);
    FindTile(board,tile,&tilerowPos,&tilecolPos);
    
    
    if ((blankcolPos == tilecolPos && (blankcolPos == tilecolPos - 1 || blankcolPos == tilecolPos + 1)) ||
        (blankrowPos == tilerowPos && (blankrowPos == tilerowPos - 1 || blankrowPos == tilerowPos + 1))) {
            
        int position = board[blankrowPos][blankcolPos];
        
        board[blankrowPos][blankcolPos] = board[tilerowPos][tilecolPos];
        
        board[tilerowPos][tilecolPos] = position;
        
        }

}
",0
atho643,1696117803,5,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
     int blankrowPos, blankcolPos;
     int tilerowPos, tilecolPos;
     
    
    FindTile(board,-1, &blankrowPos, &blankcolPos);
    FindTile(board, tile, &tilerowPos, &tilecolPos);
    
    
    if ((blankrowPos == tilerowPos && (blankcolPos == tilecolPos - 1 || blankcolPos == tilecolPos + 1)) ||
        (blankcolPos == tilecolPos && (blankrowPos == tilerowPos - 1 || blankrowPos == tilerowPos + 1))) {
        int position = board[blankrowPos][blankcolPos];
        board[blankrowPos][blankcolPos] = board[tilerowPos][tilecolPos];
        board[tilerowPos][tilecolPos] = position;
        
        }

}
",1
athu157,1695795057,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;
	int i, j;
	int temp;
	FindTile(board, -1, &row, &col);
	FindTile(board, tile, &i, &j);

	if (j == col) {
		if (i == row - 1 || i == row + 1) {
			temp = board[i][j];
			board[i][j] = board[row][col];
			board[row][col] = temp;
		}
	}
	else if (i == row) {
		if (j == col - 1 || j == col + 1) {
			temp = board[i][j];
			board[i][j] = board[row][col];
			board[row][col] = temp;
		}
	}
}",1
atup175,1696233862,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowTile, colTile, rowEmpty, colEmpty;
    FindTile(board, -1, &rowEmpty, &colEmpty);
    FindTile(board, tile, &rowTile, &colTile);
    if (abs(rowEmpty - rowTile) + abs(colEmpty - colTile) == 1){
        board[rowEmpty][colEmpty] = tile;
        board[rowTile][colTile] = -1;
    }
    
}",1
avan381,1696055891,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    
    int tileRow, tileCol, blankRow, blankCol;

//WORKOUT BLANK POSITION    
     for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++){
            
            if (board[i][j] == -1){
                blankRow = i;
                blankCol = j;
            }
            
        }
    }
    
//WORKOUT TILE POSITION    
       for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++){
            
            if (board[i][j] == tile){
                tileRow = i;
                tileCol = j;
            }
            
        }
    }  
     
// FIND ROWS and COLS DISTANCE BETWEEN TILE AND BLANK 
int rowsDist = blankRow - tileRow;
int colsDist = blankCol - tileCol;


//ANAYLESE THIS DISTANCE TO SEE IF RETRUN OR NOT
if ((rowsDist == -1 ) || (rowsDist == 0) || (rowsDist == 1)){
    
}else{
    return;
}

if ((colsDist == -1 ) || (colsDist == 0) || (colsDist == 1)){

}else{
    return;
}

if ((rowsDist == -1) && (colsDist == -1) || (rowsDist == 1) && (colsDist == -1) || (rowsDist == -1) && (colsDist == 1) || (rowsDist == 1) && (colsDist == 1)){
   return; 
}
    
    board[tileRow][tileCol] = -1;
    board[blankRow][blankCol] = tile;
    
}",0
avan381,1696056335,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    
    int tileRow;
    int tileCol;
    int blankRow;
    int blankCol;

//WORKOUT BLANK POSITION    
     for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++){
            
            if (board[i][j] == -1){
                blankRow = i;
                blankCol = j;
            }
            
        }
    }
    
//WORKOUT TILE POSITION    
       for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++){
            
            if (board[i][j] == tile){
                tileRow = i;
                tileCol = j;
            }
            
        }
    }  
     
// FIND ROWS and COLS DISTANCE BETWEEN TILE AND BLANK 
int rowsDist = blankRow - tileRow;
int colsDist = blankCol - tileCol;


//ANAYLESE THIS DISTANCE TO SEE IF RETRUN OR NOT
if ((rowsDist == -1 ) || (rowsDist == 0) || (rowsDist == 1)){
    
}else{
    return;
}

if ((colsDist == -1 ) || (colsDist == 0) || (colsDist == 1)){

}else{
    return;
}

if (((rowsDist == -1) && (colsDist == -1)) || ((rowsDist == 1) && (colsDist == -1)) || ((rowsDist == -1) && (colsDist == 1)) || ((rowsDist == 1) && (colsDist == 1))){
   return; 
}
    
    board[tileRow][tileCol] = -1;
    board[blankRow][blankCol] = tile;
    
}",1
awal599,1696239590,1,"#include <stdio.h>
#define NUM_ROWS 4
#define NUM_COLS 4
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    
    int Ad1, Val1;
    int Ad2, Val2;
    FindTile(board, tile, &Ad1, &Val1);
    FindTile(board, -1, &Ad2, &Val2);
    if ((Ad1 == Ad2 && (Val1 == Val2-1 || Val1 == Val2+1) || Val1 == Val2 && (Ad1 == Ad2-1 || Ad1 == Ad2+1))){
    int OrgBoard = board[Ad2][Val2];
    board[Ad2][Val2] = board[Ad1][Val1];
    board[Ad1][Val1] = original;
      } 
     return;
     }",0
awal599,1696241372,2,"#include <stdio.h>
#define NUM_ROWS 4
#define NUM_COLS 4
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    int Ad1, Val1;
    int Ad2, Val2;
    FindTile(board, tile, &Ad1, &Val1);
    FindTile(board, -1, &Ad2, &Val2);
    if ((Ad1 == Ad2 && (Val1 == Val2-1 || Val1 == Val2+1)) || (Val1 == Val2 && (Ad1 == Ad2-1 || Ad1 == Ad2+1))){
    int OrgBoard = board[Ad2][Val2];
    board[Ad2][Val2] = board[Ad1][Val1];
    board[Ad1][Val1] = OrgBoard;
      } 
     return;
     }",1
awar747,1696234402,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol, tileRow, tileCol;

   
    for (int row = 0; row < NUM_ROWS; row++) {
        for (int col = 0; col < NUM_COLS; col++) {
            if (board[row][col] == -1) {
                emptyRow = row;
                emptyCol = col;
            }
            if (board[row][col] == tile) {
                tileRow = row;
                tileCol = col;
            }
        }
    }

   
    if ((abs(emptyRow - tileRow) == 1 && emptyCol == tileCol) ||
        (abs(emptyCol - tileCol) == 1 && emptyRow == tileRow)) {
       
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}




",1
awil907,1695764462,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row;
    int col;

    // Find the tile to be moved with FindTile
    FindTile(board, tile, &row, &col);

    // If it is within bounds
    if ((row >= 0 && row < NUM_ROWS) && (col >= 0 && col < NUM_COLS)){

        // Right
        if (board[row][col+1] == -1 && col < NUM_COLS-1) {
            // Set up pointers for swapping
            int *starter = &board[row][col];
            int *ender = &board[row][col+1];
            int original;
            original = *starter;
            *starter = *ender;
            *ender = original;
        }

        // Left
        if (board[row][col-1] == -1 && col > 0) {
            int *starter = &board[row][col];
            int *ender = &board[row][col-1];
            int original;
            original = *starter;
            *starter = *ender;
            *ender = original;
        }

        // Above
        if (board[row-1][col] == -1 && row > 0) {
            int *starter = &board[row][col];
            int *ender = &board[row-1][col];
            int original;
            original = *starter;
            *starter = *ender;
            *ender = original;
        }

        // Below
        if (board[row+1][col] == -1 && row < NUM_ROWS-1) {
            int *starter = &board[row][col];
            int *ender = &board[row+1][col];
            int original;
            original = *starter;
            *starter = *ender;
            *ender = original;
        }
    }
}",1
awri757,1695705110,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j, tileRow, tileCol, rowPos, colPos;

	// find index of tile to be swapped
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == tile) {
				tileRow = i;
				tileCol = j;
			}
		}
	}

	// check if tile can be swapped
	int check = 0;
	for (i = -1; i <= 1; i += 2) {
		if (board[tileRow + i][tileCol] == -1) {
			rowPos = tileRow + i;
			colPos = tileCol;
			check = 1;
		}
	}
	for (j = -1; j <= 1; j += 2) {
		if (j == 1 && (tileCol + j) != 4) {
			if (board[tileRow][tileCol + j] == -1) {
				rowPos = tileRow;
				colPos = tileCol + j;
				check = 1;
			}
		}
		else if (j == -1 && (tileCol + j) != -1) {
			if (board[tileRow][tileCol + j] == -1) {
				rowPos = tileRow;
				colPos = tileCol + j;
				check = 1;
			}
		}
	}
	
	// if tile can be swapped, swap it
	if (check == 1) {
		board[rowPos][colPos] = tile;
		board[tileRow][tileCol] = -1;
	}
	return;

}",1
ayan607,1696135328,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int num)
{	
	int tileRow,tileCol;
	int numRow, numCol;

	FindTile(board, -1, &tileRow, &tileCol);
	FindTile(board, num, &numRow, &numCol);

	if (tileRow == numRow){
		if (tileCol == numCol + 1 || tileCol == numCol - 1){
			board[tileRow][tileCol] = num;
			board[numRow][numCol] = -1;
		}
	}else if (tileCol == numCol){
		if (tileRow == numRow + 1 || tileRow == numRow - 1){
			board[tileRow][tileCol] = num;
			board[numRow][numCol] = -1;
		}
	}


}",1
ayou303,1695703109,1,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
	
	int eR, eC, tR, tC;

	FindTile(board, -1, &eR, &eC);
	FindTile(board, tile, &tR, &tC);

	if (((eR - tR) == 1 || (eR - tR) == -1) && (eC == tC)) {
		board[eR][eC] = tile;
		board[tR][tC] = -1;
	}
	if (((eC - tC) == 1 || (eC - tC) == -1) && (eR==tR)) {
		board[eR][eC] = tile;
		board[tR][tC] = -1;
		
	}


}",1
ayou533,1696191300,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRow, tileCol, emptyRow, emptyCol;

    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol);

    if ((tileRow == emptyRow && (tileCol == emptyCol + 1 || tileCol == emptyCol - 1)) ||
        (tileCol == emptyCol && (tileRow == emptyRow + 1 || tileRow == emptyRow - 1))) {
        
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}",1
ayua214,1696228213,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol, tileRow, tileCol;

    // Find the empty tile
    FindTile(board, -1, &emptyRow, &emptyCol);

    // Find the tile to be moved
    FindTile(board, tile, &tileRow, &tileCol);

    // Check if the tile can be moved (adjacent to the empty square)
    if ((tileRow == emptyRow && (tileCol == emptyCol + 1 || tileCol == emptyCol - 1)) ||
        (tileCol == emptyCol && (tileRow == emptyRow + 1 || tileRow == emptyRow - 1))) {

        // Swap the tile with the empty square
        int temp = board[emptyRow][emptyCol];
        board[emptyRow][emptyCol] = board[tileRow][tileCol];
        board[tileRow][tileCol] = temp;
    } else {
        printf(""Invalid move. Tile cannot be moved.\n"");
    }
}
",0
ayua214,1696228236,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol, tileRow, tileCol;

    // Find the empty tile
    FindTile(board, -1, &emptyRow, &emptyCol);

    // Find the tile to be moved
    FindTile(board, tile, &tileRow, &tileCol);

    // Check if the tile can be moved (adjacent to the empty square)
    if ((tileRow == emptyRow && (tileCol == emptyCol + 1 || tileCol == emptyCol - 1)) ||
        (tileCol == emptyCol && (tileRow == emptyRow + 1 || tileRow == emptyRow - 1))) {

        // Swap the tile with the empty square
        int temp = board[emptyRow][emptyCol];
        board[emptyRow][emptyCol] = board[tileRow][tileCol];
        board[tileRow][tileCol] = temp;
    } else {
        printf(""\n"");
    }
}
",0
ayua214,1696228319,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol, tileRow, tileCol;

    // Find the empty tile
    FindTile(board, -1, &emptyRow, &emptyCol);

    // Find the tile to be moved
    FindTile(board, tile, &tileRow, &tileCol);

    // Check if the tile can be moved (adjacent to the empty square)
    if ((tileRow == emptyRow && (tileCol == emptyCol + 1 || tileCol == emptyCol - 1)) ||
        (tileCol == emptyCol && (tileRow == emptyRow + 1 || tileRow == emptyRow - 1))) {

        // Swap the tile with the empty square
        int temp = board[emptyRow][emptyCol];
        board[emptyRow][emptyCol] = board[tileRow][tileCol];
        board[tileRow][tileCol] = temp;
    }
}
",1
bate521,1696224879,1,"#include <stdio.h>
#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int empty_row, empty_col, tile_row, tile_col;
    FindTile(board, -1, &empty_row, &empty_col);
    FindTile(board, tile, &tile_row, &tile_col);

    if ((tile_row == empty_row && (tile_col == empty_col - 1 || tile_col == empty_col + 1)) ||
        (tile_col == empty_col && (tile_row == empty_row - 1 || tile_row == empty_row + 1))) {
        board[tile_row][tile_col] = -1;
        board[empty_row][empty_col] = tile;
    }
}
",1
bcar662,1696129650,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int newRow;
	int newCol;
	int oldRow;
	int oldCol;
	
	FindTile(board, tile, &newRow, &newCol);
	FindTile(board, -1, &oldRow, &oldCol);
	
	board[newRow][newCol] = -1;
	board[oldRow][oldCol] = tile;
}",0
bcar662,1696130706,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int newRow;
	int newCol;
	int oldRow;
	int oldCol;

	
	FindTile(board, tile, &newRow, &newCol);
	FindTile(board, -1, &oldRow, &oldCol);

	
	
	if (newRow - oldRow <= 1 && newRow - oldRow >= -1 && newCol == oldCol) {
		board[newRow][newCol] = -1;
		board[oldRow][oldCol] = tile;
	}
	else if (newCol - oldCol <= 1 && newCol - oldCol >= -1 && newRow == oldRow) {
		board[newRow][newCol] = -1;
		board[oldRow][oldCol] = tile;
	}
}",1
bcha389,1695705766,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col; //Position of tile.
	int erow, ecol; //Position of -1.
	int n = 0;

	FindTile(board, tile, &row, &col);
	FindTile(board, -1, &erow, &ecol);

	if (row == erow) {
		n = n + 2;
	}
	if (row != 0) {
		if (row - 1 == erow) {
			n++;
		}
	}
	if (row != 3) {
		if (row + 1 == erow) {
			n++;
		}
	}

	if (col == ecol) {
		n = n + 2;
	}
	if (col != 0) {
		if (col - 1 == ecol) {
			n++;
		}
	}
	if (col != 3) {
		if (col + 1 == ecol) {
			n++;
		}
	}

	//If n is 3, that means the number is adjacent to -1.
	//If it is 0, 1 or 2, the number is too far away. 4 is impossible.
	if (n == 3) {
		//Swap tile and -1.
		board[row][col] = -1;
			board[erow][ecol] = tile;
	}
}",1
bcha726,1695771400,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowTile, colTile, rowEmpty, colEmpty;
	FindTile(board, tile, &rowTile, &colTile);
	FindTile(board, -1, &rowEmpty, &colEmpty);

	if (((rowTile - rowEmpty <= 1 && rowTile - rowEmpty >= -1) && colTile - colEmpty == 0) || ((colTile - colEmpty <= 1 && colTile - colEmpty >= -1) && rowTile - rowEmpty == 0)){
		board[rowEmpty][colEmpty] = board[rowTile][colTile];
		board[rowTile][colTile] = -1;
	}
	
}",1
bcos422,1695647931,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{

	int row2, col2, row, col,gaprow,gapcol;
	FindTile(board, tile, &row2, &col2);
	FindTile(board, -1, &row, &col);
	gaprow = row - row2;
	gapcol = col - col2;
	if (gaprow == 1 && gapcol == 0){ 
		row2 = row2+1;
		row = row - 1;
	}
	if (gaprow == -1 && gapcol == 0) {
		row2 = row2 - 1;
		row = row + 1;
	}
	if (gapcol == 1 && gaprow == 0) {
		col2 = col2 + 1;
		col = col - 1;
	}
	if (gapcol == -1 && gaprow == 0) {
		col2 = col2 - 1;
		col = col + 1;
	}
	board[row][col] = -1;
	board[row2][col2] = tile;
}",1
bcru157,1695703691,1,"#include <stdio.h>
#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col, row2, col2, temp;
    FindTile(board, -1, &row, &col);
    FindTile(board, tile, &row2, &col2);
    
    if (((row2 - row == -1 || row - row2  == -1) && (col == col2)) || ((col2 - col == -1 || col - col2 == -1) && (row == row2)))
    {
        temp = board[row][col];
        board[row][col] = board[row2][col2];
        board[row2][col2] = temp;
    }
    else
    {
        return;
        
    }
    
}",1
besk864,1696217808,1,"void MakeMove(int board[4][4], int tile){
    int rowN;
    int colN;
    int rowT;
    int colT;
    
    
    for (int i = 0; i < 4; i++){
        for (int j = 0; j < 4; j++){
        
        if (board[i][j] == tile){
            
            rowT = i;
            colT = j;
            
        }
 if (board[i][j] == -1){
            
            rowN = i;
            colN = j;
            
        }        
            
        }
    }
    
    if ((rowT - rowN) > 1 || (rowT - rowN) < -1 || (colT - colN) > 1 || (colT - colN) < -1 || ((rowT - rowN) - (colT - colN)) < -1 || ((rowT - rowN) - (colT - colN)) > 1){
    }
        else{
        board[rowN][colN] = tile;
        board[rowT][colT] = -1;
    }
    
}",1
bfis965,1695865941,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col, blankRow, blankCol;
    FindTile(board, tile, &row, &col);
    FindTile(board, -1, &blankRow, &blankCol);
    if (((row == blankRow+1)||(row == blankRow-1))||((col == blankCol+1)||(col == blankCol-1))) {
        board[blankRow][blankCol] = board[row][col];
        board[row][col] = -1;
    }
}",0
bfis965,1695868300,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col, blankRow, blankCol;
    FindTile(board, tile, &row, &col);
    FindTile(board, -1, &blankRow, &blankCol);
    if ((row == blankRow)||(col == blankCol)) {
        if ((row - blankRow != 1 && row - blankRow != -1) && (col - blankCol != 1 && col - blankCol != -1)) {
            return;
        }
        board[blankRow][blankCol] = board[row][col];
        board[row][col] = -1;
    }
}",1
bfla774,1696219234,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;
	int newrow, newcol;
	FindTile(board, -1, &row, &col);
	FindTile(board, tile, &newrow, &newcol);
		if (newrow == row && newcol == col + 1 || newrow == row && newcol == col - 1 || newrow == row - 1 && newcol == col || newrow == row + 1 && newcol == col) {
			board[row][col] = tile;
			board[newrow][newcol] = -1;
	}
}",0
bfla774,1696219455,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;
	int newrow, newcol;
	FindTile(board, -1, &row, &col);
	FindTile(board, tile, &newrow, &newcol);
	if ((newrow == row && newcol == col + 1) || (newrow == row && newcol == col - 1) || (newrow == row - 1 && newcol == col) || (newrow == row + 1 && newcol == col)) {
			board[row][col] = tile;
			board[newrow][newcol] = -1;
	}
}",1
bgib630,1695795600,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowPosition = -1;
	int colPosition = -1;

	for (int i = 0; i < NUM_COLS; i++)
	{
		for (int j = 0; j < NUM_ROWS; j++)
		{
			if (board[i][j] == tile)
			{
				rowPosition = i;
				colPosition = j;
			}
		}
	}

	if ((rowPosition < *rowPos + 1) && (rowPosition > *rowPos - 1) && (colPosition < *colPos + 1) && (colPosition > *colPos - 1))
	{
		board[*colPos][*rowPos] = board[colPosition][rowPosition];
		board[colPosition][rowPosition] = -1;
	}
}",0
bgib630,1695812389,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowPosition = -1;
	int colPosition = -1;
	FindTile(board, tile, &rowPosition, &colPosition);

	int emptyCellRow = -1;
	int emptyCellCol = -1;
	FindTile(board, -1, &emptyCellRow, &emptyCellCol);

	if ((rowPosition == emptyCellRow && (colPosition - emptyCellCol == 1 || emptyCellCol - colPosition == 1)) || (colPosition == emptyCellCol && (rowPosition - emptyCellRow == 1 || emptyCellRow - rowPosition == 1)))
	{
		board[emptyCellRow][emptyCellCol] = board[rowPosition][colPosition];
		board[rowPosition][colPosition] = -1;
	}
}",1
bgru726,1696204038,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int emptyRow, emptyCol, tileRow, tileCol;
	FindTile(board, -1, &emptyRow, &emptyCol);
	FindTile(board, tile, &tileRow, &tileCol);
	if ((tileRow == emptyRow - 1 || tileRow == emptyRow + 1) ^ (tileCol == emptyCol - 1 || tileCol == emptyCol + 1)) {
		board[emptyRow][emptyCol] = tile;
		board[tileRow][tileCol] = -1;
	}
}",0
bgru726,1696217015,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int emptyRow, emptyCol, tileRow, tileCol;
	FindTile(board, -1, &emptyRow, &emptyCol);
	FindTile(board, tile, &tileRow, &tileCol);
	if (((tileRow == emptyRow - 1 || tileRow == emptyRow + 1) && (tileCol == emptyCol)) ^ ((tileCol == emptyCol - 1 || tileCol == emptyCol + 1))&& (tileRow == emptyRow)) {
		board[emptyRow][emptyCol] = tile;
		board[tileRow][tileCol] = -1;
	}
}",0
bgru726,1696217120,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int emptyRow, emptyCol, tileRow, tileCol;
	FindTile(board, -1, &emptyRow, &emptyCol);
	FindTile(board, tile, &tileRow, &tileCol);
	if (((tileRow == emptyRow - 1 || tileRow == emptyRow + 1) && (tileCol == emptyCol)) ^ ((tileCol == emptyCol - 1 || tileCol == emptyCol + 1)&& (tileRow == emptyRow))) {
		board[emptyRow][emptyCol] = tile;
		board[tileRow][tileCol] = -1;
	}
}",1
bguo360,1695618715,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tilerow, tilecol, emptyrow, emptycol;
	FindTile(board, tile, &tilerow, &tilecol);
	FindTile(board, -1, &emptyrow, &emptycol);
	if (tilerow == emptyrow) {
		if (((tilecol - emptycol) == 1) || ((tilecol - emptycol) == -1)) {
			board[emptyrow][emptycol] = tile;
			board[tilerow][tilecol] = -1;
		}
	}
	if (tilecol == emptycol) {
		if (((tilerow - emptyrow) == 1) || ((tilerow - emptyrow) == -1)) {
			board[emptyrow][emptycol] = tile;
			board[tilerow][tilecol] = -1;
		}
	}
}",1
bhua898,1695619039,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
int emptyRow, emptyCol, tileRow, tileCol = 0;

FindTile(board, -1, &emptyRow, &emptyCol);
FindTile(board, tile, &tileRow, &tileCol);

if ((tileRow == emptyRow) && ((tileCol == emptyCol - 1) || (tileCol == emptyCol + 1))) {
	board[emptyRow][emptyCol] = tile;
	board[tileRow][tileCol] = -1;
}

if ((tileCol == emptyCol) && ((tileRow == emptyRow - 1) || (tileRow == emptyRow + 1))) {
	board[emptyRow][emptyCol] = tile;
	board[tileRow][tileCol] = -1;
}
}",1
bjin223,1696067106,1,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
int emptyRow, emptyCol, tileRow, tileCol;
//
if (emptyRow==tileRow && (emptyCol ==tileCol-1 || emptyCol==tileCol+1))||
    (emptyCol == tileCol && (emptyRow == tileRow-1|| emptyRow==tileRow +1))
    board[emptyRow][emptyCol]=tile;
    board[tileRow][tileCol]=-1;
}",0
bjin223,1696067172,2,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
int emptyRow, emptyCol, tileRow, tileCol;
//
if (emptyRow==tileRow && (emptyCol ==tileCol-1 || emptyCol==tileCol+1)||emptyCol == tileCol && (emptyRow == tileRow-1|| emptyRow==tileRow +1))
    board[emptyRow][emptyCol]=tile;
    board[tileRow][tileCol]=-1;
}",0
bjin223,1696068318,3,"#include <stdio.h>
#define NUM_ROWS 4
#define NUM_COLS 4
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
int emptyRow, emptyCol, tileRow, tileCol;
//
if (emptyRow==tileRow && (emptyCol ==tileCol-1 || emptyCol==tileCol+1)||emptyCol == tileCol && (emptyRow == tileRow-1|| emptyRow==tileRow +1))
    board[emptyRow][emptyCol]=tile;
    board[tileRow][tileCol]=-1;
}",0
bjin223,1696068581,4,"#include <stdio.h>
#define NUM_ROWS 4
#define NUM_COLS 4
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
int emptyRow, emptyCol, tileRow, tileCol;
//
if (emptyRow==tileRow && (emptyCol ==tileCol-1 || emptyCol==tileCol+1)||emptyCol == tileCol && emptyRow == tileRow-1|| emptyRow==tileRow +1){
    board[emptyRow][emptyCol]=tile;
    board[tileRow][tileCol]=-1;
}
}",0
bjin223,1696068769,5,"#include <stdio.h>
#define NUM_ROWS 4
#define NUM_COLS 4
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
int emptyRow, emptyCol, tileRow, tileCol;
//
if ((emptyRow==tileRow && (emptyCol ==tileCol-1 || emptyCol==tileCol+1))||(emptyCol == tileCol && (emptyRow == tileRow-1|| emptyRow==tileRow +1))){
    board[emptyRow][emptyCol]=tile;
    board[tileRow][tileCol]=-1;
}
}",0
bjin223,1696068921,6,"#include <stdio.h>
#define NUM_ROWS 4
#define NUM_COLS 4
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
int emptyRow, emptyCol, tileRow, tileCol;

if ((emptyRow==tileRow && (emptyCol ==tileCol-1 || emptyCol==tileCol+1))||
(emptyCol == tileCol && (emptyRow == tileRow-1|| emptyRow==tileRow +1))){
    board[emptyRow][emptyCol]=tile;
    board[tileRow][tileCol]=-1;
}
}",0
bjin223,1696069228,7,"#include <stdio.h>
#define NUM_ROWS 4
#define NUM_COLS 4
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
int emptyRow;
int emptyCol;
int tileRow;
int tileCol;
FindTile(board,-1,&emptyRow,&emptyCol);
FindTile(board,tile,&emptyRow,&emptyCol);
if ((emptyRow==tileRow && (emptyCol ==tileCol-1 || emptyCol==tileCol+1))||
(emptyCol == tileCol && (emptyRow == tileRow-1|| emptyRow==tileRow +1))){
    board[emptyRow][emptyCol]=tile;
    board[tileRow][tileCol]=-1;
}
}",0
bjin223,1696069250,8,"#include <stdio.h>
#define NUM_ROWS 4
#define NUM_COLS 4
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
int emptyRow;
int emptyCol;
int tileRow;
int tileCol;
FindTile(board,-1,&emptyRow,&emptyCol);
FindTile(board,tile,&tileRow,&tileCol);
if ((emptyRow==tileRow && (emptyCol ==tileCol-1 || emptyCol==tileCol+1))||
(emptyCol == tileCol && (emptyRow == tileRow-1|| emptyRow==tileRow +1))){
    board[emptyRow][emptyCol]=tile;
    board[tileRow][tileCol]=-1;
}
}",1
bjon836,1695845142,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    
    int rowPos, colPos;
    FindTile(board, tile, &rowPos, &colPos) 
        
        
    if (rowPos > 0 && board[rowPos - 1][colPos] == -1) {
        board[rowPos][colPos] = -1;
        board[rowPos - 1][colPos] = tile;
    } else if (rowPos < NUM_ROWS - 1 && board[rowPos + 1][colPos] == -1) {
        board[rowPos][colPos] = -1;
        board[rowPos + 1][colPos] = tile;
    } else if (colPos > 0 && board[rowPos][colPos - 1] == -1) {
        board[rowPos][colPos] = -1;
        board[rowPos][colPos - 1] = tile;
    } else if (colPos < NUM_COLS - 1 && board[rowPos][colPos + 1] == -1) {
        board[rowPos][colPos] = -1;
        board[rowPos][colPos + 1] = tile;
    }
}",0
bjon836,1695845167,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    
    int rowPos, colPos;
    FindTile(board, tile, &rowPos, &colPos); 
        
        
    if (rowPos > 0 && board[rowPos - 1][colPos] == -1) {
        board[rowPos][colPos] = -1;
        board[rowPos - 1][colPos] = tile;
    } else if (rowPos < NUM_ROWS - 1 && board[rowPos + 1][colPos] == -1) {
        board[rowPos][colPos] = -1;
        board[rowPos + 1][colPos] = tile;
    } else if (colPos > 0 && board[rowPos][colPos - 1] == -1) {
        board[rowPos][colPos] = -1;
        board[rowPos][colPos - 1] = tile;
    } else if (colPos < NUM_COLS - 1 && board[rowPos][colPos + 1] == -1) {
        board[rowPos][colPos] = -1;
        board[rowPos][colPos + 1] = tile;
    }
}",1
bkho028,1695781962,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyRow, emptyCol;
    int tileRow, tileCol;

    // Find the positions of the specified tile and the empty square
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);

    // Calculate the differences between rows and columns
    int rowDiff = emptyRow - tileRow;
    int colDiff = emptyCol - tileCol;

    // Check if the specified tile is adjacent to the empty square
    if (((rowDiff == 1 || rowDiff == -1) && colDiff == 0) ||
        ((colDiff == 1 || colDiff == -1) && rowDiff == 0))
    {
        // Swap the tile with the empty square
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}",1
blar030,1695949404,1,"
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
/* find the position of new tile to be replaced as open*/
    int x, y, rowPos,colPos, OpenRowPos,OpenColPos;
    for(y=0; y<NUM_ROWS; y++) {
        for(x=0; x<NUM_COLS; x++) {
            if(board[y][x]==tile){
            rowPos = y;
            colPos = x;
            break;
            }
        }
    }

/*find position of -1 as the open tile*/
    for(y=0; y<NUM_ROWS; y++) {
        for(x=0; x<NUM_COLS; x++) {
            if(board[y][x]==-1){
            OpenRowPos = y;
            OpenColPos = x;
            }
        }
    }

/*check all cases of above, below, and sideways that the tile to move to is only 1 or less tile away*/
    if((OpenRowPos==rowPos) && (OpenColPos-1==colPos)){
        board[rowPos][colPos] = -1;
        board[OpenRowPos][OpenColPos] = tile;
    }
    
    else if((OpenRowPos==rowPos) && (OpenColPos+1==colPos)){
        board[rowPos][colPos] = -1;
        board[OpenRowPos][OpenColPos] = tile;
    }
    
    else if((OpenRowPos-1==rowPos) && (OpenColPos==colPos)){
        board[rowPos][colPos] = -1;
        board[OpenRowPos][OpenColPos] = tile;
    }
    
    else if((OpenRowPos+1==rowPos) && (OpenColPos==colPos)){
        board[rowPos][colPos] = -1;
        board[OpenRowPos][OpenColPos] = tile;
    }
}
",1
bli482,1695788766,1,"#include <stdio.h>
#include <stdlib.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;
	int nrow, ncol;
	int absoluterow;
	int absolutecol;

	FindTile(board, -1, &row, &col);
	FindTile(board, tile, &nrow, &ncol);

	absoluterow = abs(nrow - row);
	absolutecol = abs(ncol - col);

	if ((absoluterow == 1 && absolutecol == 0)||(absoluterow == 0 && absolutecol == 1)) {
		board[row][col] = tile;
		board[nrow][ncol] = -1;
	}
}",1
bli775,1695727514,1,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol, tileRow, tileCol;
    
    // Find the positions of the tile and the empty square
    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol);
    
    // Check if the tile and empty square are adjacent (horizontal or vertical)
    if (((tileRow == emptyRow && (tileCol == emptyCol - 1 || tileCol == emptyCol + 1)) ||
         (tileCol == emptyCol && (tileRow == emptyRow - 1 || tileRow == emptyRow + 1)))) {
    
    }
}
",0
bli775,1695728815,2,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol, tileRow, tileCol;
    
    // Find the positions of the tile and the empty square
    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol);
    
    // Check if the tile and empty square are adjacent (horizontal or vertical)
    if (((tileRow == emptyRow && (tileCol == emptyCol - 1 || tileCol == emptyCol + 1)) ||
         (tileCol == emptyCol && (tileRow == emptyRow - 1 || tileRow == emptyRow + 1)))) {
        // Swap the tile and the empty square
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}
",1
blin888,1696123105,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int emptyRow;
	int emptyCol;
	int tileRow;
	int tileCol;

	FindTile(board, -1, &emptyRow, &emptyCol);
	FindTile(board, tile, &tileRow, &tileCol);

	if ((emptyRow == tileRow) && (emptyCol == tileCol)) {
		board [emptyRow][emptyCol] = tile;
		board[tileRow][tileCol] = -1;
	}",0
blin888,1696123493,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int emptyRow;
	int emptyCol;
	int tileRow;
	int tileCol;

	FindTile(board, -1, &emptyRow, &emptyCol);

	if ((tileRow == emptyRow) && (tileCol == emptyCol)) {
		board [emptyRow][emptyCol] = tile;
		board[tileRow][tileCol] = -1;
	}",0
bmac148,1696219532,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
	int rowtile;
	int coltile;
	int rowempty;
	int colempty;
	int rowadj = 0;
	int coladj = 0;

	FindTile(board, -1, &rowempty, &colempty);
	FindTile(board, tile, &rowtile, &rowtile);

	if (rowempty == rowtile || rowempty == rowtile + 1 || rowempty == rowtile - 1) {
		rowadj = 1;
	}
	if (colempty == coltile || colempty == coltile + 1 || colempty == coltile - 1) {
		coladj = 1;
	}
	if ((rowadj == 1) && (coladj == 1)) {
		board[rowempty][colempty] = tile;
		board[rowtile][coltile] = -1;
	}
}",0
bmac148,1696219741,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
	int rowtile;
	int coltile;
	int rowempty;
	int colempty;
	int rowadj = 0;
	int coladj = 0;

	FindTile(board, -1, &rowempty, &colempty);
	FindTile(board, tile, &rowtile, &coltile);

	if (rowempty == rowtile || rowempty == rowtile + 1 || rowempty == rowtile - 1) {
		rowadj = 1;
	}
	if (colempty == coltile || colempty == coltile + 1 || colempty == coltile - 1) {
		coladj = 1;
	}
	if ((rowadj == 1) && (coladj == 1)) {
		board[rowempty][colempty] = tile;
		board[rowtile][coltile] = -1;
	}
}",1
bora417,1695867546,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{

    //Find the tile the user inputs
    int row_tile; 
    int col_tile; 
    FindTile(board, tile, &row_tile, &col_tile);
  
    //Find the empty tile
    int row_empty;
    int col_empty;
    FindTile(board, -1, &row_empty, &col_empty);
  

/* Calculate the difference between the empty tile and row tile to
determine if it is around the empty tile space
*/
    int row_change = row_tile - row_empty;
    int col_change = col_tile - col_empty;

    if ((row_change == 1 ||row_change == 0 || row_change == -1) && (col_change == 1 ||col_change == 0 || col_change == -1)) {
        //Swap the tile 
        board[row_empty][col_empty] = tile; 
        board[row_tile][col_tile] = -1; 
    } else {
        return; 
    }

}
",1
bpak212,1696222932,1,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) 
{
    int emptyRow = -1, emptyCol = -1;
    int tileRow = -1, tileCol = -1;

    //assign array bits into their new positions
    for (int row = 0; row < NUM_ROWS; row++) 
    {
        for (int col = 0; col < NUM_COLS; col++)
        {
            if (board[row][col] == -1) 
            {
                emptyRow = row;
                emptyCol = col;
            } 
            else if (board[row][col] == tile) 
            {
                tileRow = row;
                tileCol = col;
            }
        }
    }

    // here we are making sure the tile is adjacent to the empty square
    bool isAdjacent = ((abs(tileRow - emptyRow) == 1 && tileCol == emptyCol) ||
                       (tileRow == emptyRow && abs(tileCol - emptyCol) == 1));

    // since tile is adajacent we are required to swap the values of the tile
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}




",0
bpak212,1696223037,2,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) 
{
    int emptyRow = -1, emptyCol = -1;
    int tileRow = -1, tileCol = -1;

    //assign array bits into their new positions
    for (int row = 0; row < NUM_ROWS; row++) 
    {
        for (int col = 0; col < NUM_COLS; col++)
        {
            if (board[row][col] == -1) 
            {
                emptyRow = row;
                emptyCol = col;
            } 
            else if (board[row][col] == tile) 
            {
                tileRow = row;
                tileCol = col;
            }
        }
    }

    // here we are making sure the tile is adjacent to the empty square
    int isAdjacent = ((abs(tileRow - emptyRow) == 1 && tileCol == emptyCol) ||
                       (tileRow == emptyRow && abs(tileCol - emptyCol) == 1));

    // since tile is adajacent we are required to swap the values of the tile
       if  (isAdjacent) 
       {
       board[emptyRow][emptyCol] = tile;
       board[tileRow][tileCol] = -1;
    }
}




",1
bpat907,1695989079,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int r, c;
	FindTile(board, tile, &r, &c);

	if ((r == 1) || (r == 2)) {
		if ((c == 1) || (c == 2)) {
			if (board[r - 1][c] == -1) {
				board[r - 1][c] = tile;
				board[r][c] = -1;
			}
			else if (board[r][c - 1] == -1) {
				board[r][c - 1] = tile;
				board[r][c] = -1;
			}
			else if (board[r][c + 1] == -1) {
				board[r][c + 1] = tile;
				board[r][c] = -1;
			}
			else if (board[r + 1][c] == -1) {
				board[r + 1][c] = tile;
				board[r][c] = -1;
			}
		}
	}

	if (r == 0) {
		if ((c == 1) || (c == 2)) {
			if (board[r][c - 1] == -1) {
				board[r][c - 1] = tile;
				board[r][c] = -1;
			}
			else if (board[r][c + 1] == -1) {
				board[r][c + 1] = tile;
				board[r][c] = -1;
			}
			else if (board[r + 1][c] == -1) {
				board[r + 1][c] = tile;
				board[r][c] = -1;
			}
		}
	}

	if (r == 3) {
		if ((c == 1) || (c == 2)) {
			if (board[r][c - 1] == -1) {
				board[r][c - 1] = tile;
				board[r][c] = -1;
			}
			else if (board[r][c + 1] == -1) {
				board[r][c + 1] = tile;
				board[r][c] = -1;
			}
			else if (board[r - 1][c] == -1) {
				board[r - 1][c] = tile;
				board[r][c] = -1;
			}
		}
	}

	if (c == 0) {
		if ((r == 1) || (r == 2)) {
			if (board[r - 1][c] == -1) {
				board[r - 1][c] = tile;
				board[r][c] = -1;
			}
			else if (board[r][c + 1] == -1) {
				board[r][c + 1] = tile;
				board[r][c] = -1;
			}
			else if (board[r + 1][c] == -1) {
				board[r + 1][c] = tile;
				board[r][c] = -1;
			}
		}
	}

	if (c == 3) {
		if ((r == 1) || (r == 2)) {
			if (board[r - 1][c] == -1) {
				board[r - 1][c] = tile;
				board[r][c] = -1;
			}
			else if (board[r][c - 1] == -1) {
				board[r][c - 1] = tile;
				board[r][c] = -1;
			}
			else if (board[r + 1][c] == -1) {
				board[r + 1][c] = tile;
				board[r][c] = -1;
			}
		}
	}

	if ((r == 0) && (c == 0)) {
		if (board[r][c + 1] == -1) {
			board[r][c + 1] = tile;
			board[r][c] = -1;
		}
		else if (board[r + 1][c] == -1) {
			board[r + 1][c] = tile;
			board[r][c] = -1;
		}
	}

	if ((r == 0) && (c == 3)) {
		if (board[r][c - 1] == -1) {
			board[r][c - 1] = tile;
			board[r][c] = -1;
		}
		else if (board[r + 1][c] == -1) {
			board[r + 1][c] = tile;
			board[r][c] = -1;
		}
	}

	if ((r == 3) && (c == 3)) {
		if (board[r][c - 1] == -1) {
			board[r][c - 1] = tile;
			board[r][c] = -1;
		}
		else if (board[r - 1][c] == -1) {
			board[r - 1][c] = tile;
			board[r][c] = -1;
		}
	}

	if ((r == 3) && (c == 0)) {
		if (board[r][c + 1] == -1) {
			board[r][c + 1] = tile;
			board[r][c] = -1;
		}
		else if (board[r - 1][c] == -1) {
			board[r - 1][c] = tile;
			board[r][c] = -1;
		}
	}
	return;
}",1
bril841,1696221791,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int rowPosTile, colPosTile;
    int rowPosEmpty, colPosEmpty;

    // Find the positions of the tile and the empty square
    FindTile(board, tile, &rowPosTile, &colPosTile);
    FindTile(board, -1, &rowPosEmpty, &colPosEmpty);

    // Check if the tile and the empty square are adjacent
    if ((abs(rowPosTile - rowPosEmpty) == 1 && colPosTile == colPosEmpty) ||
        (abs(colPosTile - colPosEmpty) == 1 && rowPosTile == rowPosEmpty)) {
        // Swap the tile and the empty square
        board[rowPosEmpty][colPosEmpty] = tile;
        board[rowPosTile][colPosTile] = -1;
    }
    // If they are not adjacent, do nothing because the move is invalid
}",1
bsil719,1695779229,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowgap, colgap;
    int rowtile, coltile;
    
    FindTile(board, -1, &rowgap, &colgap);
    FindTile(board, tile, &rowtile, &coltile);
    
if ((abs(rowgap - rowtile) == 1) && (colgap == coltile)) || ((abs(colgap - coltile) == 1) && (rowgap == rowtile)){
    board[rowgap][colgap] = tile;
    board[rowtile][coltile] = -1;
}

}",0
bsil719,1695779316,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowgap, colgap;
    int rowtile, coltile;
    
    FindTile(board, -1, &rowgap, &colgap);
    FindTile(board, tile, &rowtile, &coltile);
    
if (((abs(rowgap - rowtile) == 1) && (colgap == coltile)) || ((abs(colgap - coltile) == 1) && (rowgap == rowtile))){
    board[rowgap][colgap] = tile;
    board[rowtile][coltile] = -1;
}

}",1
bvau704,1695778988,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
 int temp;
 int rowGap, colGap;
 int rowTile, colTile;

FindTile(board, -1, &rowGap, &colGap);
FindTile(board, tile, &rowTile, &colTile);

if (((abs(rowTile - rowGap) == 1) && (colTile == colGap)) || ((rowTile == rowGap) && (abs(colTile - colGap) == 1))) {
    
    board[rowGap][colGap] = tile;
    board[rowTile][colGap] = -1;
    
    
}
",0
bvau704,1695779193,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{

	int rowGap, colGap;
	int rowTile, colTile;

	FindTile(board, -1, &rowGap, &colGap);
	FindTile(board, tile, &rowTile, &colTile);

	if (((abs(rowTile - rowGap) == 1) && (colTile == colGap)) || ((rowTile == rowGap) && (abs(colTile - colGap) == 1))) {

		board[rowGap][colGap] = tile;
		board[rowTile][colTile] = -1;


	}
}",1
bwis161,1695700335,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;
	FindTile(board, -1, &row, &col);
		if (col + 1 < NUM_COLS) {
			if (tile == board[row][col + 1]) {
				board[row][col] = tile;
				board[row][col + 1] = -1;
			}
		}
		if (col - 1 >= 0) {
			if (tile == board[row][col - 1]) {
				board[row][col] = tile;
				board[row][col - 1] = -1;
			}
		}
		if (row + 1 < NUM_ROWS) {
			if (tile == board[row + 1][col]) {
				board[row][col] = tile;
				board[row + 1][col] = -1;
			}
		}
		if (row - 1 >= 0) {
			if (tile == board[row - 1][col]) {
			board[row][col] = tile;
			board[row - 1][col] = -1;
			}
		}
}",1
bwoo348,1696217709,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
 /* Checks if -1 and tile are in range */
 int row, col;
 FindTile(board, tile, &row, &col);
 
 if ((board[row][col-1] == -1) && (col>0)){
     board[row][col-1] = tile;
     board[row][col] = -1;
 };
 if ((board[row][col+1] == -1) && (col<NUM_COLS-1)) {
     board[row][col+1] = tile;
     board[row][col] = -1;
 };
 if ((board[row-1][col] == -1) && (row>0)) {
     board[row-1][col] = tile;
     board[row][col] = -1;
 };
 if ((board[row+1][col] == -1) && (row<NUM_ROWS-1)) {
     board[row+1][col] = tile;
     board[row][col] = -1;
 };
}",1
byiu331,1695851852,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j;
	int emptyRow, emptyCol;
	int tileRow, tileCol;

	FindTile(board, -1, &emptyRow, &emptyCol);
	FindTile(board, tile, &tileRow, &tileCol);

	
	if (emptyCol == 0) {
		if ((((tileRow == emptyRow + 1) || (tileRow == emptyRow - 1)) && (tileCol == emptyCol)) || ((tileRow == emptyRow) && (tileCol == emptyCol + 1))) {
			board[tileRow][tileCol] = -1;
			board[emptyRow][emptyCol] = tile;
		}
		else {
			return;
		}
	}
	else if (emptyCol == 3) {
		if ((((tileRow == emptyRow + 1) || (tileRow == emptyRow - 1)) && (tileCol == emptyCol)) || ((tileRow == emptyRow) && (tileCol == emptyCol - 1))) {
			board[tileRow][tileCol] = -1;
			board[emptyRow][emptyCol] = tile;
		}
		else {
			return;
		}
	}
	else if ((emptyCol > 0) && (emptyCol < 3)) {
		if ((((tileRow == emptyRow + 1) || (tileRow == emptyRow - 1)) && (tileCol == emptyCol)) || ((tileRow == emptyRow) && ((tileCol == emptyCol - 1) || (tileCol == emptyCol + 1)))) {
			board[tileRow][tileCol] = -1;
			board[emptyRow][emptyCol] = tile;
		}
		else {
			return;
		}
	}		
}",0
byiu331,1695852041,2,"#include <stdio.h>


void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int emptyRow, emptyCol;
	int tileRow, tileCol;

	FindTile(board, -1, &emptyRow, &emptyCol);
	FindTile(board, tile, &tileRow, &tileCol);

	
	if (emptyCol == 0) {
		if ((((tileRow == emptyRow + 1) || (tileRow == emptyRow - 1)) && (tileCol == emptyCol)) || ((tileRow == emptyRow) && (tileCol == emptyCol + 1))) {
			board[tileRow][tileCol] = -1;
			board[emptyRow][emptyCol] = tile;
		}
		else {
			return;
		}
	}
	else if (emptyCol == 3) {
		if ((((tileRow == emptyRow + 1) || (tileRow == emptyRow - 1)) && (tileCol == emptyCol)) || ((tileRow == emptyRow) && (tileCol == emptyCol - 1))) {
			board[tileRow][tileCol] = -1;
			board[emptyRow][emptyCol] = tile;
		}
		else {
			return;
		}
	}
	else if ((emptyCol > 0) && (emptyCol < 3)) {
		if ((((tileRow == emptyRow + 1) || (tileRow == emptyRow - 1)) && (tileCol == emptyCol)) || ((tileRow == emptyRow) && ((tileCol == emptyCol - 1) || (tileCol == emptyCol + 1)))) {
			board[tileRow][tileCol] = -1;
			board[emptyRow][emptyCol] = tile;
		}
		else {
			return;
		}
	}		
}",1
byul423,1695708560,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;
	FindTile(board, tile, &row, &col);

	if ((row > 0) && (row < 3)) {
		if (board[row - 1][col] == -1) {
			board[row - 1][col] = tile;
			board[row][col] = -1;
		}
		else if (board[row + 1][col] == -1) {
			board[row + 1][col] = tile;
			board[row][col] = -1;
		}

	}
	else if (row == 0) {
		if (board[row + 1][col] == -1) {
			board[row + 1][col] = tile;
			board[row][col] = -1;
		}

	}
	else if (row == 3) {
		if (board[row - 1][col] == -1) {
			board[row - 1][col] = tile;
			board[row][col] = -1;
		}
	}

	if ((col > 0) && (col < 3)) {
		if (board[row][col - 1] == -1) {
			board[row][col - 1] = tile;
			board[row][col] = -1;
		}
		else if (board[row][col + 1] == -1) {
			board[row][col + 1] = tile;
			board[row][col] = -1;
		}
	}
	else if (col == 0) {
		if (board[row][col + 1] == -1) {
			board[row][col + 1] = tile;
			board[row][col] = -1;
		}
	}
	else if (col == 3) {
		if (board[row][col - 1] == -1) {
			board[row][col - 1] = tile;
			board[row][col] = -1;
		}
	}
}",1
cada577,1695902134,1,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int temp;
        
   
    int row, col, row1, col1;

    FindTile(board, -1, &row, &col);
  FindTile(board, tile, &row1, &col1);

if(row1+1 == row && col == col1){
    temp = board[row][col];
board[row][col] = board[row1][col1];
board[row1][col1] = temp;
}

if(row1-1 == row && col == col1){
    temp = board[row][col];
board[row][col] = board[row1][col1];
board[row1][col1] = temp;
}

if(col1+1 == col && row == row1){
    temp = board[row][col];
board[row][col] = board[row1][col1];
board[row1][col1] = temp;
}

if(col1-1 == col && row == row1){
    temp = board[row][col];
board[row][col] = board[row1][col1];
board[row1][col1] = temp;
}
    
    
}",1
cana544,1695848120,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int movRow, movCol, spaceRow, spaceCol;
    for (int i = 0; i < 4; i++) {
        for (int j = 0; i < 4; i++) {
            if (board[i][j] == -1) {
                if (board[i - 1][j] == tile) {
					board[i][j] = tile;
					board[i - 1][j] = -1;
                } 
                else if (board[i][j + 1] == tile) {
					board[i][j] = tile;
					board[i][j + 1] = -1;
				}
				else if (board[i + 1][j] == tile) {
					board[i][j] = tile;
					board[i + 1][j] = -1;
				}
				else (board[i][j - 1] == tile) {
					board[i][j] = tile;
					board[i][j - 1] = -1;
				}
				return;
            }
        }
    }
}",0
cana544,1695848496,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    for (int i = 0; i < 4; i++) {
        for (int j = 0; i < 4; j++) {
            if (board[i][j] == -1) {
                if (board[i - 1][j] == tile) {
					board[i][j] = tile;
					board[i - 1][j] = -1;
                } 
                else if (board[i][j + 1] == tile) {
					board[i][j] = tile;
					board[i][j + 1] = -1;
				}
				else if (board[i + 1][j] == tile) {
					board[i][j] = tile;
					board[i + 1][j] = -1;
				}
				else if (board[i][j - 1] == tile) {
					board[i][j] = tile;
					board[i][j - 1] = -1;
				}
				else {
					return;
				}
            }
        }
    }
}",0
cana544,1695878877,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            if (board[i][j] == -1) {
                if (i > 0 && board[i - 1][j] == tile) {
                    board[i][j] = tile;
                    board[i - 1][j] = -1;
                } 
                else if (j < 4 - 1 && board[i][j + 1] == tile) {
                    board[i][j] = tile;
                    board[i][j + 1] = -1;
                }
                else if (i < 4 - 1 && board[i + 1][j] == tile) {
                    board[i][j] = tile;
                    board[i + 1][j] = -1;
                }
                else if (j > 0 && board[i][j - 1] == tile) {
                    board[i][j] = tile;
                    board[i][j - 1] = -1;
                }
                else {
                    return;
                }
            }
        }
    }
}",0
cana544,1695879614,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == -1) {
                if (i > 0 && board[i - 1][j] == tile) {
                    board[i][j] = tile;
                    board[i - 1][j] = -1;
                } 
                else if (j < 3 && board[i][j + 1] == tile) {
                    board[i][j] = tile;
                    board[i][j + 1] = -1;
                }
                else if (i < 3 && board[i + 1][j] == tile) {
                    board[i][j] = tile;
                    board[i + 1][j] = -1;
                }
                else if (j > 0 && board[i][j - 1] == tile) {
                    board[i][j] = tile;
                    board[i][j - 1] = -1;
                }
                else {
                    // Handle corner cases
                    if (i == 0 && j == 0 && board[i + 1][j + 1] == tile) {
                        board[i][j] = tile;
                        board[i + 1][j + 1] = -1;
                    }
                    else if (i == 0 && j == 3 && board[i + 1][j - 1] == tile) {
                        board[i][j] = tile;
                        board[i + 1][j - 1] = -1;
                    }
                    else if (i == 3 && j == 0 && board[i - 1][j + 1] == tile) {
                        board[i][j] = tile;
                        board[i - 1][j + 1] = -1;
                    }
                    else if (i == 3 && j == 3 && board[i - 1][j - 1] == tile) {
                        board[i][j] = tile;
                        board[i - 1][j - 1] = -1;
                    }
                    else {
                        return;
                    }
                }
            }
        }
    }
}
",0
cana544,1695880085,5,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRow, tileCol, emptyRow, emptyCol;

    // Find the positions of the specified tile and the empty square
    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol);

    // Check if the specified tile and the empty square are adjacent
    if ((tileRow == emptyRow && (tileCol == emptyCol + 1 || tileCol == emptyCol - 1)) ||
        (tileCol == emptyCol && (tileRow == emptyRow + 1 || tileRow == emptyRow - 1))) {
        // Swap the specified tile and the empty square
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}
",1
cang688,1696040112,1,"#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRowPos,tileRowPos,emptyColPos,tileColPos;
    
    FindTile(board, -1, &emptyRowPos, &emptyColPos);
    FindTile(board, tile, &tileRowPos, &tileColPos);
    
    //check whether the tile can be moved can be moved horizontally (columns) or vertically (rows)
    if (((tileRowPos == emptyRowPos) && abs(tileColPos-emptyColPos)== 1) || ((tileColPos == emptyColPos) && abs(tileRowPos-emptyRowPos)== 1)) {
        //set the previously empty tile with the selected tile and vice versa
        board[tileRowPos][tileColPos] = -1;
        board[emptyRowPos][emptyColPos] = tile;
    }

}",1
cbee072,1695780886,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    
    int i;
    int j;
    int row, col;
    int tileR, tileC;
    // if tile = either +-1 of row and col of -1
    
    //Finding negative tile
    FindTile(board, -1, &row, &col);
    
    FindTile(board, tile, &tileR, &tileC);
    
    if (((row + 1 == tileR) && (col == tileC)) || ((row == tileR) && (col + 1 == tileC)) || ((row - 1 == tileR) && (col == tileC)) || ((row == tileR) && (col - 1 == tileC))) {
        board[row][col] = tile;
        board[tileR][tileC] = -1;
    }
}
",0
cbee072,1695780950,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    
    int row, col;
    int tileR, tileC;
    // if tile = either +-1 of row and col of -1
    
    //Finding negative tile
    FindTile(board, -1, &row, &col);
    
    FindTile(board, tile, &tileR, &tileC);
    
    if (((row + 1 == tileR) && (col == tileC)) || ((row == tileR) && (col + 1 == tileC)) || ((row - 1 == tileR) && (col == tileC)) || ((row == tileR) && (col - 1 == tileC))) {
        board[row][col] = tile;
        board[tileR][tileC] = -1;
    }
}
",1
cben375,1696129772,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;
	FindTile(board, tile, &row, &col);

	if (row - 1 >= 0 && board[row - 1][col] == -1) {
		board[row][col] = -1;
		board[row - 1][col] = tile;
	}
	else if (row + 1 < NUM_ROWS && board[row + 1][col] == -1) {
		board[row][col] = -1;
		board[row + 1][col] = tile;
	}
	else if (col - 1 >= 0 && board[row][col - 1] == -1) {
		board[row][col] = -1;
		board[row][col - 1] = tile;
	}
	else if (col + 1 < NUM_COLS && board[row][col + 1] == -1) {
		board[row][col] = -1;
		board[row][col + 1] = tile;
	",0
cben375,1696129825,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;
	FindTile(board, tile, &row, &col);

	if (row - 1 >= 0 && board[row - 1][col] == -1) {
		board[row][col] = -1;
		board[row - 1][col] = tile;
	}
	else if (row + 1 < NUM_ROWS && board[row + 1][col] == -1) {
		board[row][col] = -1;
		board[row + 1][col] = tile;
	}
	else if (col - 1 >= 0 && board[row][col - 1] == -1) {
		board[row][col] = -1;
		board[row][col - 1] = tile;
	}
	else if (col + 1 < NUM_COLS && board[row][col + 1] == -1) {
		board[row][col] = -1;
		board[row][col + 1] = tile;
	}
}",1
cbro223,1695621805,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	// Find the missing tile and store it
	int missingTileRow, missingTileCol;
	FindTile(board, -1, &missingTileRow, &missingTileCol);

	// Find the selected tile
	int moveTileRow, moveTileCol;
	FindTile(board, tile, &moveTileRow, &moveTileCol);

	// Check if the tile is adjacent to the missing tile
	int rowTileDistance = moveTileRow - missingTileRow;
	int colTileDistance = moveTileCol - missingTileCol;

	int adjacentHorizontal = rowTileDistance <= 1 && rowTileDistance >= -1;
	int adjacentVertical = (colTileDistance <= 1 && colTileDistance >= -1);
	//If not adjacent then exit the function
	if (!((adjacentHorizontal && colTileDistance == 0 ) || (adjacentVertical && rowTileDistance == 0)))
		return;
	
	//Swap the tile 
	board[moveTileRow][moveTileCol] = -1;
	board[missingTileRow][missingTileCol] = tile;
}",1
cbro435,1695872723,1,"#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#define NUM_ROWS 4
#define NUM_COLS 4
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
int row, col;
int emptyr, emptyc;
FindTile(board, -1, &row, &col);
FindTile(board, tile, &emptyr, &emptyc);
int empty = board[emptyr][emptyc];
 if((col==emptyc) && (row==emptyr+1 || row==emptyr-1)){
        board[emptyr][emptyc]= board[row][col];
        board[row][col]=empty;    
        }
        
if((row==emptyr) && (col==emptyc+1 || col==emptyc-1)){
        board[emptyr][emptyc]= board[row][col];
        board[row][col]=empty;        
    }
    return;
}",1
cbro989,1695706480,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int Row, Col, row, col, temp1, temp2;
    FindTile(board[NUM_ROWS][NUM_COLS], tile, &Row, &Col);
    FindTile(board, -1, &row, &col);
    
    
if (((Row - row) >= 1) || ((Row - row) >= -1) || ((Row - row) >= 0)){
return;}
    else{
    temp1 = Row;
    Row = row;
    row = temp1;
}
if (((Col - col) >= 1) || ((Col - col) >= -1) || ((Col - col) >= 0)){
return;}
    else{
        temp2 = Col;
        Col = col;
        col = temp2;
    }
return;
}
",0
cbro989,1695707029,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int Row, Col, row, col, temp, riff, ciff;
    FindTile(board, tile, &Row, &Col);
    FindTile(board, -1, &row, &col);
    
    riff = Row - row;
    ciff = Col - col;
    
if ((riff == 1 && ciff == 0) || (riff == -1 && ciff == 0) || (riff == 0 && ciff == 1) || (riff == 0 && ciff == -1)) {
        int temp = board[Row][Col];
        board[Row][Col] = board[row][col];
        board[row][col] = temp;
    } else {
        return;
}
}",0
cbro989,1695707080,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int Row, Col, row, col, riff, ciff;
    FindTile(board, tile, &Row, &Col);
    FindTile(board, -1, &row, &col);
    
    riff = Row - row;
    ciff = Col - col;
    
if ((riff == 1 && ciff == 0) || (riff == -1 && ciff == 0) || (riff == 0 && ciff == 1) || (riff == 0 && ciff == -1)) {
        int temp = board[Row][Col];
        board[Row][Col] = board[row][col];
        board[row][col] = temp;
    } else {
        return;
}
}",1
cbur703,1696033652,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int  emptyrow, emptycol, temp, tilerow, tilecol;
    
    FindTile(board, -1, &emptyrow, &emptycol);
    FindTile(board, tile, &tilerow, &tilecol);
    
    if ((tilerow == emptyrow - 1 && tilecol == emptycol) || (tilerow == emptyrow + 1 && tilecol == emptycol) || 
    (tilerow == emptyrow && tilecol == emptycol - 1) || (tilerow == emptyrow && tilecol == emptycol + 1)) {
        temp = board[tilerow][tilecol];
        board[tilerow][tilecol] = board[emptyrow][emptycol];
        board[emptyrow][emptycol] = temp;
        
    } else {
        return;
        
    }
}",1
ccha663,1696071888,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int xRow, yCol, zRow, dCol;

    
    FindTile(board, -1, &xRow, &yCol);
    FindTile(board, tile, &zRow, &dCol);

    
    if ((xRow == zRow && (yCol == dCol - 1 || yCol == dCol + 1)) ||
        (yCol == dCol && (xRow == zRow - 1 || xRow == zRow + 1))) {

        
        board[xRow][yCol] = tile;
        board[zRow][dCol] = -1;
    }
}",1
ccha854,1696044745,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rTile,cTile;
    FindTile(board,tile,&rTile,&cTile);
    
    int rSpace,cSpace;
    FindTile(board,-1,&rSpace,&cSpace);
    
    if (((rTile-rSpace==1 || rSpace-rTile==1) && cTile==cSpace) || ((cTile-cSpace==1 || cSpace-cTile==1) && rTile==rSpace)) {
        int temp = board[rTile][cTile];
        board[rTile][cTile] = board[rSpace][cSpace];
        board[rSpace][cSpace] = temp;        
    }
    
}",1
cche441,1695688363,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int number_row,number_col,number = tile;
	int row, col, row_diff = 0, col_diff = 0;
    FindTile(board, -1, &row, &col);
    FindTile(board, number, &number_row, &number_col);

	row_diff = number_row - row;
	col_diff = number_col - col;
	
	if ((row_diff == -1 && col_diff == 0) || (row_diff == 1 && col_diff == 0) || (row_diff == 0 && col_diff == -1) || (row_diff == 0 && col_diff == 1)){
		board[row][col] = tile;
		board[number_row][number_col] = -1;
	}
}",1
cche873,1695810102,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
     int emptyRow;
     int emptyCol;
    FindTile(board, -1, &emptyRow, &emptyCol);

    int tileRow; 
    int tileCol;
    FindTile(board, tile, &tileRow, &tileCol);

    int rowDiff = emptyRow - tileRow;
    int colDiff = emptyCol - tileCol;

    if ((rowDiff == 1 && colDiff == 0) || (rowDiff == -1 && colDiff == 0) || (rowDiff == 0 && colDiff == 1) || (rowDiff == 0 && colDiff == -1)) {
        board[emptyRow][emptyCol] = board[tileRow][tileCol];
        board[tileRow][tileCol] = -1;
    } else {
        return;
    }
}",1
cdel568,1695701882,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int emprowPos = 0;
	int empcolPos = 0;
	int rowPos = 0;
	int colPos = 0;
	FindTile(board, -1, &emprowPos, &empcolPos);
	FindTile(board, tile, &rowPos, &colPos);

	if (((emprowPos + 1 == rowPos) && empcolPos == colPos) || ((emprowPos - 1 == rowPos) && empcolPos == colPos) || ((empcolPos + 1 == colPos) && emprowPos == rowPos) || ((empcolPos - 1 == colPos) && emprowPos == rowPos)) {
		board[emprowPos][empcolPos] = board[rowPos][colPos];
		board[rowPos][colPos] = -1;
	}
}",1
cdin152,1696047045,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tile_row, tile_col;
	int empty_row, empty_col;

	/* Locate the position of the moving tile and empty tile*/
	FindTile(board, -1, &empty_row, &empty_col);
	FindTile(board, tile, &tile_row, &tile_col);

	/* Only if the tile is directly above, below, left of right can the move be executed*/
	if ((abs(tile_row - empty_row) == 1 && tile_col == empty_col) ||
		(tile_row == empty_row && abs(tile_col - empty_col) == 1)) {
		board[tile_row][tile_col] = board[empty_row][empty_col];
		board[empty_row][empty_col] = tile;
	}
}",1
cdin268,1695698750,1,"void FindTile(int board[4][4], int tile, int *rowPos, int *colPos) {
    int i;
    int j;
    
    
    
    for (i = 0; i<4; i++) {
        for (j = 0; j<4; j++) {
            if (board[i][j] == tile) {
                *rowPos = i;
                *colPos = j;
            }
        }
    }
}

void MakeMove(int board[4][4], int tile) {
    
    int old = 0;
    int row, col;
    int rowT, colT;
    
    FindTile(board, -1, &row, &col);
    FindTile(board, tile, &rowT, &colT);
    
    if (row != 0 && row !=3 && col != 0 && col != 3) {
        if ((rowT - 1 == row && colT == col) || (rowT + 1 == row && colT == col) || (rowT == row && colT - 1 == col) || (rowT == row && colT + 1 == col)) {
            old = tile;
            board[rowT][colT] = -1;
            board[row][col] = tile;
        }
    } else if (row == 0 && col == 0){
        if ((rowT + 1 == row && colT == col) || (rowT == row && colT + 1 == col)) {
            old = tile;
            board[rowT][colT] = -1;
            board[row][col] = tile;
        }
    } else if (row == 0){
        if ((rowT + 1 == row && colT == col) || (rowT == row && colT + 1 == col) || (rowT == row && colT -1 == col)) {
            old = tile;
            board[rowT][colT] = -1;
            board[row][col] = tile;
        }
    } else if (col == 0){
        if ((rowT + 1 == row && colT == col) || (rowT == row && colT + 1 == col) || (rowT - 1 == row && colT == col)) {
            old = tile;
            board[rowT][colT] = -1;
            board[row][col] = tile;
        }
    } else {
        return;
    }
    
}",0
cdin268,1695698780,2,"void MakeMove(int board[4][4], int tile) {
    
    int old = 0;
    int row, col;
    int rowT, colT;
    
    FindTile(board, -1, &row, &col);
    FindTile(board, tile, &rowT, &colT);
    
    if (row != 0 && row !=3 && col != 0 && col != 3) {
        if ((rowT - 1 == row && colT == col) || (rowT + 1 == row && colT == col) || (rowT == row && colT - 1 == col) || (rowT == row && colT + 1 == col)) {
            old = tile;
            board[rowT][colT] = -1;
            board[row][col] = tile;
        }
    } else if (row == 0 && col == 0){
        if ((rowT + 1 == row && colT == col) || (rowT == row && colT + 1 == col)) {
            old = tile;
            board[rowT][colT] = -1;
            board[row][col] = tile;
        }
    } else if (row == 0){
        if ((rowT + 1 == row && colT == col) || (rowT == row && colT + 1 == col) || (rowT == row && colT -1 == col)) {
            old = tile;
            board[rowT][colT] = -1;
            board[row][col] = tile;
        }
    } else if (col == 0){
        if ((rowT + 1 == row && colT == col) || (rowT == row && colT + 1 == col) || (rowT - 1 == row && colT == col)) {
            old = tile;
            board[rowT][colT] = -1;
            board[row][col] = tile;
        }
    } else {
        return;
    }
    
}",0
cdin268,1695709179,3,"void MakeMove(int board[4][4], int tile) {
    
    int row, col;
    int rowT, colT;
    
    FindTile(board, -1, &row, &col);
    FindTile(board, tile, &rowT, &colT);
    
    if (row != 0 && row !=3 && col != 0 && col != 3) {
        if ((rowT - 1 == row && colT == col) || (rowT + 1 == row && colT == col) || (rowT == row && colT - 1 == col) || (rowT == row && colT + 1 == col)) {
            board[row][col] = tile;
            board[rowT][colT] = -1;
            
        }
    } else if (row == 0 && col == 0){
        if ((rowT - 1 == row && colT == col) || (rowT == row && colT - 1 == col)) {
            board[row][col] = tile;
            board[rowT][colT] = -1;
            
        }
    } else if (row == 3 && col == 3){
        if ((rowT + 1 == row && colT == col) || (rowT == row && colT + 1 == col)) {
            board[row][col] = tile;
            board[rowT][colT] = -1;
            
        }
    } else if (row == 3 && col == 0){
        if ((rowT + 1 == row && colT == col) || (rowT == row && colT - 1 == col)) {
            board[row][col] = tile;
            board[rowT][colT] = -1;
            
        }
    }else if (row == 0 && col == 3){
        if ((rowT - 1 == row && colT == col) || (rowT == row && colT + 1 == col)) {
            board[row][col] = tile;
            board[rowT][colT] = -1;
            
        }
    }else if (row == 0){
        if ((rowT - 1 == row && colT == col) || (rowT + 1 == row && colT == col) || (rowT == row && colT -1 == col)) {
            board[row][col] = tile;
            board[rowT][colT] = -1;
            
        }
    } else if (col == 0){
        if ((rowT - 1 == row && colT == col) || (rowT == row && colT + 1 == col) || (rowT == row && colT - 1 == col)) {
            board[row][col] = tile;
            board[rowT][colT] = -1;
            
        }
    } else if (row == 3){
        if ((rowT + 1 == row && colT == col) || (rowT == row && colT + 1 == col) || (rowT == row && colT == col - 1)) {
            board[row][col] = tile;
            board[rowT][colT] = -1;
            
        }
    } else if (col == 3){
        if ((rowT + 1 == row && colT == col) || (rowT == row && colT + 1 == col) || (rowT - 1 == row && colT == col)) {
            board[row][col] = tile;
            board[rowT][colT] = -1;
            
        }
    } else {
        return;
    }
    
}",0
cdin268,1695709958,4,"void MakeMove(int board[4][4], int tile) {
    
    int row, col;
    int rowT, colT;
    
    FindTile(board, -1, &row, &col);
    FindTile(board, tile, &rowT, &colT);
    
    if (row != 0 && row !=3 && col != 0 && col != 3) {
        if ((rowT - 1 == row && colT == col) || (rowT + 1 == row && colT == col) || (rowT == row && colT - 1 == col) || (rowT == row && colT + 1 == col)) {
            board[row][col] = tile;
            board[rowT][colT] = -1;
            
        }
    } else if (row == 0 && col == 0){
        if ((rowT - 1 == row && colT == col) || (rowT == row && colT - 1 == col)) {
            board[row][col] = tile;
            board[rowT][colT] = -1;
            
        }
    } else if (row == 3 && col == 3){
        if ((rowT + 1 == row && colT == col) || (rowT == row && colT + 1 == col)) {
            board[row][col] = tile;
            board[rowT][colT] = -1;
            
        }
    } else if (row == 3 && col == 0){
        if ((rowT + 1 == row && colT == col) || (rowT == row && colT - 1 == col)) {
            board[row][col] = tile;
            board[rowT][colT] = -1;
            
        }
    }else if (row == 0 && col == 3){
        if ((rowT - 1 == row && colT == col) || (rowT == row && colT + 1 == col)) {
            board[row][col] = tile;
            board[rowT][colT] = -1;
            
        }
    }else if (row == 0){
        if ((rowT - 1 == row && colT == col) || (rowT == row && colT+ 1 == col ) || (rowT == row && colT -1 == col)) {
            board[row][col] = tile;
            board[rowT][colT] = -1;
            
        }
    } else if (col == 0){
        if ((rowT - 1 == row && colT == col) || (rowT + 1 == row && colT  == col) || (rowT == row && colT - 1 == col)) {
            board[row][col] = tile;
            board[rowT][colT] = -1;
            
        }
    } else if (row == 3){
        if ((rowT + 1 == row && colT == col) || (rowT == row && colT + 1 == col) || (rowT == row && colT == col - 1)) {
            board[row][col] = tile;
            board[rowT][colT] = -1;
            
        }
    } else if (col == 3){
        if ((rowT + 1 == row && colT == col) || (rowT == row && colT + 1 == col) || (rowT - 1 == row && colT == col)) {
            board[row][col] = tile;
            board[rowT][colT] = -1;
            
        }
    } else {
        return;
    }",0
cdin268,1695710004,5,"void MakeMove(int board[4][4], int tile) {
    
    int row, col;
    int rowT, colT;
    
    FindTile(board, -1, &row, &col);
    FindTile(board, tile, &rowT, &colT);
    
    if (row != 0 && row !=3 && col != 0 && col != 3) {
        if ((rowT - 1 == row && colT == col) || (rowT + 1 == row && colT == col) || (rowT == row && colT - 1 == col) || (rowT == row && colT + 1 == col)) {
            board[row][col] = tile;
            board[rowT][colT] = -1;
            
        }
    } else if (row == 0 && col == 0){
        if ((rowT - 1 == row && colT == col) || (rowT == row && colT - 1 == col)) {
            board[row][col] = tile;
            board[rowT][colT] = -1;
            
        }
    } else if (row == 3 && col == 3){
        if ((rowT + 1 == row && colT == col) || (rowT == row && colT + 1 == col)) {
            board[row][col] = tile;
            board[rowT][colT] = -1;
            
        }
    } else if (row == 3 && col == 0){
        if ((rowT + 1 == row && colT == col) || (rowT == row && colT - 1 == col)) {
            board[row][col] = tile;
            board[rowT][colT] = -1;
            
        }
    }else if (row == 0 && col == 3){
        if ((rowT - 1 == row && colT == col) || (rowT == row && colT + 1 == col)) {
            board[row][col] = tile;
            board[rowT][colT] = -1;
            
        }
    }else if (row == 0){
        if ((rowT - 1 == row && colT == col) || (rowT == row && colT+ 1 == col ) || (rowT == row && colT -1 == col)) {
            board[row][col] = tile;
            board[rowT][colT] = -1;
            
        }
    } else if (col == 0){
        if ((rowT - 1 == row && colT == col) || (rowT + 1 == row && colT  == col) || (rowT == row && colT - 1 == col)) {
            board[row][col] = tile;
            board[rowT][colT] = -1;
            
        }
    } else if (row == 3){
        if ((rowT + 1 == row && colT == col) || (rowT == row && colT + 1 == col) || (rowT == row && colT == col - 1)) {
            board[row][col] = tile;
            board[rowT][colT] = -1;
            
        }
    } else if (col == 3){
        if ((rowT + 1 == row && colT == col) || (rowT == row && colT + 1 == col) || (rowT - 1 == row && colT == col)) {
            board[row][col] = tile;
            board[rowT][colT] = -1;
            
        }
    } else {
        return;
    }
}",1
cdsi208,1696229678,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {

   int row, col;
   FindTile(board, -1, &row, &col);
    
    if (col + 1 < NUM_COLS && board[row][col + 1] == tile) {
  
    int row1, col1;
   FindTile(board, tile, &row1, &col1);
   
   board[row][col] = tile;
   
   board[row1][col1] = -1;
   
    } 
    
    if (col - 1 >= 0 && board[row][col - 1] == tile) {

    
   int row1, col1;
   FindTile(board, tile, &row1, &col1);
   
   board[row][col] = tile;
   
   board[row1][col1] = -1;
    }  
    
    if (row - 1 >= 0 && board[row - 1][col] == tile) {
  
   int row1, col1;
   FindTile(board, tile, &row1, &col1);
   
   board[row][col] = tile;
   
   board[row1][col1] = -1;
    
    }
    
    if (row + 1 < NUM_ROWS && board[row + 1][col] == tile) {
    
   int row1, col1;
   FindTile(board, tile, &row1, &col1);
   
   board[row][col] = tile;
   
   board[row1][col1] = -1;
   
    }
    
   
}",1
cgaz516,1695696777,1,"{
	int row, col, empty_row, empty_col;

	// Find the position of the tile we are looking for
	FindTile(board, tile, &row, &col);
	// Find the position of the empty tile

	// Check if empty tile is below swapping tile
	if (board[row + 1][col] == -1) {
		board[row][col] = -1;
		board[row + 1][col] = tile;
	}

	// Check if empty tile is above swapping tile
	if (board[row - 1][col] == -1) {
		board[row][col] = -1;
		board[row - 1][col] = tile;
	}

	// Check if empty tile is to the right of swapping tile
	if (board[row][col + 1] == -1) {
		board[row][col] = -1;
		board[row][col + 1] = tile;
	}

	// Check if empty tile is to the left of swapping tile
	if (board[row][col - 1] == -1) {
		board[row][col] = -1;
		board[row][col - 1] = tile;
	}
}",0
cgaz516,1695696803,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, empty_row, empty_col;

	// Find the position of the tile we are looking for
	FindTile(board, tile, &row, &col);
	// Find the position of the empty tile

	// Check if empty tile is below swapping tile
	if (board[row + 1][col] == -1) {
		board[row][col] = -1;
		board[row + 1][col] = tile;
	}

	// Check if empty tile is above swapping tile
	if (board[row - 1][col] == -1) {
		board[row][col] = -1;
		board[row - 1][col] = tile;
	}

	// Check if empty tile is to the right of swapping tile
	if (board[row][col + 1] == -1) {
		board[row][col] = -1;
		board[row][col + 1] = tile;
	}

	// Check if empty tile is to the left of swapping tile
	if (board[row][col - 1] == -1) {
		board[row][col] = -1;
		board[row][col - 1] = tile;
	}
}",0
cgaz516,1695696896,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;

	// Find the position of the tile we are looking for
	FindTile(board, tile, &row, &col);
	// Find the position of the empty tile

	// Check if empty tile is below swapping tile
	if (board[row + 1][col] == -1) {
		board[row][col] = -1;
		board[row + 1][col] = tile;
	}

	// Check if empty tile is above swapping tile
	if (board[row - 1][col] == -1) {
		board[row][col] = -1;
		board[row - 1][col] = tile;
	}

	// Check if empty tile is to the right of swapping tile
	if (board[row][col + 1] == -1) {
		board[row][col] = -1;
		board[row][col + 1] = tile;
	}

	// Check if empty tile is to the left of swapping tile
	if (board[row][col - 1] == -1) {
		board[row][col] = -1;
		board[row][col - 1] = tile;
	}
}",0
cgaz516,1695702815,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;

	// Find the position of the tile we are looking for
	FindTile(board, tile, &row, &col);

		// Check if empty tile is below swapping tile
		if (board[row + 1][col] == -1) {
			board[row][col] = -1;
			board[row + 1][col] = tile;
		}

		// Check if empty tile is above swapping tile
		if (board[row - 1][col] == -1) {
			board[row][col] = -1;
			board[row - 1][col] = tile;
		}

		// Check if empty tile is to the right of swapping tile
		if (col == 0) {
			if (board[row][col + 1] == -1) {
				board[row][col] = -1;
				board[row][col + 1] = tile;
			}
		}
		if (col > 0 && col < 3) {
			if (board[row][col + 1] == -1) {
				board[row][col] = -1;
				board[row][col + 1] = tile;
			}

			if (board[row][col - 1] == -1) {
				board[row][col] = -1;
				board[row][col - 1] = tile;
			}
		}

		if (col == 3) {
			if (board[row][col - 1] == -1) {
				board[row][col] = -1;
				board[row][col - 1] = tile;
			}
		}
}",1
chua804,1696219045,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRow, tileCol;
    int emptyRow, emptyCol;

    // Find the positions of the tile and the empty square
    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol);

    // Check if the tile and empty square are adjacent (horizontally or vertically)
    if ((abs(tileRow - emptyRow) == 1 && tileCol == emptyCol) ||
        (abs(tileCol - emptyCol) == 1 && tileRow == emptyRow)) {
        // Swap the tile and empty square
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    } 
}",1
civa625,1696203337,1,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col;
    int temp;
    FindTile(board, -1, &row, &col);
    
    // Check the adjacent values for -1.
    if (board[row-1][col] == tile) { 
        temp = board[row-1][col];
        board[row-1][col] = -1;
        board[row][col] = temp;
    }
    else if (board[row+1][col] == tile) {
        temp = board[row+1][col];
        board[row+1][col] = -1;
        board[row][col] = temp;
    }
    else if (board[row][col-1] == tile) {
        if (col == 0) { // Cannot go more to the left.
            return; 
        } else {
        temp = board[row][col-1];
        board[row][col-1] = -1;
        board[row][col] = temp;
        }
    }
    else if (board[row][col+1] == tile) {
        if (col == 3) { // Cannot go more to the right.
            return; 
        } else {
        temp = board[row][col+1];
        board[row][col+1] = -1;
        board[row][col] = temp;
        }
    }
    
}",1
cjun818,1696233040,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int emptyRows, emptyCols, tileRows, tileCols;

	FindTile(board, -1, &emptyRows, &emptyCols);
	FindTile(board, tile, &tileRows, &tileCols);

	if ((emptyCols == tileCols && (emptyRows - tileRows == 1 || tileRows - emptyRows == 1)) ||
		(emptyRows == tileRows && (emptyCols - tileCols == 1 || tileCols - emptyCols == 1)))
	{
		board[emptyRows][emptyCols] = tile;
		board[tileRows][tileCols] = -1;
	}
}",1
clee482,1696174250,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{

    int i,j;
    int tilerow, tilecol;
    for(i=0; i<NUM_ROWS; i++)
    {
        for(j=0; j<NUM_COLS; j++)
        {
            if(board[i][j]== tile)
            {
             tilerow = i;
             tilecol = j;
             break;
            }
        }
    }
    
    if (tilerow > 0 && tilecol > 0 && tilerow < NUM_ROWS && tilecol <NUM_COLS)
    {
        if(board[tilerow-1][tilecol]==-1)
        {
            board[tilerow-1][tilecol] = board[tilerow][tilecol];
            board[tilerow][tilecol] = -1;
        }
        else if(board[tilerow+1][tilecol]==-1)
        {
            board[tilerow+1][tilecol]= board[tilerow][tilecol];
            board[tilerow][tilecol] = -1;
        }
        else if(board[tilerow][tilecol-1]==-1)
        {
            board[tilerow][tilecol-1]=board[tilerow][tilecol];
            board[tilerow][tilecol] = -1;
        }
        else if(board[tilerow][tilecol+1]==-1)
        {
            board[tilerow][tilecol+1]= board[tilerow][tilecol];
            board[tilerow][tilecol] = -1;
        }
        
    }
    else if(tilerow == 0)
    {
        if(board[tilerow+1][tilecol]==-1)
        {
            board[tilerow+1][tilecol]= board[tilerow][tilecol];
            board[tilerow][tilecol] = -1;
        }
        else if(board[tilerow][tilecol-1]==-1)
        {
            board[tilerow][tilecol-1]=board[tilerow][tilecol];
            board[tilerow][tilecol] = -1;
        }
        else if(board[tilerow][tilecol+1]==-1)
        {
            board[tilerow][tilecol+1]= board[tilerow][tilecol];
            board[tilerow][tilecol] = -1;
        }
    }
    else if(tilerow == NUM_ROWS)
    {
        if(board[tilerow-1][tilecol]==-1)
        {
            board[tilerow-1][tilecol]= board[tilerow][tilecol];
            board[tilerow][tilecol] = -1;
        }
        else if(board[tilerow][tilecol-1]==-1)
        {
            board[tilerow][tilecol-1]=board[tilerow][tilecol];
            board[tilerow][tilecol] = -1;
        }
        else if(board[tilerow][tilecol+1]==-1)
        {
            board[tilerow][tilecol+1]= board[tilerow][tilecol];
            board[tilerow][tilecol] = -1;
        }
    }
    else if(tilecol == 0)
    {
                if(board[tilerow-1][tilecol]==-1)
        {
            board[tilerow-1][tilecol] = board[tilerow][tilecol];
            board[tilerow][tilecol] = -1;
        }
        else if(board[tilerow+1][tilecol]==-1)
        {
            board[tilerow+1][tilecol]= board[tilerow][tilecol];
            board[tilerow][tilecol] = -1;
        }
        else if(board[tilerow][tilecol-1]==-1)
        {
            board[tilerow][tilecol-1]=board[tilerow][tilecol];
            board[tilerow][tilecol] = -1;
        }
    }
    else if(tilecol == NUM_COLS)
    {
                if(board[tilerow-1][tilecol]==-1)
        {
            board[tilerow-1][tilecol] = board[tilerow][tilecol];
            board[tilerow][tilecol] = -1;
        }
        else if(board[tilerow+1][tilecol]==-1)
        {
            board[tilerow+1][tilecol]= board[tilerow][tilecol];
            board[tilerow][tilecol] = -1;
        }
        else if(board[tilerow][tilecol+1]==-1)
        {
            board[tilerow][tilecol+1]= board[tilerow][tilecol];
            board[tilerow][tilecol] = -1;
        }
    }
}",0
clee482,1696176895,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int i,j;
    int tilerow, tilecol;
    for(i=0; i<NUM_ROWS; i++)
    {
        for(j=0; j<NUM_COLS; j++)
        {
            if(board[i][j]== tile)
            {
             tilerow = i;
             tilecol = j;
             break;
            }
        }
    }
    
    if (tilerow > 0 && tilecol > 0 && tilerow < NUM_ROWS-1 && tilecol <NUM_COLS-1)
    {
        if(board[tilerow-1][tilecol]==-1)
        {
            board[tilerow-1][tilecol] = board[tilerow][tilecol];
            board[tilerow][tilecol] = -1;
        }
        else if(board[tilerow+1][tilecol]==-1)
        {
            board[tilerow+1][tilecol]= board[tilerow][tilecol];
            board[tilerow][tilecol] = -1;
        }
        else if(board[tilerow][tilecol-1]==-1)
        {
            board[tilerow][tilecol-1]=board[tilerow][tilecol];
            board[tilerow][tilecol] = -1;
        }
        else if(board[tilerow][tilecol+1]==-1)
        {
            board[tilerow][tilecol+1]= board[tilerow][tilecol];
            board[tilerow][tilecol] = -1;
        }

    }

    else if(tilerow == 0)
    {
        if(board[tilerow-1][tilecol]==-1)
        {
            board[tilerow-1][tilecol] = board[tilerow][tilecol];
            board[tilerow][tilecol] = -1;
            
        }
        else if(board[tilerow+1][tilecol]==-1)
        {
            board[tilerow+1][tilecol]= board[tilerow][tilecol];
            board[tilerow][tilecol] = -1;
            
        }
        else if(board[tilerow][tilecol-1]==-1)
        {
            board[tilerow][tilecol-1]=board[tilerow][tilecol];
            board[tilerow][tilecol] = -1;
            
        }
   
    }
    else if(tilerow == NUM_ROWS-1)
    {
        if(board[tilerow-1][tilecol]==-1)
        {
            board[tilerow-1][tilecol] = board[tilerow][tilecol];
            board[tilerow][tilecol] = -1;
        }
        else if(board[tilerow+1][tilecol]==-1)
        {
            board[tilerow+1][tilecol]= board[tilerow][tilecol];
            board[tilerow][tilecol] = -1;
        }
        else if(board[tilerow][tilecol+1]==-1)
        {
            board[tilerow][tilecol+1]= board[tilerow][tilecol];
            board[tilerow][tilecol] = -1;
        }
    }
    else if(tilecol == 0)
    {
        if(board[tilerow+1][tilecol]==-1)
        {
            board[tilerow+1][tilecol]= board[tilerow][tilecol];
            board[tilerow][tilecol] = -1;
        }
        else if(board[tilerow-1][tilecol]==-1)
        {
            board[tilerow-1][tilecol]=board[tilerow][tilecol];
            board[tilerow][tilecol] = -1;
        }
        else if(board[tilerow][tilecol+1]==-1)
        {
            board[tilerow][tilecol+1]= board[tilerow][tilecol];
            board[tilerow][tilecol] = -1;
        }
    }
    else if(tilecol == NUM_COLS-1)
    {
        if(board[tilerow-1][tilecol]==-1)
        {
            board[tilerow-1][tilecol] = board[tilerow][tilecol];
            board[tilerow][tilecol] = -1;
        }
        else if(board[tilerow][tilecol-1]==-1)
        {
            board[tilerow][tilecol-1]=board[tilerow][tilecol];
            board[tilerow][tilecol] = -1;
        }
        else if(board[tilerow+1][tilecol]==-1)
        {
            board[tilerow+1][tilecol]= board[tilerow][tilecol];
            board[tilerow][tilecol] = -1;
        }
    }
}",1
cleu746,1695958445,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyRow, emptyCol, tileRow, tileCol, temp, *x, *y;
    
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);
 
    if (((emptyRow == tileRow && (emptyCol - tileCol == 1 || tileCol - emptyCol == 1)) ||
         (emptyCol == tileCol && (emptyRow - tileRow == 1 || tileRow - emptyRow == 1)))) {    
        
        x = &board[tileRow][tileCol];
        y = &board[emptyRow][emptyCol];
        temp = *x;
        *x = *y;
        *y = temp;
    }
}",1
clob269,1695788644,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {

	int row, col;

	for (int i = 0; i <= 4; i++) {
		for (int j = 0; j <= 4; j++) {
			if (tile == board[i][j]) {
				row = i;
				col = j;
				break;
			}
		}
	}


	bool doit = false;
	int situation;

	if (board[row + 1][col] == -1) {

		doit = true;
		situation = 1;

	}
	else if (board[row - 1][col] == -1) {
		doit = true;
		situation = 2;

	}
	else if (board[row][col + 1] == -1) {
		doit = true;
		situation = 3;

	}
	else if (board[row][col - 1] == -1) {
		doit = true;
		situation = 4;

	}


	if (doit) {
		switch (situation) {
		case (1):
			board[row + 1][col] = board[row][col];
			board[row][col] = -1;
			break;
		case (2):
			board[row - 1][col] = board[row][col];
			board[row][col] = -1;
			break;
		case (3):
			board[row][col + 1] = board[row][col];
			board[row][col] = -1;
			break;
		case (4):
			board[row][col - 1] = board[row][col];
			board[row][col] = -1;
			break;
		}
	}






}",1
cmac377,1696054477,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col, rowempty, colempty, rowdiff, coldiff;
    
    FindTile(board, tile, &row, &col);
    
    FindTile(board, -1, &rowempty, &colempty);
    
    coldiff = col - colempty;
    rowdiff = row - rowempty;
    if (rowdiff >= -1 && rowdiff <= 1 && coldiff >= -1 && coldiff <= 1){
    board[row][col] = -1;
    board[rowempty][colempty] = tile;
    }
    
    
}",1
cmad989,1695968843,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowTile, colTile;
	FindTile(board, tile, &rowTile, &colTile);
	int rowEmpty, colEmpty;
	FindTile(board, -1, &rowEmpty, &colEmpty);

    if ((rowTile == rowEmpty && (colTile == colEmpty + 1 || colTile == colEmpty - 1)) ||
        (colTile == colEmpty && (rowTile == rowEmpty + 1 || rowTile == rowEmpty - 1))) {
        int temp = board[rowTile][colTile];
        board[rowTile][colTile] = board[rowEmpty][colEmpty];
        board[rowEmpty][colEmpty] = temp;
		}
}",1
cmas527,1696054290,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
  
    int i, j;
for (i = 0; i < NUM_ROWS; i++) {
for (j = 0; j < NUM_COLS; j++) { 
if (board[i][j]==tile){
if (board[i+1][j] == -1&&i+1<NUM_ROWS) {
    board[i+1][j] = tile;
    board[i][j] = -1;
    return;
  
}
else if (board[i-1][j] == -1&&i-1 >-1) {
    board[i-1][j] = tile;
    board[i][j] = -1;
    return;
   
}
else if (board[i][j+1] == -1&&j+1<NUM_COLS) {
    board[i][j+1] = tile;
    board[i][j] = -1;
    return;
    
}
else if (board[i][j-1] == -1&&j-1>-1) {
    board[i][j-1] = tile;
    board[i][j] = -1;
    return;
    
    
}
}

}
}
}",1
cmcm317,1696216265,1,"/* ENGGEN131 (2022) - Lab 9 (25th - 30th September, 2023)
   EXERCISE SEVEN and EIGHT - Sliding Tile Puzzle
*/
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

/* The dimensions of the puzzle */
#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, rowT, colT;

	FindTile(board, -1, &row, &col);
    
	FindTile(board, tile, &rowT, &colT);

	if (((rowT == (row + 1)||(row - 1))&&(colT == col))||((colT == (col + 1)||(col - 1))&&(rowT == row))) {
		board[row][col] = tile;
		board[rowT][colT] = -1;
	}
}",0
cmcm317,1696217291,2,"/* ENGGEN131 (2022) - Lab 9 (25th - 30th September, 2023)
   EXERCISE SEVEN and EIGHT - Sliding Tile Puzzle
*/
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

/* The dimensions of the puzzle */
#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, rowT, colT;

	FindTile(board, -1, &row, &col);
    
	FindTile(board, tile, &rowT, &colT);

	if ((rowT == row + 1) || (rowT == row - 1)) {
		if (col == colT) {
			board[row][col] = tile;
			board[rowT][colT] = -1;
		}	
	}
	else if ((colT == col + 1) || (colT == col - 1)) {
		if (row == rowT){
			board[row][col] = tile;
			board[rowT][colT] = -1;
		}
	}
}",1
cmia215,1695689853,1,"#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowempty, colempty, row, col;
	FindTile(board, -1, &rowempty, &colempty);
	FindTile(board, tile, &row, &col);
	if ((rowempty == row && (colempty == col + 1 || colempty == col - 1)) 
		|| ((colempty == col) && (rowempty == row + 1 || rowempty == row - 1))) {
		board[rowempty][colempty] = tile;
		board[row][col] = -1;
	}

}",1
cmot464,1695616176,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowPos, colPos;
	int rowPosE, colPosE; // for empty tile
	int distRow, distCol;

	FindTile(board, tile, &rowPos, &colPos);
	FindTile(board, -1, &rowPosE, &colPosE);

	distCol = colPos - colPosE;
	distRow = rowPos - rowPosE;


	if((distRow == 1 || distRow == 0 || distRow == -1) && (distCol == 1 || distCol == 0 || distCol == -1) && ((distCol*distCol) != (distRow*distRow))){
		board[rowPos][colPos] = -1;
		board[rowPosE][colPosE] = tile;
	}
}",1
cnai408,1696232262,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow;
    int emptyCol;
    
    FindTile(board, -1, &emptyRow, &emptyCol);
    printf(""Found at %d, %d \n"", emptyRow, emptyCol);
    
    int newRow;
    int newCol;
    
    FindTile(board, tile, &newRow, &newCol);
    printf(""Found at %d, %d \n"", newRow, newCol);
            
            // Moving Up
            if (board[emptyRow][emptyCol] == board[newRow - 1][newCol]) {
                
                board[emptyRow][emptyCol] = board[newRow][newCol];
                board[newRow][newCol] = -1;
            }
            
            // Moving down
            if (board[emptyRow][emptyCol] == board[newRow + 1][newCol]) {
                
                board[emptyRow][emptyCol] = board[newRow][newCol];
                board[newRow][newCol] = -1;
            }
            
            // Check if it is moving past a first or final column 
            if (emptyCol - newCol < 4) {
                 // Moving left
                if (board[emptyRow][emptyCol] == board[newRow][newCol - 1]) {
                    
                    board[emptyRow][emptyCol] = board[newRow][newCol];
                    board[newRow][newCol] = -1;
                }
                
                 // Moving right
                if (board[emptyRow][emptyCol] == board[newRow][newCol + 1]) {
                    
                    board[emptyRow][emptyCol] = board[newRow][newCol];
                    board[newRow][newCol] = -1;
                }
            }
}",0
cnai408,1696232286,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow;
    int emptyCol;
    
    FindTile(board, -1, &emptyRow, &emptyCol);
    
    int newRow;
    int newCol;
    
    FindTile(board, tile, &newRow, &newCol);
            
            // Moving Up
            if (board[emptyRow][emptyCol] == board[newRow - 1][newCol]) {
                
                board[emptyRow][emptyCol] = board[newRow][newCol];
                board[newRow][newCol] = -1;
            }
            
            // Moving down
            if (board[emptyRow][emptyCol] == board[newRow + 1][newCol]) {
                
                board[emptyRow][emptyCol] = board[newRow][newCol];
                board[newRow][newCol] = -1;
            }
            
            // Check if it is moving past a first or final column 
            if (emptyCol - newCol < 4) {
                 // Moving left
                if (board[emptyRow][emptyCol] == board[newRow][newCol - 1]) {
                    
                    board[emptyRow][emptyCol] = board[newRow][newCol];
                    board[newRow][newCol] = -1;
                }
                
                 // Moving right
                if (board[emptyRow][emptyCol] == board[newRow][newCol + 1]) {
                    
                    board[emptyRow][emptyCol] = board[newRow][newCol];
                    board[newRow][newCol] = -1;
                }
            }
}",0
cnai408,1696232948,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow;
    int emptyCol;
    
    FindTile(board, -1, &emptyRow, &emptyCol);
    
    int newRow;
    int newCol;
    
    FindTile(board, tile, &newRow, &newCol);
            
            // Moving Up
            if (board[emptyRow][emptyCol] == board[newRow - 1][newCol]) {
                
                board[emptyRow][emptyCol] = board[newRow][newCol];
                board[newRow][newCol] = -1;
            }
            
            // Moving down
            if (board[emptyRow][emptyCol] == board[newRow + 1][newCol]) {
                
                board[emptyRow][emptyCol] = board[newRow][newCol];
                board[newRow][newCol] = -1;
            }
            
            // Check if it is moving past a first or final column 
            if (emptyCol - newCol < 3) {
                 // Moving left
                if (board[emptyRow][emptyCol] == board[newRow][newCol - 1]) {
                    
                    board[emptyRow][emptyCol] = board[newRow][newCol];
                    board[newRow][newCol] = -1;
                }
                
                 // Moving right
                if (board[emptyRow][emptyCol] == board[newRow][newCol + 1]) {
                    
                    board[emptyRow][emptyCol] = board[newRow][newCol];
                    board[newRow][newCol] = -1;
                }
            }
}",1
cnie825,1696168344,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRow, tileCol;
    int emptyRow, emptyCol;

    // Find the specified tile 
    FindTile(board, tile, &tileRow, &tileCol);

    // Find the empty space
    FindTile(board, -1, &emptyRow, &emptyCol);

    // Check if adjacent to empty space. if so, swap the tiles
    if (((tileRow - emptyRow == 1 || tileRow - emptyRow == -1) && tileCol == emptyCol) || 
        ((tileCol - emptyCol == 1 || tileCol - emptyCol == -1) && tileRow == emptyRow)) {
        // Swap the tiles
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}",1
coli772,1695611461,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int empty_row, empty_col, row, col;
    FindTile(board, -1, &empty_row, &empty_col);
    FindTile(board, tile, &row, &col);
    if ((row - empty_row == 0 && col - empty_col == -1) ||
        (row - empty_row == 0 && col - empty_col == 1) ||
        ((row - empty_row == -1 && col - empty_col == 0)) ||
        (row - empty_row == 1 && col - empty_col == 0)) {
            board[empty_row][empty_col] = board[row][col];
            board[row][col] = -1;
    }
    
}",1
couy656,1695704118,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;
    FindTile(board, tile, &row, &col);

	if (row > 0 && board[row-1][col]==-1){
		board[row-1][col] = tile;
		board[row][col] = -1;
	} else if (row < NUM_ROWS-1 && board[row+1][col]==-1){
		board[row+1][col] = tile;
		board[row][col] = -1;
	} else if (col > 0 && board[row][col-1]==-1){
		board[row][col-1] = tile;
		board[row][col] = -1;
	} else if (col < NUM_COLS-1 && board[row][col+1]==-1){
		board[row][col+1] = tile;
		board[row][col] = -1;
	}	
}",1
csan114,1695786595,1,"#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{ 
	int row;
	int col;

	for (int i = 0; i < NUM_ROWS; i++) {
		for (int j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == -1) {
				row = i;
				col = j;
			}
		}
	}


	
	for (int i = 0; i < NUM_ROWS; i++) {
		for (int j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == tile && board[i][j] == board[row][col + 1]) {
				board[i][j] = -1;
				board[row][col] = tile;
			}
			else if (board[i][j] == tile && board[i][j] == board[row][col - 1]) {
				board[i][j] = -1;
				board[row][col] = tile;
			}
			else if (board[i][j] == tile && board[i][j] == board[row + 1][col]) {
				board[i][j] = -1;
				board[row][col] = tile;
			}
			else if (board[i][j] == tile && board[i][j] == board[row - 1][col]) {
				board[i][j] = -1;
				board[row][col] = tile;
			}
		}
	}


}",0
csan114,1695786671,2,"#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{ 
	int row = 0;
	int col = 0;

	for (int i = 0; i < NUM_ROWS; i++) {
		for (int j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == -1) {
				row = i;
				col = j;
			}
		}
	}


	
	for (int i = 0; i < NUM_ROWS; i++) {
		for (int j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == tile && board[i][j] == board[row][col + 1]) {
				board[i][j] = -1;
				board[row][col] = tile;
			}
			else if (board[i][j] == tile && board[i][j] == board[row][col - 1]) {
				board[i][j] = -1;
				board[row][col] = tile;
			}
			else if (board[i][j] == tile && board[i][j] == board[row + 1][col]) {
				board[i][j] = -1;
				board[row][col] = tile;
			}
			else if (board[i][j] == tile && board[i][j] == board[row - 1][col]) {
				board[i][j] = -1;
				board[row][col] = tile;
			}
		}
	}


}",0
csan114,1695803955,3,"#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{ 
	int row = 0;
	int col = 0;

	for (int i = 0; i < NUM_ROWS; i++) {
		for (int j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == -1) {
				row = i;
				col = j;
			}
		}
	}


	
	for (int i = 0; i < NUM_ROWS; i++) {
		for (int j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == tile && i == row && j == col + 1) {
				board[i][j] = -1;
				board[row][col] = tile;
			}
			else if (board[i][j] == tile && i == row && j == col - 1) {
				board[i][j] = -1;
				board[row][col] = tile;
			}
			else if (board[i][j] == tile && i == row + 1 && j == col) {
				board[i][j] = -1;
				board[row][col] = tile;
			}
			else if (board[i][j] == tile && i == row - 1 && j == col) {
				board[i][j] = -1;
				board[row][col] = tile;
			}
		}
	}


}",1
cset571,1695630727,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j, tilerow, tilecol, row, col;
	FindTile(board, -1, &row, &col);

	for (i = 0; i < 4; i++) {
		for (j = 0; j < 4; j++) {
			if (board[i][j] == tile) {
				tilerow = i;
				tilecol = j;
			}
		}
	}
	if ((row == tilerow && col == tilecol - 1) || (row == tilerow && col == tilecol + 1) || (col == tilecol && row == tilerow - 1) || (col == tilecol && row == tilerow + 1)) {
		int temp = board[row][col];
		board[row][col] = board[tilerow][tilecol];
		board[tilerow][tilecol] = temp;
	}
}",1
csin574,1695929760,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
int r_;
int c_;
int rt;
int ct;
int i;
int j;
for (i = 0; i < NUM_ROWS; i++) {
	for (j = 0; j < NUM_COLS; j++) {
		if (board[i][j] == tile) {
			rt = i;
			ct = j;
		}
		if (board[i][j] == -1) {
			r_ = i;
			c_ = j;
		}
	}
}
if ( ((rt + 1 == r_) && (ct == c_)) || ((rt - 1 == r_) && (ct == c_)) || ((rt == r_) && (ct + 1 == c_)) || ((rt == r_) && (ct - 1 == c_)) ) {
	board[rt][ct] = -1;
	board[r_][c_] = tile;
}
}",1
cste189,1695780283,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowTile, rowEmp, colTile, colEmp, hold;
	FindTile(board, tile, &rowTile, &colTile);
	FindTile(board, -1, &rowEmp, &colEmp);
	
	if ((rowTile + 1 == rowEmp || rowTile - 1 == rowEmp)&&(colTile == colEmp) || (colTile + 1 == colEmp || colTile - 1 == colEmp)&&(rowTile == rowEmp)) {
		
		hold = board[rowEmp][colEmp];
		board[rowEmp][colEmp] = board[rowTile][colTile];
		board[rowTile][colTile] = hold;
	}
	
}",0
cste189,1695780326,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowTile, rowEmp, colTile, colEmp, hold;
	FindTile(board, tile, &rowTile, &colTile);
	FindTile(board, -1, &rowEmp, &colEmp);
	
	if (((rowTile + 1 == rowEmp || rowTile - 1 == rowEmp)&&(colTile == colEmp)) || ((colTile + 1 == colEmp || colTile - 1 == colEmp)&&(rowTile == rowEmp))) {
		
		hold = board[rowEmp][colEmp];
		board[rowEmp][colEmp] = board[rowTile][colTile];
		board[rowTile][colTile] = hold;
	}
	
}",1
ctof106,1696237476,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyRow, emptyCol, row, col;
    
    FindTile(board, -1, emptyRow, emptyCol); 

    FindTile(board, tile, row, col); 

    if ((row == emptyRow && (col == emptyCol - 1 || col == emptyCol + 1)) ||
        (col == emptyCol && (row == emptyRow - 1 || row == emptyRow + 1))) 
        {
        int placeHolder = board[emptyRow][emptyCol];
        board[emptyRow][emptyCol] = board[row][col];
        board[row][col] = placeHolder;
    } 

}",0
ctof106,1696237647,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyRow, emptyCol, row, col;
    
    FindTile(board, -1, emptyRow, emptyCol); 

    FindTile(board, tile, row, col); 

    if ((row == emptyRow && (col == emptyCol - 1 || col == emptyCol + 1)) ||
        (col == emptyCol && (row == emptyRow - 1 || row == emptyRow + 1))) 
        {
        board[emptyRow][emptyCol] = tile;
        board[row][col] = -1;
    } 

}",0
ctof106,1696237720,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyRow, emptyCol, &row, &col;
    
    FindTile(board, -1, &emptyRow, &emptyCol); 

    FindTile(board, tile, row, col); 

    if ((row == emptyRow && (col == emptyCol - 1 || col == emptyCol + 1)) ||
        (col == emptyCol && (row == emptyRow - 1 || row == emptyRow + 1))) 
        {
        board[emptyRow][emptyCol] = tile;
        board[row][col] = -1;
    } 

}",0
ctof106,1696237829,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyRow, emptyCol, row, col;
    
    FindTile(board, -1, &emptyRow, &emptyCol); 

    FindTile(board, tile, &row, &col); 

    if ((row == emptyRow && (col == emptyCol - 1 || col == emptyCol + 1)) ||
        (col == emptyCol && (row == emptyRow - 1 || row == emptyRow + 1))) 
        {
        board[emptyRow][emptyCol] = tile;
        board[row][col] = -1;
    } 

}",1
ctub889,1696228275,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol;
    FindTile(board, -1, &emptyRow, &emptyCol);

    int tileRow, tileCol;
    FindTile(board, tile, &tileRow, &tileCol);

    if ((tileRow == emptyRow && abs(tileCol - emptyCol) == 1) ||
        (tileCol == emptyCol && abs(tileRow - emptyRow) == 1)) {
       
        int temp = board[emptyRow][emptyCol];
        board[emptyRow][emptyCol] = board[tileRow][tileCol];
        board[tileRow][tileCol] = temp;
    }
}",1
cwei506,1696052560,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, row1, col1;
	FindTile(board, tile, &row, &col);
	FindTile(board, -1, &row1, &col1);

	if (row - 1 == row1) {
		if (col == col1) {
			board[row1][col1] = tile;
			board[row][col] = -1;
		}
	}
	if (row + 1 == row1) {
		if (col == col1) {
			board[row1][col1] = tile;
			board[row][col] = -1;
		}
	}
	if (col + 1 == col1) {
		if (row == row1) {
			board[row1][col1] = tile;
			board[row][col] = -1;
		}
	}
	if (col - 1 == col1) {
		if (row == row1) {
			board[row1][col1] = tile;
			board[row][col] = -1;
		}
	}

}",1
cwu200,1696224376,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
  int i, j, emptyrow, emptycol, tilerow, tilecol;
    
  FindTile(board, tile, &tilerow, &tilecol);
  FindTile(board, -1, &emptyrow, &emptycol);
  
  if ((abs(tilerow - emptyrow) == 1 && tilecol == emptycol) || (abs(tilecol - emptycol) == 1 && tilerow == emptyrow)) {
    board[emptyrow][emptycol] = tile;
    board[tilerow][tilecol] = -1;
  }
}",0
cwu200,1696224393,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
  int emptyrow, emptycol, tilerow, tilecol;
    
  FindTile(board, tile, &tilerow, &tilecol);
  FindTile(board, -1, &emptyrow, &emptycol);
  
  if ((abs(tilerow - emptyrow) == 1 && tilecol == emptycol) || (abs(tilecol - emptycol) == 1 && tilerow == emptyrow)) {
    board[emptyrow][emptycol] = tile;
    board[tilerow][tilecol] = -1;
  }
}",1
cyan312,1695958447,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tileRow, tileCol, emptyRow, emptyCol;
	FindTile(board, tile, &tileRow, &tileCol);
	FindTile(board, -1, &emptyRow, &emptyCol);

	if (((tileCol == emptyCol - 1 || tileCol == emptyCol + 1) && tileRow == emptyRow) || ((tileRow == emptyRow - 1 || tileRow == emptyRow + 1) && tileCol == emptyCol)) {
		board[emptyRow][emptyCol] = tile;
		board[tileRow][tileCol] = -1;
	}
	else {
		printf(""The desired tile cannot be moved.\n"");
	}
}",0
cyan312,1695958572,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tileRow, tileCol, emptyRow, emptyCol;
	FindTile(board, tile, &tileRow, &tileCol);
	FindTile(board, -1, &emptyRow, &emptyCol);

	if (((tileCol == emptyCol - 1 || tileCol == emptyCol + 1) && tileRow == emptyRow) || ((tileRow == emptyRow - 1 || tileRow == emptyRow + 1) && tileCol == emptyCol)) {
		board[emptyRow][emptyCol] = tile;
		board[tileRow][tileCol] = -1;
	}
}",1
cyiu210,1695939981,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    
    int i;
    int j;
    int Row;
    int Col;
    
    for (i = 0; i < NUM_ROWS; i++)  {
        for (j = 0; j < NUM_COLS; j++)  {
            if (board[i][j] == tile)  {
                Row = i;
                Col = j;
            }
        }
    }
    
    if (board[Row+1][Col] == -1)  {
                board[Row][Col] = -1;
                board[Row+1][Col] = tile;
    }
    else if (board[Row-1][Col] == -1)  {
                board[Row][Col] = -1;
                board[Row-1][Col] = tile;
    }            
    else if (board[Row][Col+1] == -1) {
                
                board[Row][Col] = -1;
                board[Row][Col+1] = tile;
                if (Col == 3) {
                board[Row][Col] = tile;
                board[Row][Col+1] = -1;    
                }
    }            
    else if (board[Row][Col-1] == -1) {
                board[Row][Col] = -1;
                board[Row][Col-1] = tile;
                if (Col == 0 ) {
                board[Row][Col] = tile;
                board[Row][Col-1] = -1;    
                }
    }

} ",1
dbar153,1695786965,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int R;
	int C;
	FindTile(board, tile, &R, &C);
	if (board[R + 1][C] == -1 && R+ 1 < NUM_ROWS){
		board[R+1][C] = tile;
		board[R][C] = -1;
	}
	if (board[R - 1][C] == -1 && R>0) {
		board[R-1][C] = tile;
		board[R][C] = -1;
	}
	if (board[R][C+1] == -1 && C + 1 < NUM_COLS) {
		board[R][C+1] = tile;
		board[R][C] = -1;
	}
	if (board[R][C - 1] == -1 && C>0) {
		board[R][C - 1] = tile;
		board[R][C] = -1;
	}
}",1
dcha468,1696219952,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) { 

    int emptyRow, emptyCol, tileRow, tileCol;

    // Find the positions of the specified tile and the empty square
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);
    
    
    if (emptyRow == tileRow){ 
        if (emptyCol == tileCol - 1 || emptyCol == tileCol + 1) { 
            board[emptyRow][emptyCol] = tile;
            board[tileRow][tileCol] = -1;
        } 
    } 
 
    if (emptyCol == tileCol){ 
        if (emptyRow == tileRow - 1 || emptyRow == tileRow + 1) { 
            board[emptyRow][emptyCol] = tile;
            board[tileRow][tileCol] = -1;
        } 
    } 
}",1
dche306,1696073509,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol;
    FindTile(board, -1, &emptyRow, &emptyCol);  // Find the position of the empty square (-1)
    
    int tileRow, tileCol;
    FindTile(board, tile, &tileRow, &tileCol);  // Find the position of the specified tile
    
    // Check if the specified tile is adjacent to the empty square (horizontally or vertically)
    if ((abs(emptyRow - tileRow) == 1 && emptyCol == tileCol) || 
        (abs(emptyCol - tileCol) == 1 && emptyRow == tileRow)) {
        // Swap the tile with the empty square
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    } else {
        // The tile is not adjacent to the empty square, so it cannot be moved.
        // You can handle this case as needed (e.g., display an error message).
    }
}",1
deri361,1695631442,1,"#include <stdio.h>
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, tileRow,tileCol, i ,j;
	FindTile(board, -1, &row, &col);
	FindTile(board, tile, &tileRow, &tileCol);
	if ((abs(row - tileRow) == 1) || (abs(col-tileCol) == 1)) {;
		board[row][col] = tile;
		board[tileRow][tileCol] = -1;
	}

}",0
deri361,1695631525,2,"#include <stdio.h>
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, tileRow, tileCol;
	FindTile(board, -1, &row, &col);
	FindTile(board, tile, &tileRow, &tileCol);
	if ((abs(row - tileRow) == 1) || (abs(col-tileCol) == 1)) {;
		board[row][col] = tile;
		board[tileRow][tileCol] = -1;
	}

}",0
deri361,1695633625,3,"#include <stdio.h>
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, tileRow, tileCol;
	FindTile(board, -1, &row, &col);
	FindTile(board, tile, &tileRow, &tileCol);
	if ((abs(row - tileRow) == 1) && (abs(col - tileCol) == 0) || (abs(row - tileRow) == 0) && (abs(col - tileCol) == 1)) {
		board[row][col] = tile;
		board[tileRow][tileCol] = -1;
	}
}",0
deri361,1695635766,4,"#include <stdio.h>
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, tileRow, tileCol;
	FindTile(board, -1, &row, &col);
	FindTile(board, tile, &tileRow, &tileCol);
	if (((abs(row - tileRow) == 1) && (abs(col - tileCol) == 0)) || ((abs(row - tileRow) == 0) && (abs(col - tileCol) == 1))) {
		board[row][col] = tile;
		board[tileRow][tileCol] = -1;
	}
}
",1
dfor626,1695782561,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col, i, j;
    FindTile(board[NUM_ROWS][NUM_COLS], tile, &row, &col);
    int storage;
    if ((board[row + 1][col] == -1)|(board[row - 1][col] == -1)|(board[row][col + 1] == -1)|(board[row][col - 1] == -1)) {
        FindTile(board[NUM_ROWS][NUM_COLS], -1, &i, &j);
        board[i][j] = board[row][col];
        board[row][col] = -1;
    }
}",0
dfor626,1695782631,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col, i, j;
    FindTile(board, tile, &row, &col);
    int storage;
    if ((board[row + 1][col] == -1)|(board[row - 1][col] == -1)|(board[row][col + 1] == -1)|(board[row][col - 1] == -1)) {
        FindTile(board, -1, &i, &j);
        board[i][j] = board[row][col];
        board[row][col] = -1;
    }
}",0
dfor626,1695782679,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col, i, j;
    FindTile(board, tile, &row, &col);
    if ((board[row + 1][col] == -1)|(board[row - 1][col] == -1)|(board[row][col + 1] == -1)|(board[row][col - 1] == -1)) {
        FindTile(board, -1, &i, &j);
        board[i][j] = board[row][col];
        board[row][col] = -1;
    }
}",0
dfor626,1695793139,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col, i, j;
    FindTile(board, tile, &row, &col);
    if ((board[row + 1][col] == -1)|(board[row - 1][col] == -1)|(board[row][col + 1] == -1)|(board[row][col - 1] == -1)) {
        if (col == 0) {
            if (board[row][col - 1] != -1) {
            FindTile(board, -1, &i, &j);
            board[i][j] = board[row][col];
            board[row][col] = -1;
            }
        }
    }
}",0
dfor626,1695867860,5,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col, i, j;
    FindTile(board, tile, &i, &j);
    FindTile(board, -1, &row, &col);
    
    if ((i == row && (j == col + 1 || j == col - 1)) || (j == col && (i == row + 1|| i == row - 1))) {
        FindTile(board, -1, &row, &col);
        board[row][col] = board[i][j];
        board[i][j] = -1;
    }
}",1
dgal735,1695936460,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int rowPos, colPos;
    
    // Find the position of the specified tile
    FindTile(board, tile, &rowPos, &colPos);
    
    // Check if the tile is adjacent to the empty square (represented by -1)
    if (rowPos > 0 && board[rowPos - 1][colPos] == -1) {
        // Swap the tile and the empty square
        board[rowPos - 1][colPos] = tile;
        board[rowPos][colPos] = -1;
    } else if (rowPos < NUM_ROWS - 1 && board[rowPos + 1][colPos] == -1) {
        board[rowPos + 1][colPos] = tile;
        board[rowPos][colPos] = -1;
    } else if (colPos > 0 && board[rowPos][colPos - 1] == -1) {
        board[rowPos][colPos - 1] = tile;
        board[rowPos][colPos] = -1;
    } else if (colPos < NUM_COLS - 1 && board[rowPos][colPos + 1] == -1) {
        board[rowPos][colPos + 1] = tile;
        board[rowPos][colPos] = -1;
    }
    // If the tile is not adjacent to the empty square, do nothing
}
",1
dgal735,1695936981,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int rowPos, colPos;
    
    // Find the position of the specified tile using the FindTile function
    FindTile(board, tile, &rowPos, &colPos);
    
    // Check if the tile is adjacent to the empty square (represented by -1)
    if (rowPos > 0 && board[rowPos - 1][colPos] == -1) {
// Keep Swaping the tile and the empty square ONLY if tile is adjacent to empty square
        board[rowPos - 1][colPos] = tile;
        board[rowPos][colPos] = -1;
    } else if (rowPos < NUM_ROWS - 1 && board[rowPos + 1][colPos] == -1) {
        board[rowPos + 1][colPos] = tile;
        board[rowPos][colPos] = -1;
    } else if (colPos > 0 && board[rowPos][colPos - 1] == -1) {
        board[rowPos][colPos - 1] = tile;
        board[rowPos][colPos] = -1;
    } else if (colPos < NUM_COLS - 1 && board[rowPos][colPos + 1] == -1) {
        board[rowPos][colPos + 1] = tile;
        board[rowPos][colPos] = -1;
    }
    // If the tile is NOT adjacent to the empty square, do nothing and prompt the user again for an input 
}
",1
dha524,1695773007,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int *row = 0, *col = 0;
	int *erow = 0, *ecol = 0;
	int i, j;

	FindTile(board, -1, erow, ecol);
	FindTile(board, tile, row, col);

	if (*erow = *row - 1) {
		if (*ecol = *col - 1) {
			i = *erow;
			*row = *erow;
			*erow = i;

			j = *ecol;
			*col = *ecol;
			*ecol = j;
		}
		else if (*ecol = *col + 1) {
			i = *erow;
			*row = *erow;
			*erow = i;

			j = *ecol;
			*col = *ecol;
			*ecol = j;
		}
	}
	else if (*erow = *row + 1) {
		if (*ecol = *col - 1) {
			i = *erow;
			*row = *erow;
			*erow = i;

			j = *ecol;
			*col = *ecol;
			*ecol = j;
		}
		else if (*ecol = *col + 1) {
			i = *erow;
			*row = *erow;
			*erow = i;

			j = *ecol;
			*col = *ecol;
			*ecol = j;
		}
	}
}",0
dha524,1695788464,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row = 0, col = 0;
	int erow = 0, ecol = 0;
	int i;

	FindTile(board, -1, &erow, &ecol);
	FindTile(board, tile, &row, &col);

	if (erow == row - 1) {
		if (ecol == col) {
			i = board[row][col];
			board[erow][ecol] = i;
			board[row][col] = -1;

		}
	}
	else if (erow == row + 1) {
		if (ecol == col) {
			i = board[row][col];
			board[erow][ecol] = i;
			board[row][col] = -1;

		}
	}

	else if (ecol == col - 1) {
		if (erow == row) {
			i = board[row][col];
			board[erow][ecol] = i;
			board[row][col] = -1;

		}
	}

	else if (ecol == col + 1) {
		if (erow == row) {
			i = board[row][col];
			board[erow][ecol] = i;
			board[row][col] = -1;

		}
	}
}",1
dhah941,1696223495,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int temp;
	int t_row, t_col;
	int o_row, o_col;
	FindTile(board, tile, &t_row, &t_col);
	FindTile(board, -1, &o_row, &o_col);

	if (t_row == o_row || t_col == o_col)
	{
		if ((t_row - o_row) == -1 || (t_row - o_row) == 1 || (t_col - o_col) == -1 || (t_col - o_col) == 1)
		{
			temp = board[t_row][t_col];
			board[t_row][t_col] = -1;
			board[o_row][o_col] = temp;
		}
	}
}",1
dhar714,1695712078,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{

	int pos1; //row of selected tile
	int pos2; //column of selected tile
	FindTile(board, tile, &pos1, &pos2);
	int pos3; //row of empty tile
	int pos4; //column of empty tile
	FindTile(board, -1, &pos3, &pos4);

	int deltaRow = pos1 - pos3;
	int deltaCol = pos2 - pos4;
	if (deltaCol < 0) {
		deltaCol = deltaCol * -1;
	}
	if (deltaRow < 0) {
		deltaRow = deltaRow * -1;
	}

	if (deltaRow <= 1 && deltaCol <= 1) {// if adjacent then switch
		board[pos1][pos2] = -1;
		board[pos3][pos4] = tile;
	}
}",1
dhen760,1695698425,1,"void MakeMove(int board[4][4], int tile) {

int row;
int col;

    for (int i=0; i<4; i++) {
        for (int j=0; j<4; j++) {
        if (board[i][j] == tile) {
        row = i;
        int col = j;
        }
        }
    }
    if (row == 0 && col == 0) {
    if (board[row+1][col] == -1) {
        board[row+1][col] = tile;
        board[row][col] = -1;
    }
    if (board[row][col+1] == -1) {
        board[row][col+1] = tile;
        board[row][col] = -1;
    }
    }
    
    if (row == 0 && col > 0) {
    if (board[row+1][col] == -1) {
        board[row+1][col] = tile;
        board[row][col] = -1;
    }
    if (board[row][col+1] == -1) {
    board[row][col+1] = tile;
    board[row][col] = -1;
    }
    if (board[row][col-1] == -1) {
    board[row][col-1] = tile;
    board[row][col] = -1;
    }
    }
    
    if (row > 0 && col == 0) {
    if (board[row+1][col] == -1) {
        board[row+1][col] = tile;
        board[row][col] = -1;
    }
    if (board[row][col+1] == -1) {
        board[row][col+1] = tile;
        board[row][col] = -1;
    }
    if (board[row-1][col] == -1) {
    board[row-1][col] = tile;
    board[row][col] = -1;
    }
    }
    
    if (row > 0 && col > 0) {
    if (board[row+1][col] == -1) {
        board[row+1][col] = tile;
        board[row][col] = -1;
    }
    if (board[row][col+1] == -1) {
    board[row][col+1] = tile;
    board[row][col] = -1;
    }
    if (board[row][col-1] == -1) {
    board[row][col-1] = tile;
    board[row][col] = -1;
    }
    if (board[row-1][col-1] == -1) {
    board[row-1][col-1] = tile;
    board[row][col] = -1;
    }
    }
}",0
dhen760,1695698477,2,"void MakeMove(int board[4][4], int tile) {

int row;
int col;

    for (int i=0; i<4; i++) {
        for (int j=0; j<4; j++) {
        if (board[i][j] == tile) {
        row = i;
        col = j;
        }
        }
    }
    if (row == 0 && col == 0) {
    if (board[row+1][col] == -1) {
        board[row+1][col] = tile;
        board[row][col] = -1;
    }
    if (board[row][col+1] == -1) {
        board[row][col+1] = tile;
        board[row][col] = -1;
    }
    }
    
    if (row == 0 && col > 0) {
    if (board[row+1][col] == -1) {
        board[row+1][col] = tile;
        board[row][col] = -1;
    }
    if (board[row][col+1] == -1) {
    board[row][col+1] = tile;
    board[row][col] = -1;
    }
    if (board[row][col-1] == -1) {
    board[row][col-1] = tile;
    board[row][col] = -1;
    }
    }
    
    if (row > 0 && col == 0) {
    if (board[row+1][col] == -1) {
        board[row+1][col] = tile;
        board[row][col] = -1;
    }
    if (board[row][col+1] == -1) {
        board[row][col+1] = tile;
        board[row][col] = -1;
    }
    if (board[row-1][col] == -1) {
    board[row-1][col] = tile;
    board[row][col] = -1;
    }
    }
    
    if (row > 0 && col > 0) {
    if (board[row+1][col] == -1) {
        board[row+1][col] = tile;
        board[row][col] = -1;
    }
    if (board[row][col+1] == -1) {
    board[row][col+1] = tile;
    board[row][col] = -1;
    }
    if (board[row][col-1] == -1) {
    board[row][col-1] = tile;
    board[row][col] = -1;
    }
    if (board[row-1][col-1] == -1) {
    board[row-1][col-1] = tile;
    board[row][col] = -1;
    }
    }
}",0
dhen760,1695698603,3,"void MakeMove(int board[4][4], int tile) {

int row;
int col;

    for (int i=0; i<4; i++) {
        for (int j=0; j<4; j++) {
        if (board[i][j] == tile) {
        row = i;
        col = j;
        }
        }
    }
    if (row == 0 && col == 0) {
    if (board[row+1][col] == -1) {
        board[row+1][col] = tile;
        board[row][col] = -1;
    }
    if (board[row][col+1] == -1) {
        board[row][col+1] = tile;
        board[row][col] = -1;
    }
    }
    
    if (row == 0 && col > 0) {
    if (board[row+1][col] == -1) {
        board[row+1][col] = tile;
        board[row][col] = -1;
    }
    if (board[row][col+1] == -1) {
    board[row][col+1] = tile;
    board[row][col] = -1;
    }
    if (board[row][col-1] == -1) {
    board[row][col-1] = tile;
    board[row][col] = -1;
    }
    }
    
    if (row > 0 && col == 0) {
    if (board[row+1][col] == -1) {
        board[row+1][col] = tile;
        board[row][col] = -1;
    }
    if (board[row][col+1] == -1) {
        board[row][col+1] = tile;
        board[row][col] = -1;
    }
    if (board[row-1][col] == -1) {
    board[row-1][col] = tile;
    board[row][col] = -1;
    }
    }
    
    if (row > 0 && col > 0) {
    if (board[row+1][col] == -1) {
        board[row+1][col] = tile;
        board[row][col] = -1;
    }
    if (board[row][col+1] == -1) {
    board[row][col+1] = tile;
    board[row][col] = -1;
    }
    if (board[row][col-1] == -1) {
    board[row][col-1] = tile;
    board[row][col] = -1;
    }
    if (board[row-1][col] == -1) {
    board[row-1][col] = tile;
    board[row][col] = -1;
    }
    }
}",1
dhul688,1695701718,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    
    int i, j;
    int XMove = 0;
    int YMove = 0;
    int IsValid;
    
    int row, col;
    FindTile(board, -1, &row, &col);
    
    if (board[row - 1][col] == tile){
        IsValid = 1;
        XMove = -1;
    }
    if (board[row + 1][col] == tile){
        IsValid = 1;
        XMove = 1;
    }
    if (board[row][col - 1] == tile){
        IsValid = 1;
        YMove = -1;
    }
    if (board[row][col + 1] == tile){
        IsValid = 1;
        YMove = 1;
    }
    
    if (IsValid == 1){
        board[row][col] = board[row + XMove][col + YMove];
        board[row + XMove][col + YMove] = -1;
    }
    
}",0
dhul688,1695701752,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    
    int XMove = 0;
    int YMove = 0;
    int IsValid;
    
    int row, col;
    FindTile(board, -1, &row, &col);
    
    if (board[row - 1][col] == tile){
        IsValid = 1;
        XMove = -1;
    }
    if (board[row + 1][col] == tile){
        IsValid = 1;
        XMove = 1;
    }
    if (board[row][col - 1] == tile){
        IsValid = 1;
        YMove = -1;
    }
    if (board[row][col + 1] == tile){
        IsValid = 1;
        YMove = 1;
    }
    
    if (IsValid == 1){
        board[row][col] = board[row + XMove][col + YMove];
        board[row + XMove][col + YMove] = -1;
    }
    
}",0
dhul688,1695702291,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    
    int XMove = 0;
    int YMove = 0;
    int IsValid;
    
    int row, col;
    FindTile(board, -1, &row, &col);
    
    if (board[row - 1][col] == tile){
        IsValid = 1;
        YMove = -1;
    }
    if (board[row + 1][col] == tile){
        IsValid = 1;
        YMove = 1;
    }
    if (board[row][col - 1] == tile){
        IsValid = 1;
        XMove = -1;
    }
    if (board[row][col + 1] == tile){
        IsValid = 1;
        XMove = 1;
    }
    
    if ((XMove == -1 & col == 0)|(XMove == 1 & col == NUM_ROWS)){
        IsValid = 0;
    }
    if ((YMove == -1 & row == 0)|(YMove == 1 & row == NUM_ROWS)){
        IsValid = 0;
    }
    
    if (IsValid == 1){
        board[row][col] = board[row + XMove][col + YMove];
        board[row + XMove][col + YMove] = -1;
    }
    
}",0
dhul688,1695702380,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    
    int XMove = 0;
    int YMove = 0;
    int IsValid;
    
    int row, col;
    FindTile(board, -1, &row, &col);
    
    if (board[row - 1][col] == tile){
        IsValid = 1;
        YMove = -1;
    }
    if (board[row + 1][col] == tile){
        IsValid = 1;
        YMove = 1;
    }
    if (board[row][col - 1] == tile){
        IsValid = 1;
        XMove = -1;
    }
    if (board[row][col + 1] == tile){
        IsValid = 1;
        XMove = 1;
    }
    
    if (((XMove == -1) & (col == 0))|((XMove == 1) & (col == NUM_ROWS))){
        IsValid = 0;
    }
    if (((YMove == -1) & (row == 0))|((YMove == 1) & (row == NUM_ROWS))){
        IsValid = 0;
    }
    
    if (IsValid == 1){
        board[row][col] = board[row + XMove][col + YMove];
        board[row + XMove][col + YMove] = -1;
    }
    
}",0
dhul688,1695704598,5,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    
    int Up_down = 0;
    int Left_right = 0;
    int XMove = 0;
    int YMove = 0;
    int IsValid;
    
    int row, col;
    FindTile(board, tile, &row, &col);
    
    if (row == 0){
        Up_down = 1;
    }
    if (row == NUM_ROWS){
        Up_down = 2;
    }
    if (col == 0){
        Left_right = 1;
    }
    if (col == NUM_COLS){
        Left_right = 2;
    }
    
    if ((board[row - 1][col] == tile) & (Up_down != 1)){
        IsValid = 1;
        YMove = -1;
    }
    if ((board[row + 1][col] == tile) & (Up_down != 2)){
        IsValid = 1;
        YMove = 1;
    }
    if ((board[row][col - 1] == tile) & (Left_right != 1)){
        IsValid = 1;
        XMove = -1;
    }
    if ((board[row][col + 1] == tile) & (Left_right != 2)){
        IsValid = 1;
        XMove = 1;
    }
    
    if (IsValid == 1){
        board[row][col] = board[row + YMove][col + XMove];
        board[row + YMove][col + XMove] = -1;
    }
    
}",0
dhul688,1695704829,6,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    
    int Up_down = 0;
    int Left_right = 0;
    int XMove = 0;
    int YMove = 0;
    int IsValid;
    
    int row, col;
    FindTile(board, tile, &row, &col);
    
    if (row == 0){
        Up_down = 1;
    }
    if (row == NUM_ROWS){
        Up_down = 2;
    }
    if (col == 0){
        Left_right = 1;
    }
    if (col == NUM_COLS){
        Left_right = 2;
    }
    
    if ((board[row - 1][col] == -1) & (Up_down != 1)){
        IsValid = 1;
        YMove = -1;
    }
    if ((board[row + 1][col] == -1) & (Up_down != 2)){
        IsValid = 1;
        YMove = 1;
    }
    if ((board[row][col - 1] == -1) & (Left_right != 1)){
        IsValid = 1;
        XMove = -1;
    }
    if ((board[row][col + 1] == -1) & (Left_right != 2)){
        IsValid = 1;
        XMove = 1;
    }
    
    if (IsValid == 1){
        board[row][col] = board[row + YMove][col + XMove];
        board[row + YMove][col + XMove] = tile;
    }
    
}",1
dkha055,1695632347,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int search) {
    
    int row,col;
    FindTile(board, -1, &row, &col);
    
    int rowArray[4] = {row - 1,row,row,row + 1};
    int colArray[4] = {col,col - 1,col + 1,col};
    
    for (int i = 0; i < 4; i++) {
        int currentRow = rowArray[i];
        int currentCol = colArray[i];
        
        if(board[currentRow][currentCol] == search) {
            
            board[row][col] = search;
            board[currentRow][currentCol] = -1;
        }
    }
}",0
dkha055,1695710351,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int search) {
    
    int row,col;
    FindTile(board, -1, &row, &col);
    
    int rowArray[4] = {row - 1,row,row,row + 1};
    int colArray[4] = {col,col - 1,col + 1,col};
    
    for (int i = 0; i < 4; i++) {
        int currentRow = rowArray[i];
        int currentCol = colArray[i];

        if (currentRow >=0 && currentCol >=0 && currentRow < 4 && currentCol < 4 ) {
            if(board[currentRow][currentCol] == search) {

                board[row][col] = search;
                board[currentRow][currentCol] = -1;
            }
        }
    }
}",1
dkim848,1695856235,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int tempr, tempc, row1, row2, col1, col2;
    
    FindTile(board, tile, &row1, &col1);
    FindTile(board, -1, &row2, &col2);
    
    if (((col1 == col2) && (row1 == row2 - 1 || row1 == row2 + 1)) || ((row1 == row2) && (col1 == col2 - 1 || col1 == col2 + 1))) {
        tempr = row1;
        row1 = row2;
        row2 = tempr;
        tempc = col1;
        col1 = col2;
        col2 = tempc;
        board[row1][col1] = tile;
        board[row2][col2] = -1;
    }
    
}",1
dkur670,1695960583,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int swapRow;
	int swapCol;
	FindTile(board, tile, &swapRow, &swapCol);
	int newRow;
	int newCol;
	FindTile(board, -1, &newRow, &newCol);
	
	//if (( swapRow == newRow && ( (swapRow == newRow -1) || (swapRow == newRow + 1))) || ((swapCol == newCol && ( (swapCol == newCol -1) || (swapCol = newCol + 1)))){
	
	if (swapRow == newRow){
		if ( (swapCol == newCol -1) || (swapCol == newCol + 1)){
			board[newRow][newCol] = tile;
			board[swapRow][swapCol] = -1;
			
		}		
	}else if (swapCol == newCol){
		if ((swapRow == newRow -1) || (swapRow == newRow + 1)){
			board[newRow][newCol] = tile;
			board[swapRow][swapCol] = -1;
	}
	

}
	}",1
dli630,1696146181,1,"void Swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int i_tile, j_tile;
    int i_empty, j_empty;
    int RowTile_Difference, ColTile_Difference ;

    FindTile(board, tile, &i_tile, &j_tile);
    FindTile(board, -1, &i_empty, &j_empty);

    RowTile_Difference = abs(i_tile - i_empty);
    ColTile_Difference = abs(j_tile - j_empty);

    if ((RowTile_Difference == 1 && j_tile == j_empty) || (i_tile == i_empty && ColTile_Difference == 1)) {
        Swap(&board[i_empty][j_empty], &board[i_tile][j_tile]);
    }
}",1
dlob194,1695717098,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int space_i;
    int space_j;
    int tile_i;
    int tile_j;
    
    FindTile(board, -1, &space_i, &space_j);
    FindTile(board, tile, &tile_i, &tile_j);
    
    if (tile_i - space_i == 1 && tile_j - space_j == 0)  {
        board[tile_i][tile_j] = -1;
        board[space_i][space_j] = tile;
    }
    
    if (tile_i - space_i == -1 && tile_j - space_j == 0)  {
        board[tile_i][tile_j] = -1;
        board[space_i][space_j] = tile;
    }
    
    if (tile_i - space_i == 0 && tile_j - space_j == 1)  {
        board[tile_i][tile_j] = -1;
        board[space_i][space_j] = tile;
    }
    
    if (tile_i - space_i == 0 && tile_j - space_j == -1)  {
        board[tile_i][tile_j] = -1;
        board[space_i][space_j] = tile;
    }
}",1
dma765,1696150343,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol;
    int tileRow, tileCol;


    FindTile(board, -1, &emptyRow, &emptyCol);


    FindTile(board, tile, &tileRow, &tileCol);

    if (tileRow == emptyRow && (tileCol == emptyCol + 1 || tileCol == emptyCol - 1)) {

        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    } else if (tileCol == emptyCol && (tileRow == emptyRow + 1 || tileRow == emptyRow - 1)) {

        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }

}",1
dmar494,1695690027,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int _row, _col, tilerow, tilecol;
    
    FindTile(board, -1, &_row, &_col);
    FindTile(board, tile, &tilerow, &tilecol);
    
    if ((_row == tilerow && (tilecol == (_col + 1) || tilecol == (_col - 1))) || 
        (_col == tilecol && (tilerow == (_row + 1) || tilerow == (_row - 1)))) {
            board[_row][_col] = tile;
            board[tilerow][tilecol] = -1;
    }
}",1
dmcn107,1696149948,1,"#include <stdio.h>
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    FindTile(board, -1, row1, col1)
    FindTile(board, tile2, row2, col2)
    if ((row2+1 = row1 || row2-1=row1) && (col2 = col1) || (col2+1 = col1 || col2-1=col1) && (row2 = row1)) {
        board[row1][col1] = tile2;
        board[row2][col2] = -1;
}
else {
    return;
}",0
dmcn107,1696150425,2,"#include <stdio.h>
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    int row1;
    int col1;
    int row2;
    int col2;
    FindTile(board, -1, row1, col1)
    FindTile(board, tile, row2, col2)
    if ((row2+1 == row1 || row2-1=row1) && (col2 == col1) || (col2+1 == col1 || col2-1 == col1) && (row2 == row1)) {
        board[row1][col1] = tile;
        board[row2][col2] = -1;
}
else {
    return;
}
}",0
dmcn107,1696229453,3,"#include <stdio.h>
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    int row1;
    int col1;
    int row2;
    int col2;
    FindTile(board, -1, &row1, &col1);
    FindTile(board, tile, &row2, &col2);
    if ((row2 - row1 == -1 && col2 == col1)  (row2 - row1 == 1 && col2 == col1)  (col2 - col1 == 1 && row2 == row1) || (col2 - col1 == -1 && row2 == row1)) {
        board[row1][col1] = tile;
        board[row2][col2] = -1;
    }
}",0
dmcn107,1696229692,4,"#include <stdio.h>
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    int row1;
    int col1;
    int row2;
    int col2;
    FindTile(board, -1, &row1, &col1);
    FindTile(board, tile, &row2, &col2);
    if ((row2 - row1 == -1 && col2 == col1) || (row2 - row1 == 1 && col2 == col1) || (col2 - col1 == 1 && row2 == row1) || (col2 - col1 == -1 && row2 == row1)) {
        board[row1][col1] = tile;
        board[row2][col2] = -1;
    }
}",1
dmun793,1696180863,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row = -1, column = -1, emptyRow = -1, emptyColumn = -1;

	FindTile(board, tile, &row, &column);
	FindTile(board, -1, &emptyRow, &emptyColumn);

	if (
		((row - 1 == emptyRow || row + 1 == emptyRow) && column == emptyColumn) ||
		((column - 1 == emptyColumn || column + 1 == emptyColumn) && row == emptyRow)
		)
	{
		board[emptyRow][emptyColumn] = tile;
		board[row][column] = -1;
	}
}",1
dosb979,1695785948,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    //Calls the find tile function to 
    int rowinput;
    int colinput;
    int tilerow;
    int tilecol;
    
    
    FindTile(board, -1, &tilerow, &tilecol);
        
    FindTile(board, tile, &rowinput, &colinput);
    
            if (tile == (board[tilerow+1][tilecol] ||  board[tilerow-1][tilecol] || board[tilerow][tilecol+1] || board[tilerow][tilecol-1])){
                board[tilerow][tilecol] = -1;
                board[rowinput][colinput] = tile;
            }
}",0
dosb979,1695787920,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    //Initialises variables for input location and tile location
    int rowinput;
    int colinput;
    int tilerow;
    int tilecol;
    
    //Runs the FindTile function to determine where the empty tile and input tile is located
    FindTile(board, -1, &emptyrow, &emptycol);
    FindTile(board, tile, &rowinput, &colinput);
    
    //If statement to ensure the input tile is adjacent to the empty tile
            if (tile == (board[emptyrow+1][emptycol] ||  board[emptyrow-1][emptycol] || board[emptyrow][emptycol+1] || board[emptyrow][emptycol-1])){
                board[emptyrow][emptycol] = tile;
                board[rowinput][colinput] = -1;
            }
}",0
dosb979,1695788046,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    //Initialises variables for input location and tile location
    int emptyrow;
    int emptycol;
    int rowinput;
    int colinput;
    
    //Runs the FindTile function to determine where the empty tile and input tile is located
    FindTile(board, -1, &emptyrow, &emptycol);
    FindTile(board, tile, &rowinput, &colinput);
    
    //If statement to ensure the input tile is adjacent to the empty tile
            if (tile == (board[emptyrow+1][emptycol] ||  board[emptyrow-1][emptycol] || board[emptyrow][emptycol+1] || board[emptyrow][emptycol-1])){
                board[emptyrow][emptycol] = tile;
                board[rowinput][colinput] = -1;
            }
}",0
dpar783,1696156193,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, row2, col2;
	FindTile(board, tile, &row, &col);
	FindTile(board, -1, &row2, &col2);

	if ((col == col2 && (row + 1 == row2 || row - 1 == row2)) || (row == row2 && (col + 1 == col2 || col - 1 == col2))) {
		board[row2][col2] = board[row][col];
		board[row][col] = -1;
	} else {
		return;
	}
}",1
dpat391,1696205571,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col,row1,col1;

    
    FindTile(board, tile, &row1, &col1);
    FindTile(board, -1, &row, &col);
    
    
    if ((row-1==-1)&&(col-1==-1))  {
        if ((board[row+1][col]==tile)||(board[row][col+1]==tile)){
            board[row][col] = tile;
            board[row1][col1] = -1;
        }
    } else if ((row-1==-1)) {
        if ((board[row+1][col]==tile)||(board[row][col+1]==tile)||(board[row][col-1]==tile)) {
            board[row][col] = tile;
            board[row1][col1] = -1;
        }
    } else if ((row-1==-1) && (col+1==NUM_COLS)) {
        if ((board[row+1][col]==tile)||(board[row][col-1]==tile)) {
            board[row][col] =tile;
            board[row1][col1] = -1;
        }
    } else if (col+1 == NUM_COLS) {
        if ((board[row+1][col]==tile)||(board[row][col-1]==tile)||(board[row-1][col-1]==tile)){
            board[row][col] = tile;
            board[row1][col1] = -1;
        }
    } else if ((col+1==NUM_COLS)&&(row+1==NUM_ROWS)){
        if ((board[row][col-1]==tile)||(board[row-1][col]==tile)) {
            board[row][col] = tile;
            board[row1][col1] = -1;
        }
    } else if (row+1==NUM_ROWS) {
        if ((board[row-1][col]==tile)||(board[row][col+1]==tile)||(board[row][col-1]==tile)) {
            board[row][col] = tile;
            board[row1][col1] = -1;
        }
    } else if ((col-1==-1)&&(row+1==NUM_ROWS)) {
        if ((board[row][col+1]==tile)||(board[row-1][col]==tile)) {
            board[row][col] = tile;
            board[row1][col1] = -1;
        }
    } else if (col-1==-1) {
        if ((board[row+1][col]==tile)||(board[row-1][col]==tile)||(board[row][col+1]==tile)){
            board[row][col] = tile;
            board[row1][col1] = -1;
        }
    } else {
        if ((board[row+1][col] == tile) || (board[row-1][col] == tile) || (board[row][col+1] == tile) || (board[row][col-1] == tile)) {
            board[row][col] = tile;
            board[row1][col1] = -1;
        }
    }
       
    
    
}",1
dpat674,1696226093,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
int emptySquareRow;
int emptySquareColumn;
int specifiedTileRow;
int specifiedTileColumn;

FindTile(board, -1, emptySquareRow, emptySquareColumn);
FindTile(board, tile, specifiedTileRow, specifiedTileColumn);


if(specifiedTileRow>=NUM_ROWS||specifiedTileColumn>=NUM_COLS){
return; 
}

if(specifiedTileRow==emptySquareRow - 1&&specifiedTileColumn==emptySquareColumn){        
board[emptySquareRow][emptySquareColumn]=tile;
board[specifiedTileRow][specifiedTileColumn]=-1;
} else if(specifiedTileRow==emptySquareRow + 1&&specifiedTileColumn==emptySquareColumn){
board[emptySquareRow][emptySquareColumn] = tile;
board[specifiedTileRow][specifiedTileColumn] = -1;
} else if(specifiedTileRow==emptySquareRow&&specifiedTileColumn==emptySquareColumn - 1){  
board[emptySquareRow][emptySquareColumn] = tile;
board[specifiedTileRow][specifiedTileColumn] = -1;
} else if(specifiedTileRow==emptySquareRow&&specifiedTileColumn==emptySquareColumn + 1){
board[emptySquareRow][emptySquareColumn]=tile;
board[specifiedTileRow][specifiedTileColumn]= -1;
} else if(specifiedTileRow == emptySquareRow - 1&&specifiedTileColumn == emptySquareColumn - 1){
board[emptySquareRow][emptySquareColumn] = tile;
board[specifiedTileRow][specifiedTileColumn] = -1;
} else if(specifiedTileRow == emptySquareRow - 1&&specifiedTileColumn == emptySquareColumn + 1){
board[emptySquareRow][emptySquareColumn] = tile;
board[specifiedTileRow][specifiedTileColumn] = -1;
} else if(specifiedTileRow == emptySquareRow + 1&&specifiedTileColumn == emptySquareColumn - 1){
board[emptySquareRow][emptySquareColumn] = tile;
board[specifiedTileRow][specifiedTileColumn] = -1;
} else if(specifiedTileRow==emptySquareRow+ 1&&specifiedTileColumn==emptySquareColumn + 1){
board[emptySquareRow][emptySquareColumn]=tile;
board[specifiedTileRow][specifiedTileColumn]= -1;
}
}
",0
dpat674,1696226236,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
int emptySquareRow;
int emptySquareColumn;
int specifiedTileRow;
int specifiedTileColumn;

FindTile(board, -1, &emptySquareRow, &emptySquareColumn);
FindTile(board, tile, &specifiedTileRow, &specifiedTileColumn);


if(specifiedTileRow>=NUM_ROWS||specifiedTileColumn>=NUM_COLS){
return 0; 
}

if(specifiedTileRow==emptySquareRow - 1&&specifiedTileColumn==emptySquareColumn){        
board[emptySquareRow][emptySquareColumn]=tile;
board[specifiedTileRow][specifiedTileColumn]=-1;
} else if(specifiedTileRow==emptySquareRow + 1&&specifiedTileColumn==emptySquareColumn){
board[emptySquareRow][emptySquareColumn] = tile;
board[specifiedTileRow][specifiedTileColumn] = -1;
} else if(specifiedTileRow==emptySquareRow&&specifiedTileColumn==emptySquareColumn - 1){  
board[emptySquareRow][emptySquareColumn] = tile;
board[specifiedTileRow][specifiedTileColumn] = -1;
} else if(specifiedTileRow==emptySquareRow&&specifiedTileColumn==emptySquareColumn + 1){
board[emptySquareRow][emptySquareColumn]=tile;
board[specifiedTileRow][specifiedTileColumn]= -1;
} else if(specifiedTileRow == emptySquareRow - 1&&specifiedTileColumn == emptySquareColumn - 1){
board[emptySquareRow][emptySquareColumn] = tile;
board[specifiedTileRow][specifiedTileColumn] = -1;
} else if(specifiedTileRow == emptySquareRow - 1&&specifiedTileColumn == emptySquareColumn + 1){
board[emptySquareRow][emptySquareColumn] = tile;
board[specifiedTileRow][specifiedTileColumn] = -1;
} else if(specifiedTileRow == emptySquareRow + 1&&specifiedTileColumn == emptySquareColumn - 1){
board[emptySquareRow][emptySquareColumn] = tile;
board[specifiedTileRow][specifiedTileColumn] = -1;
} else if(specifiedTileRow==emptySquareRow+ 1&&specifiedTileColumn==emptySquareColumn + 1){
board[emptySquareRow][emptySquareColumn]=tile;
board[specifiedTileRow][specifiedTileColumn]= -1;
}
}
",0
dpat674,1696226368,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
int emptySquareRow;
int emptySquareColumn;
int specifiedTileRow;
int specifiedTileColumn;

FindTile(board, -1, &emptySquareRow, &emptySquareColumn);
FindTile(board, tile, &specifiedTileRow, &specifiedTileColumn);


if(specifiedTileRow>=NUM_ROWS||specifiedTileColumn>=NUM_COLS){
return; 
}

if(specifiedTileRow==emptySquareRow - 1&&specifiedTileColumn==emptySquareColumn){        
board[emptySquareRow][emptySquareColumn]=tile;
board[specifiedTileRow][specifiedTileColumn]=-1;
} else if(specifiedTileRow==emptySquareRow + 1&&specifiedTileColumn==emptySquareColumn){
board[emptySquareRow][emptySquareColumn] = tile;
board[specifiedTileRow][specifiedTileColumn] = -1;
} else if(specifiedTileRow==emptySquareRow&&specifiedTileColumn==emptySquareColumn - 1){  
board[emptySquareRow][emptySquareColumn] = tile;
board[specifiedTileRow][specifiedTileColumn] = -1;
} else if(specifiedTileRow==emptySquareRow&&specifiedTileColumn==emptySquareColumn + 1){
board[emptySquareRow][emptySquareColumn]=tile;
board[specifiedTileRow][specifiedTileColumn]= -1;
} else if(specifiedTileRow == emptySquareRow - 1&&specifiedTileColumn == emptySquareColumn - 1){
board[emptySquareRow][emptySquareColumn] = tile;
board[specifiedTileRow][specifiedTileColumn] = -1;
} else if(specifiedTileRow == emptySquareRow - 1&&specifiedTileColumn == emptySquareColumn + 1){
board[emptySquareRow][emptySquareColumn] = tile;
board[specifiedTileRow][specifiedTileColumn] = -1;
} else if(specifiedTileRow == emptySquareRow + 1&&specifiedTileColumn == emptySquareColumn - 1){
board[emptySquareRow][emptySquareColumn] = tile;
board[specifiedTileRow][specifiedTileColumn] = -1;
} else if(specifiedTileRow==emptySquareRow+ 1&&specifiedTileColumn==emptySquareColumn + 1){
board[emptySquareRow][emptySquareColumn]=tile;
board[specifiedTileRow][specifiedTileColumn]= -1;
}
}
",1
dric234,1695783215,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row,col;
	FindTile(board, tile, &row, &col);
	if (board[row - 1][col] == -1) {
		board[row - 1][col] = tile;
		board[row][col] = -1;
	}
	if (board[row + 1][col] == -1) {
		board[row + 1][col] = tile;
		board[row][col] = -1;
	}
	if (board[row][col-1] == -1) {
		board[row][col-1] = tile;
		board[row][col] = -1;
	}
	if (board[row][col+1] == -1) {
		board[row][col+1] = tile;
		board[row][col] = -1;
	}
}",0
dric234,1695784835,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row,col;
	FindTile(board, tile, &row, &col);
	if (board[row - 1][col] == -1 && row -1 >= 0) {
		board[row - 1][col] = tile;
		board[row][col] = -1;
	}
	if (board[row + 1][col] == -1 && row + 1 < NUM_ROWS) {
		board[row + 1][col] = tile;
		board[row][col] = -1;
	}
	if (board[row][col-1] == -1 && col - 1 >= 0) {
		board[row][col-1] = tile;
		board[row][col] = -1;
	}
	if (board[row][col+1] == -1 && col + 1 < NUM_COLS) {
		board[row][col+1] = tile;
		board[row][col] = -1;
	} 
}",1
drob588,1696236209,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int gapRow, gapCol;
	int numRow, numCol;
	int distRow, distCol;

    // locating position of number and gap
	FindTile(board, -1, &gapRow, &gapCol);
	FindTile(board, tile, &numRow, &numCol);
	
	// using formula to find absolute distance from gap
	distRow = numRow - gapRow;
	distCol = numCol - gapCol;

    // identifying each possible case that is valid 
	if ((distRow == -1 && distCol == 0) || (distRow == 1 && distCol == 0) || (distCol == -1 && distRow == 0) || (distCol == 1 && distRow == 0)) {

		int temp = board[numRow][numCol];
		board[numRow][numCol] = board[gapRow][gapCol];
		board[gapRow][gapCol] = temp;
		
	} 
	// returning at end of func
	return;
}",1
droj056,1696222952,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	FindTile(board, tile, int tileRow, int tileCol);
	FindTile(board, -1, int emptyRow, int emptyCol);

	board[emptyRow][emptyCol] = tile;
	board[tileRow][tileCol] = -1;

}
",0
droj056,1696224382,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tileRow, tileCol;
	int emptyRow, emptyCol;

	FindTile(board, tile, &tileRow, &tileCol);
	FindTile(board, -1, &emptyRow, &emptyCol);

	if ((tileRow == emptyRow && (tileCol == emptyCol - 1 || tileCol == emptyCol + 1)) || 
		(tileCol == emptyCol && (tileRow == emptyRow - 1 || tileRow == emptyRow + 1))) {
		board[emptyRow][emptyCol] = tile;
		board[tileRow][tileCol] = -1;
	}
}
",1
dryu303,1695975074,1,"
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int i,j,row,col;
    i=0;
    j=0;
    for (i=0; i<4; i++)
    {
        for (j=0; j<4; j++)
        {
            if (board[i][j]==tile)
            {
                FindTile(board,-1, &row, &col);
                if ((row-i==1|row-i==-1)^((col-j==1|col-j==-1)))
                {
                    board[i][j]=-1;
                    board[row][col]=tile;
                    return;
                }
            }
        }
    }
}",0
dryu303,1695975334,2,"
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int i,j,row,col;
    i=0;
    j=0;
    for (i=0; i<4; i++)
    {
        for (j=0; j<4; j++)
        {
            if (board[i][j]==tile)
            {
                FindTile(board,-1, &row, &col);
                if (((row-i==1)|(row-i==-1))^(((col-j==1)|(col-j==-1))))
                {
                    board[i][j]=-1;
                    board[row][col]=tile;
                    return;
                }
            }
        }
    }
}",0
dryu303,1695976824,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int i,j,row,col;
    i=0;
    j=0;
    for (i=0; i<4; i++)
    {
        for (j=0; j<4; j++)
        {
            if (board[i][j]==tile)
            {
                FindTile(board,-1, &row, &col);
                if (    ( (col==j)&((row-i==1)|(i-row==1)) )| ( (row==i)&((col-j==1)|(j-col==1)))   )
                {
                    printf(""IJ %d %d\n"",i,j);
                    printf(""row col %d %d\n"", row, col);
                    board[i][j]=-1;
                    board[row][col]=tile;
                    return;
                }
            }
        }
    }
}",0
dryu303,1695976838,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int i,j,row,col;
    i=0;
    j=0;
    for (i=0; i<4; i++)
    {
        for (j=0; j<4; j++)
        {
            if (board[i][j]==tile)
            {
                FindTile(board,-1, &row, &col);
                if (    ( (col==j)&((row-i==1)|(i-row==1)) )| ( (row==i)&((col-j==1)|(j-col==1)))   )
                {
                    board[i][j]=-1;
                    board[row][col]=tile;
                    return;
                }
            }
        }
    }
}",1
dsan845,1696241796,1,"*******************************************************************************/
#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int ER, EC;
    int Tr, Tc;

    FindTile(board, -1, &ER, &EC);

    FindTile(board, tile, &Tr, &Tc);

    if ((Tr == ER && (Tc == EC - 1 || Tc == EC + 1)) ||
        (Tc == EC && (Tr == ER - 1 || Tr == ER + 1))) {
        board[ER][EC] = tile;
        board[Tr][Tc] = -1;
    }

",0
dsan845,1696241804,2,"*******************************************************************************/
#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int ER, EC;
    int Tr, Tc;

    FindTile(board, -1, &ER, &EC);

    FindTile(board, tile, &Tr, &Tc);

    if ((Tr == ER && (Tc == EC - 1 || Tc == EC + 1)) ||
        (Tc == EC && (Tr == ER - 1 || Tr == ER + 1))) {
        board[ER][EC] = tile;
        board[Tr][Tc] = -1;
    }
}
",0
dsan845,1696241958,3,"*******************************************************************************/
#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int ER, EC;
    int Tr, Tc;

    FindTile(board, -1, &ER, &EC);

    FindTile(board, tile, &Tr, &Tc);

    if ((Tr == ER && (Tc == EC - 1 || Tc == EC + 1)) ||
        (Tc == EC && (Tr == ER - 1 || Tr == ER + 1))) {
        board[ER][EC] = tile;
        board[Tr][Tc] = -1;
    }
    
    return 0 ;
}
",0
dsan845,1696242628,4,"*******************************************************************************/
#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int ER, EC;
    int Tr, Tc;

    FindTile(board, -1, &ER, &EC);

    FindTile(board, tile, &Tr, &Tc);

    if ((Tr == ER && (Tc == EC - 1 || Tc == EC + 1)) ||
        (Tc == EC && (Tr == ER - 1 || Tr == ER + 1))) {
        board[ER][EC] = tile;
        board[Tr][Tc] = -1;
    }
    
    return  ;
}
",0
dsan845,1696242643,5,"*******************************************************************************/
#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int ER, EC;
    int Tr, Tc;

    FindTile(board, -1, &ER, &EC);

    FindTile(board, tile, &Tr, &Tc);

    if ((Tr == ER && (Tc == EC - 1 || Tc == EC + 1)) ||
        (Tc == EC && (Tr == ER - 1 || Tr == ER + 1))) {
        INT
        
        board[Tr][Er] = board[ER][EC];
        board[ER][EC] = board[Tr][Tc];
    }

    return ;
}


",0
dsan845,1696242685,6,"*******************************************************************************/
#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int ER, EC;
    int Tr, Tc;

    FindTile(board, -1, &ER, &EC);

    FindTile(board, tile, &Tr, &Tc);

    if ((Tr == ER && (Tc == EC - 1 || Tc == EC + 1)) ||
        (Tc == EC && (Tr == ER - 1 || Tr == ER + 1))) {
        
        
        board[Tr][Er] = board[ER][EC];
        board[ER][EC] = board[Tr][Tc];
    }

    return ;
}


",0
dsaw164,1695776769,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int move_row;
	int move_col;
	int row_empty;
	int col_empty;

	FindTile(board, tile, &move_row, &move_col);
	FindTile(board, -1, &row_empty, &col_empty); 

	if((row_empty == move_row + 1 || row_empty == move_row - 1) && (col_empty == move_col)){
		board[row_empty][col_empty] = tile;
		board[move_row][move_col] = -1;
	}

	else if((col_empty == move_col + 1 || col_empty == move_col - 1) && (row_empty == move_row)){
		board[row_empty][col_empty] = tile;
		board[move_row][move_col] = -1;
	}
}",1
dsin316,1695893747,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row;
	int col;

	int rowT;
	int colT;

	FindTile(board, tile, &row, &col);

	FindTile(board,-1, &rowT, &colT);
	

	 if (row + 1 == rowT && col == colT) {
        board[row][col] = -1;
        board[row + 1][col] = tile;
    }
    else if (row - 1 == rowT && col == colT) {
        board[row][col] = -1;
        board[row - 1][col] = tile;
    }
    else if (row == rowT && col - 1 == colT) {
        board[row][col] = -1;
        board[row][col - 1] = tile;
    }
    else if (row == rowT && col + 1 == colT) {
        board[row][col] = -1;
        board[row][col + 1] = tile;
    }


}",1
dstr542,1695993414,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;
	//find position of tile to be moved
		FindTile(board, tile, &row, &col);
		int tileRow = row;
		int tileCol = col;
			//printf(""OLD tilerow is %d and tilecol is %d\n"", tileRow, tileCol);
		
	//find position of empty tile
		FindTile(board, -1, &row, &col);
			//printf(""row is %d and col is %d"", row, col);
		int emptyRow = row;
		int emptyCol = col;
		int checker = 0;
			//printf(""OLD emptyrow is %d and emptycol is %d\n"", emptyRow, emptyCol);


	//check if they are adjacent (taking edge cases)
		if (((tileRow + 1 == emptyRow) || (tileRow - 1 == emptyRow)) && (tileCol == emptyCol)) {
				checker = 1;
				//printf(""checker is 1(1) "");
				//printf(""old empty space: (row)%d (col)%d, old tile space: (row)%d col(%d)\n\n"", emptyRow, emptyCol, tileRow, tileCol);
	
		} 
		if (((tileCol + 1 == emptyCol) || (tileCol - 1 == emptyCol)) && (tileRow == emptyRow)) {
				 checker = 1;
				 //printf(""checker is 1(2) "");
		} 
		


	// swap the two integers if they are adjacent (and return*?)
	if (checker == 1) {
		int tempNewEmpty, tempNewTile;

		tempNewEmpty = board[tileRow][tileCol];
		tempNewTile = board[emptyRow][emptyCol];

		board[tileRow][tileCol] = tempNewTile;
		board[emptyRow][emptyCol] = tempNewEmpty;
		//printf(""shoulda worked\n"");
			//printf(""New empty space: (row)%d (col)%d, new tile space: (row)%d col(%d)\n\n"", emptyRow, emptyCol, tileRow, tileCol);
	}
	else {
		return;
	}
}",1
dsut709,1696044759,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int input_row, input_col, space_row, space_col;
	FindTile(board, tile, &input_row, &input_col);
	FindTile(board, -1, &space_row, &space_col);
	
	int hori_dist = 0;
	int vert_dist = 0;
	if (input_row > space_row) {
		vert_dist = input_row - space_row;
	}
	if (space_row > input_row) {
		vert_dist = space_row - input_row;
	}
	if (input_col > space_col) {
		hori_dist = input_col - space_col;
	}
	if (space_col > input_col) {
		hori_dist = space_col - input_col;
	}
	int total_dist = hori_dist + vert_dist;
	if (total_dist==1) {
		board[input_row][input_col] = -1;
		board[space_row][space_col] = tile;
	}
}",1
dtem664,1696241949,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tilerow, tilecol, blankrow, blankcol;
	FindTile(board, -1, &blankrow, &blankcol);
	FindTile(board, tile, &tilerow, &tilecol);
	//printf(""%d %d\n %d %d\n"", blankrow, blankcol, tilerow, tilecol);
	if ((tilerow <= blankrow+1) && (tilerow >= blankrow-1)) {
		if ((tilecol <= blankcol+1) && (tilecol >= blankcol-1)) {
			board[blankrow][blankcol] = board[tilerow][tilecol];
			board[tilerow][tilecol] = -1;


		}
	}


}",1
dten781,1696244294,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int Row, Col;
    FindTile(board, -1, &Row, &Col);

    int tileRow, tileCol;
    FindTile(board, tile, &tileRow, &tileCol);

    // Check if the tile can be moved (adjacent to the empty space)
    if ((abs(Row - tileRow) == 1 && Col == tileCol) || (abs(Col - tileCol) == 1 && Row == tileRow)) {
        // Swap the empty space and the tile
        board[Row][Col] = tile;
        board[tileRow][tileCol] = -1;
    } else {
        printf(""Invalid move. You can only move adjacent tiles.\n"");
    }
}",0
dtie151,1695877334,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tileRow, tileCol, emptyRow, emptyCol;

	FindTile(board, tile, &tileRow, &tileCol);
	FindTile(board, -1, &emptyRow, &emptyCol);

	if ((abs(tileRow - emptyRow) == 1 && tileCol == emptyCol) || (abs(tileCol - emptyCol) == 1 && tileRow == emptyRow)) {
		board[emptyRow][emptyCol] = tile;
		board[tileRow][tileCol] = -1;

	}
}",1
dtol781,1695851604,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, rowt, colt;
	int temp, latter;
	FindTile(board, -1, &row, &col);
	FindTile(board, tile, &rowt, &colt);
	int top = row - 1;
	int bottom = row + 1;
	int right = col + 1;
	int left = col - 1;

	if(board[row + 1][col] == tile && row != NUM_ROWS-1) {
		temp = board[row][col];
		latter = board[row + 1][col];
		board[row][col] = latter;
		board[row + 1][col] = temp;
	}
	else if(board[row - 1][col] == tile && row != 0 ) {
		temp = board[row][col];
		latter = board[row - 1][col];
		board[row][col] = latter;
		board[row - 1][col] = temp;
	}
	else if(board[row][col + 1] == tile && col != NUM_COLS-1) {
		temp = board[row][col];
		latter = board[row][col + 1];
		board[row][col] = latter;
		board[row][col + 1] = temp;
	}
	else if(board[row][col - 1] == tile && col != 0) {
		temp = board[row][col];
		latter = board[row][col - 1];
		board[row][col] = latter;
		board[row][col - 1] = temp;
	}

}",0
dtol781,1695851699,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, rowt, colt;
	int temp, latter;
	FindTile(board, -1, &row, &col);
	FindTile(board, tile, &rowt, &colt);

	if(board[row + 1][col] == tile && row != NUM_ROWS-1) {
		temp = board[row][col];
		latter = board[row + 1][col];
		board[row][col] = latter;
		board[row + 1][col] = temp;
	}
	else if(board[row - 1][col] == tile && row != 0 ) {
		temp = board[row][col];
		latter = board[row - 1][col];
		board[row][col] = latter;
		board[row - 1][col] = temp;
	}
	else if(board[row][col + 1] == tile && col != NUM_COLS-1) {
		temp = board[row][col];
		latter = board[row][col + 1];
		board[row][col] = latter;
		board[row][col + 1] = temp;
	}
	else if(board[row][col - 1] == tile && col != 0) {
		temp = board[row][col];
		latter = board[row][col - 1];
		board[row][col] = latter;
		board[row][col - 1] = temp;
	}

}",1
dver839,1696227596,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	/* Find position of tile that needs to be moved into empty space*/
	int tileRow;
	int tileCol;
	FindTile(board, tile, &tileRow, &tileCol);

	/* Find position of -1 (empty tile)*/
	int Row;
	int Col;
	FindTile(board, -1, &Row, &Col);

	/*Check if tiles can be swapped*/

	/* If tile and empty space in same row, then check if they are in adjacent columns. */
	if (tileRow == Row)
	{
		if ((tileCol == Col + 1) || (tileCol == Col - 1))
		{
			board[tileRow][tileCol] = -1;
			board[Row][Col] = tile;
		}
	}

	/* Else if tile and empty space is same column, then check if they are in adjacent rows. */
	else if (tileCol == Col)
	{
		if ((tileRow == Row + 1) || (tileRow == Row - 1))
		{
			board[tileRow][tileCol] = -1;
			board[Row][Col] = tile;
		}
	}
}",1
dvu878,1696141223,1,"#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>


void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;
	// finding position of tile to move
	FindTile(board, tile, &row, &col);

	// upwards comparison
	// checking if comparison will cause errors
	if (row - 1 >= 0) {
		// checking for -1
		if (board[row - 1][col] == -1) {
			// completing the move
			board[row - 1][col] = tile;
			board[row][col] = -1;
		}
	}

	// downwards
	if (row + 1 < NUM_ROWS) {
		// checking for -1
		if (board[row + 1][col] == -1) {
			// completing the move
			board[row + 1][col] = tile;
			board[row][col] = -1;
		}
	}

	// right
	if (col + 1 < NUM_COLS) {
		// checking for -1
		if (board[row ][col + 1] == -1) {
			// completing the move
			board[row][col + 1] = tile;
			board[row][col] = -1;
		}
	}

	// left
	if (col - 1 >= 0) {
		// checking for -1
		if (board[row][col - 1] == -1) {
			// completing the move
			board[row][col - 1] = tile;
			board[row][col] = -1;
		}
	}
}",1
dwar594,1695785465,1,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    
    int row, col, emptyrow, emptycol;
    
    FindTile(board, tile, &row, &col);
    FindTile(board, -1, &emptyrow, &emptycol);
    
    if ((row > 0) && (board[row - 1][col] == -1) || ((row < NUM_ROWS - 1) && (board[row + 1][col] == -1)))){
        
        board[row][col] = -1;
        board[emptyrow][emptycol] = tile;
    }
    
    if ((col > 0) && (board[row][col - 1] == -1) || ((col < NUM_COLS - 1) && (board[row][col + 1] == -1)))){
        
        board[row][col] = -1;
        board[emptyrow][emptycol] = tile;
    }
}
",0
dwar594,1695785485,2,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    
    int row, col, emptyrow, emptycol;
    
    FindTile(board, tile, &row, &col);
    FindTile(board, -1, &emptyrow, &emptycol);
    
    if (((row > 0) && (board[row - 1][col] == -1) || ((row < NUM_ROWS - 1) && (board[row + 1][col] == -1)))){
        
        board[row][col] = -1;
        board[emptyrow][emptycol] = tile;
    }
    
    if (((col > 0) && (board[row][col - 1] == -1) || ((col < NUM_COLS - 1) && (board[row][col + 1] == -1)))){
        
        board[row][col] = -1;
        board[emptyrow][emptycol] = tile;
    }
}
",0
dwar594,1695785713,3,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    
    int row, col, emptyrow, emptycol;
    
    FindTile(board, tile, &row, &col);
    FindTile(board, -1, &emptyrow, &emptycol);
    
    if (((row > 0) && (board[row - 1][col] == -1)) || ((row < NUM_ROWS - 1) && (board[row + 1][col] == -1))){
        
        board[row][col] = -1;
        board[emptyrow][emptycol] = tile;
    }
    
    if (((col > 0) && (board[row][col - 1] == -1)) || ((col < NUM_COLS - 1) && (board[row][col + 1] == -1))){
        
        board[row][col] = -1;
        board[emptyrow][emptycol] = tile;
    }
}

",1
dwu617,1695965896,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, row1, col1;

	FindTile(board, tile, &row, &col);
	FindTile(board, -1, &row1, &col1);

	if ((row - row1 == -1) || (row - row1 == 0) || (row - row1 == 1)) {
		if ((col - col1 == -1) || (col - col1 == 0) || (col - col1 == 1)) {
			board[row1][col1] = tile;
			board[row][col] = -1;
		}
	}
}",1
dyu343,1695615790,1,"int isVerticallyAdjacent(int tile_row, int tile_col, int empty_row, int empty_col)
{
	if ((empty_col == tile_col) && (empty_row - tile_row == 1 || empty_row - tile_row == -1))
	{
		return 1;
	}
	return 0;
}

int isHorizontallyAdjacent(int tile_row, int tile_col, int empty_row, int empty_col)
{
	if ((empty_row == empty_col) && (empty_col - tile_col == 1 || empty_col - tile_col == -1))
	{
		return 1;
	}
	return 0;
}



void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int empty_row, empty_col; // row and column index of specified tile.

	FindTile(board, -1, &empty_row, &empty_col);

	int tile_row, tile_col;

	FindTile(board, tile, &tile_row, &tile_col);

	int vert_adjacent = isVerticallyAdjacent(tile_row, tile_col, empty_row, empty_col);
	int horiz_adjacent = isHorizontallyAdjacent(tile_row, tile_col, empty_row, empty_col);

	// checking if the empty square and the tile are next to eachother in order to modify the board.
	if (vert_adjacent && !horiz_adjacent)
	{
		board[empty_row][empty_col] = board[tile_row][tile_col];
		board[tile_row][tile_col] = -1;
	}
	else if (!vert_adjacent && horiz_adjacent)
	{
		board[empty_row][empty_col] = board[tile_row][tile_col];
		board[tile_row][tile_col] = -1;
	}

}
",0
dyu343,1695615875,2,"int isVerticallyAdjacent(int tile_row, int tile_col, int empty_row, int empty_col)
{
	if ((empty_col == tile_col) && (empty_row - tile_row == 1 || empty_row - tile_row == -1))
	{
		return 1;
	}
	return 0;
}

int isHorizontallyAdjacent(int tile_row, int tile_col, int empty_row, int empty_col)
{
	if ((empty_row == tile_row) && (empty_col - tile_col == 1 || empty_col - tile_col == -1))
	{
		return 1;
	}
	return 0;
}



void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int empty_row, empty_col; // row and column index of specified tile.

	FindTile(board, -1, &empty_row, &empty_col);

	int tile_row, tile_col;

	FindTile(board, tile, &tile_row, &tile_col);

	int vert_adjacent = isVerticallyAdjacent(tile_row, tile_col, empty_row, empty_col);
	int horiz_adjacent = isHorizontallyAdjacent(tile_row, tile_col, empty_row, empty_col);

	// checking if the empty square and the tile are next to eachother in order to modify the board.
	if (vert_adjacent && !horiz_adjacent)
	{
		board[empty_row][empty_col] = board[tile_row][tile_col];
		board[tile_row][tile_col] = -1;
	}
	else if (!vert_adjacent && horiz_adjacent)
	{
		board[empty_row][empty_col] = board[tile_row][tile_col];
		board[tile_row][tile_col] = -1;
	}

}",1
dzha497,1695878154,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row,col;
    
    FindTile(board,tile,&row,&col);

    if (row - 1 >= 0) {
        if (board[row - 1][col] == -1) {
            board[row - 1][col] = tile;
            board[row][col] = -1;
            
        }
    }
    if (col - 1 >= 0) {
        if (board[row][col - 1] == -1) {
            board[row][col - 1] = tile;
            board[row][col] = -1;
        }
    }
    if (row + 1 < 4) {
        if (board[row + 1][col] == -1) {
            board[row + 1][col] = tile;
            board[row][col] = -1;
        }
    }
    if (col + 1 < 4) {
        if (board[row][col + 1] == -1) {
            board[row][col + 1] = tile;
            board[row][col] = -1;
        }
    } 
}",1
eara128,1695857854,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, rowPos, colPos; 
	// finding the position of the -1 tile, which is the empty tile 
	FindTile(board, -1, &row, &col);
	// finding the position of the tile that we want to swap
	FindTile(board, tile, &rowPos, &colPos);
	// checking if the empty tile is adjacent to tile we want to swap 
	if (rowPos == row){
		if (colPos == col -1 || colPos == col +1){
			// updating the value of the empty tile to match the value of the tile we are swapping
			board[row][col] = tile;
			// making the once full tile into an empty tile 
			board[rowPos][colPos] = -1;
		}
	}
	else if (rowPos == row - 1 || rowPos == row + 1 ) {
		if (colPos == col) {
			// updating the value of the empty tile to match the value of the tile we are swapping
			board[row][col] = tile;
			// making the once full tile into an empty tile 
			board[rowPos][colPos] = -1;
		}
	}
}",1
earn712,1695870856,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    
    int emptyRow, emptyCol;
    int row, col;
    
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &row, &col);
    
    if (abs(emptyRow - row)  <= 1  && abs(emptyCol- col) <=1){ 
        int temp = board[emptyRow][emptyCol];
        board[emptyRow][emptyCol] = board[row][col];
        board[row][col] = temp;
    }
    
}

",1
ebar824,1695990441,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowEmpty;
    int colEmpty;
    int rowTile;
    int colTile;

    for (int i = 0; i < NUM_ROWS; i++)
    {
        for (int j = 0; j < NUM_COLS; j++)
        {
            if (board[i][j] == -1){
                
                rowEmpty =i;
                colEmpty =j;
                

            }

            if (board[i][j] == tile){
                
                rowTile =i;
                colTile =j;
                

            }
               
        }
        
    }

    if (board[rowEmpty][colEmpty] == board[rowTile+1][colEmpty]){
        board[rowEmpty][colEmpty] = board[rowTile][colTile]; 
        board[rowTile][colTile] = -1;
    }
    if (board[rowEmpty][colEmpty] == board[rowTile-1][colEmpty]){
        board[rowEmpty][colEmpty] = board[rowTile][colTile]; 
        board[rowTile][colTile] = -1;
    }
    if (board[rowEmpty][colEmpty] == board[rowEmpty][colTile+1]){
        board[rowEmpty][colEmpty] = board[rowTile][colTile]; 
        board[rowTile][colTile] = -1;
    }
    if (board[rowEmpty][colEmpty] == board[rowEmpty][colTile-1]){
        board[rowEmpty][colEmpty] = board[rowTile][colTile]; 
        board[rowTile][colTile] = -1;
    }
        

    




}",0
ebar824,1696032449,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowEmpty;
    int colEmpty;
    int rowTile;
    int colTile;
    int move =0;

    for (int i = 0; i < NUM_ROWS; i++)
    {
        for (int j = 0; j < NUM_COLS; j++)
        {
            if (board[i][j] == -1){
                
                rowEmpty =i;
                colEmpty =j;
                

            }

            if (board[i][j] == tile){
                
                rowTile =i;
                colTile =j;
                

            }
               
        }
        
    }

    if (-1 == board[rowTile+1][colTile]){
        move = 1;
    }
    else if (-1 == board[rowTile-1][colTile]){
        move = 1;
    
    }
    else if (-1 == board[rowTile][colTile+1] && colTile+1 !=4){
        move = 1;
    }
    else if (-1 == board[rowTile][colTile-1] && colTile-1 !=-1){
        move = 1;
    }
        
    
    if (move ==1){
        board[rowEmpty][colEmpty] = board[rowTile][colTile]; 
        board[rowTile][colTile] = -1;
    }




}




",1
echa931,1696229262,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int R, C;
    int row, col;
    FindTile(board, -1, &row, &col);
    FindTile(board, tile, &R, &C);
	int n = board[R][C];
	if ((R == row and (C == col + 1 or C == col - 1)) or (C == col and (R == row + 1 or R == row - 1))) {
		board[R][C] = board[row][col];
		board[row][col] = n;
	}
}",0
echa931,1696229749,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int R, C;
	int row, col;
	FindTile(board, -1, &row, &col);
	FindTile(board, tile, &R, &C);
	int n = board[R][C];
	if (((R == row) and ((C == col + 1) or (C == col - 1))) or ((C == col) and ((R == row + 1) or (R == row - 1)))) {
		board[R][C] = board[row][col];
		board[row][col] = n;
	}
}",0
echa931,1696230841,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int R, C;
	int row, col;
	FindTile(board, -1, &row, &col);
	FindTile(board, tile, &R, &C);
	int n = board[R][C];
	if ( (R == row) && (C == (col + 1)) ) {
		board[R][C] = board[row][col];
		board[row][col] = n;
	}
	if ( (R == row) && (C == (col - 1)) ) {
		board[R][C] = board[row][col];
		board[row][col] = n;
	}
	if ( (C == col) && (R == (row + 1)) ) {
		board[R][C] = board[row][col];
		board[row][col] = n;
	}
	if ((C == col) && (R == (row - 1)) ) {
		board[R][C] = board[row][col];
		board[row][col] = n;
	}
}",1
eche101,1696201222,1,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowPos = -1; 
    int colPos = -1; 
    int tileRow = -1;
    int tileCol = -1;
    
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == -1) {
                rowPos = i;
                colPos = j;
            } else if (board[i][j] == tile) {
                tileRow = i;
                tileCol = j;
            }      
            
        }
            
    }
    
    int rowDiff = rowPos - tileRow;
    int colDiff = colPos - tileCol;
    
    if ((rowDiff == 1 || rowDiff == -1) && colPos == tileCol ||
        (colDiff == 1 || colDiff == -1) && rowPos == tileRow) {
        
        int x = board[rowPos][colPos];
        board[rowPos][colPos] = board[tileRow][tileCol];
        board[tileRow][tileCol] = x;
        }

}",0
eche101,1696201888,2,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int rowPos = -1; 
    int colPos = -1; 
    int tileRow = -1;
    int tileCol = -1;
    
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == -1) {
                rowPos = i;
                colPos = j;
            } else if (board[i][j] == tile) {
                tileRow = i;
                tileCol = j;
            }      
        }
    }
    
    int rowDiff = rowPos - tileRow;
    int colDiff = colPos - tileCol;
    
    if (((rowDiff == 1 || rowDiff == -1) && colPos == tileCol) ||
        ((colDiff == 1 || colDiff == -1) && rowPos == tileRow)) {

        int x = board[rowPos][colPos];
        board[rowPos][colPos] = board[tileRow][tileCol];
        board[tileRow][tileCol] = x;
    }
}",1
eejl688,1696225595,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) 
{
	int row, col;
	FindTile(board, -1, &row, &col);

	int row_tile, col_tile;
	FindTile(board, tile, &row_tile, &col_tile);

	if (row_tile == row && abs(col_tile - col) == 1) || (col_tile == col && abs(row_tile - row) == 1)
	{
		board[row][col] = tile;
		board[row_tile][col_tile] = -1;
	}
",0
eejl688,1696226021,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) 
{
	int row, col;
	FindTile(board, -1, &row, &col);

	int row_tile, col_tile;
	FindTile(board, tile, &row_tile, &col_tile);

	if ((row_tile == row && abs(col_tile - col) == 1) || (col_tile == col && abs(row_tile - row) == 1))
	{
		board[row][col] = tile;
		board[row_tile][col_tile] = -1;
	}
",0
eejl688,1696226334,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) 
{
	int row, col;
	FindTile(board, -1, &row, &col);

	int row_tile, col_tile;
	FindTile(board, tile, &row_tile, &col_tile);

	if ((row_tile == row && abs(col_tile - col) == 1) || (col_tile == col && abs(row_tile - row) == 1))
	{
		int placeholder = 
		board[row][col] = tile;
		board[row_tile][col_tile] = -1;
	}
}",0
eejl688,1696227101,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col;
    FindTile(board, -1, &row, &col);

    int row_tile, col_tile;
    FindTile(board, tile, &row_tile, &col_tile);

 
    if ((row == row_tile && abs(col_tile - col) == 1) || (col == col_tile && abs(row - row_tile) == 1))
    {
        board[row][col] = tile;
        board[row_tile][col_tile] = -1;
    }
}",1
eejl932,1695782077,1,"/* ENGGEN131 (2022) - Lab 9 (25th - 30th September, 2023)
   EXERCISE SEVEN and EIGHT - Sliding Tile Puzzle
*/
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

/* The dimensions of the puzzle */
#define NUM_ROWS 4
#define NUM_COLS 4

void PrintBoard(int board[NUM_ROWS][NUM_COLS]) {
    for (int row = 0; row < NUM_ROWS; row++) {
        for (int col = 0; col < NUM_COLS; col++) {
            if (board[row][col] == -1) {
                printf(""_ "");
            } else {
                printf(""%2d "", board[row][col]);
            }
        }
        printf(""\n"");
    }
}

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow = -1;
    int emptyCol = -1;
    int tileRow = -1;
    int tileCol = -1;

    // Find the positions of the empty square and the specified tile
    for (int row = 0; row < NUM_ROWS; row++) {
        for (int col = 0; col < NUM_COLS; col++) {
            if (board[row][col] == -1) {
                emptyRow = row;
                emptyCol = col;
            } else if (board[row][col] == tile) {
                tileRow = row;
                tileCol = col;
            }
        }
    }
}",0
eejl932,1696143154,2,"/* ENGGEN131 (2022) - Lab 9 (25th - 30th September, 2023)
   EXERCISE SEVEN and EIGHT - Sliding Tile Puzzle
*/
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

/* The dimensions of the puzzle */
#define NUM_ROWS 4
#define NUM_COLS 4

void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *row, int *col) {
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == tile) {
                *row = i;
                *col = j;
                return;
            }
        }
    }
}

// Function to swap two tiles
void SwapTiles(int board[NUM_ROWS][NUM_COLS], int row1, int col1, int row2, int col2) {
    int temp = board[row1][col1];
    board[row1][col1] = board[row2][col2];
    board[row2][col2] = temp;
}

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol;
    int tileRow, tileCol;

    FindTile(board, -1, &emptyRow, &emptyCol);

    FindTile(board, tile, &tileRow, &tileCol);

}

void PrintBoard(int board[NUM_ROWS][NUM_COLS]) {
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == -1) {
                printf("" _ "");
            } else {
                printf(""%2d "", board[i][j]);
            }
        }
        printf(""\n"");
    }
}",0
eejl932,1696143256,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol;
    int tileRow, tileCol;

    // Find the coordinates of the empty square (-1)
    FindTile(board, -1, &emptyRow, &emptyCol);

    // Find the coordinates of the specified tile
    FindTile(board, tile, &tileRow, &tileCol);

    }",0
eejl932,1696143565,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRow, tileCol, emptyRow, emptyCol;

    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol);
    
}",0
eejl932,1696216539,5,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol;
    FindTile(board, -1, &emptyRow, &emptyCol); // Find the empty square

    int tileRow, tileCol;
    FindTile(board, tile, &tileRow, &tileCol); // Find the specified tile

    if ((abs(emptyRow - tileRow) == 1 && emptyCol == tileCol) ||
        (abs(emptyCol - tileCol) == 1 && emptyRow == tileRow)) {

        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}",1
efra318,1695888101,1,"void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int* rowPos, int* colPos)
{
	int i = 0;
	int j = 0;

	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {

			if (board[i][j] == tile) {
				*rowPos = i;
				*colPos = j;
				return;
			}

		}
	}
}",0
efra318,1696125285,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row = 0;
	int col = 0;
	int checkRow = 0;
	int checkCol = 0;
	int storeRow = 0;
	int storeCol = 0;
	int i = 0;
	int j = 0;
	int rowPos = 0;
	int colPos = 0;

	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {

			if (board[i][j] == tile) {
				rowPos = i;
				colPos = j;
			}
		}
	}


	row = rowPos;
	col = colPos;

	//check rows for empty tile
	if (rowPos == 0) {
		checkRow = row + 1;
		if (board[checkRow][col] == -1) {
			storeRow = board[row][col];
			board[row][col] = -1;
			board[checkRow][col] = storeRow;
		}
	}
	else if (rowPos == 3) {
		checkRow = row - 1;
		if (board[checkRow][col] == -1) {
			storeRow = board[row][col];
			board[row][col] = -1;
			board[checkRow][col] = storeRow;
		}
	}
	else {
		checkRow = row + 1;
		if (board[checkRow][col] == -1) {
			storeRow = board[row][col];
			board[row][col] = -1;
			board[checkRow][col] = storeRow;
		}
		else {
			checkRow = row - 1;
			if (board[checkRow][col] == -1) {
				storeRow = board[row][col];
				board[row][col] = -1;
				board[checkRow][col] = storeRow;
			}
		}
	}

	if (colPos == 0) {
		checkCol = col + 1;
		if (board[row][checkCol] == -1) {
			storeCol = board[row][col];
			board[row][col] = -1;
			board[row][checkCol] = storeCol;

		}
	}
	else if (colPos == 3) {
		checkCol = col - 1;
		if (board[row][checkCol] == -1) {
			storeCol = board[row][col];
			board[row][col] = -1;
			board[row][checkCol] = storeCol;
		}
	}
	else {
		checkCol = col + 1;
		if (board[row][checkCol] == -1) {
			storeCol = board[row][col];
			board[row][col] = -1;
			board[row][checkCol] = storeCol;
		}
		else {
			checkCol = col - 1;
			if (board[row][checkCol] == -1) {
				storeCol = board[row][col];
				board[row][col] = -1;
				board[row][checkCol] = storeCol;
			}
		}

	}
}",1
egho902,1696226516,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int Rows, Columns;
    int R, C;
    int DistR, DistC;
    FindTile(board, tile, &Rows, &Columns);
    FindTile(board, -1, &R, &C);
    
    DistC = Columns - C;
    DistR = Rows - R;
    
if ((DistR >= -1 || DistR <= 1) && (DistC >= -1 || DistC <= 1))
{
    int Temporary = board[Rows][Columns];
    board[R][C] = Temporary;
}
    else
    {
        return;
    }
}",0
egho902,1696226535,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int Rows, Columns;
    int R, C;
    int DistR, DistC;
    FindTile(board, tile, &Rows, &Columns);
    FindTile(board, -1, &R, &C);
    
    DistC = Columns - C;
    DistR = Rows - R;
    
if ((DistR <= -1 || DistR >= 1) && (DistC <= -1 || DistC >= 1))
{
    int Temporary = board[Rows][Columns];
    board[R][C] = Temporary;
}
    else
    {
        return;
    }
}",0
egho902,1696227138,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int Rows, Columns;
    int R, C;
    int DistR, DistC;
    FindTile(board, tile, &Rows, &Columns);
    FindTile(board, -1, &R, &C);
    
    DistC = Columns - C;
    DistR = Rows - R;
    
    if ((DistR >= -1 && DistR <= 1) && (DistC >= -1 && DistC <= 1)) {
        int Temporary = board[Rows][Columns];
        board[Rows][Columns] = board[R][C];
        board[R][C] = Temporary;
    } else {
        return;
    }
}",1
ehua682,1696209316,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol;
    int tileRow, tileCol;

    // Find the empty square positions and the tile
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);

   // Verifying whether the tile is positioned next to the empty square.
    if ((abs(emptyRow - tileRow) == 1 && emptyCol == tileCol) ||
        (abs(emptyCol - tileCol) == 1 && emptyRow == tileRow) ||
        (emptyRow == tileRow && emptyCol == tileCol - 1) ||
        (emptyRow == tileRow && emptyCol == tileCol + 1) ||
        (emptyCol == tileCol && emptyRow == tileRow - 1) ||
        (emptyCol == tileCol && emptyRow == tileRow + 1)) {
        // Swap the specified tile with the empty square
        int temp = board[emptyRow][emptyCol];
        board[emptyRow][emptyCol] = board[tileRow][tileCol];
        board[tileRow][tileCol] = temp;
    }
}
",1
ejeo051,1695980886,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    if (*cols > 0 && *cols < NUM_COLS) {
        if (board[*rows][*cols + 1] == -1) {
            board[*rows][*cols] = -1;
            board[*rows][*cols + 1] = tile;
            return;
            
        } else if (board[*rows][*cols - 1] == -1) {
            board[*rows][*cols] = -1;
            board[*rows][*cols - 1] = tile;
            return;
            
        } else {
            return;
        }
    
    } 
    
    
    else if (*cols == 0) {
        if (board[*rows][*cols + 1] == -1) {
            board[*rows][*cols] = -1;
            board[*rows][*cols + 1] = tile;
            return;
            
        } else {
            return;
        }
        
    }
    
    else if (*cols == NUM_COLS) {
        if (board[*rows][*cols - 1] == -1) {
            board[*rows][*cols] = -1;
            board[*rows][*cols - 1] = tile;
            return;
            
        } else {
            return;
        }
        
    }
    
    if (*rows > 0 && *rows < NUM_ROWS) {
        if (board[*rows + 1][*cols] == -1) {
            board[*rows][*cols] = -1;
            board[*rows + 1][*cols] = tile;
            return;
            
        } else if (board[*rows - 1][*cols] == -1) {
            board[*rows][*cols] = -1;
            board[*rows - 1][*cols] = tile;
            return
            
        } else {
            return;
        }
    }
    
    else if (*rows == 0) {
        if (board[*rows + 1][*cols] == -1) {
            board[*rows][*cols] = -1;
            board[*rows + 1][*cols] = tile;
            return;
            
        } else {
            return;
        }
        
    }
    
    else if (*rows == NUM_ROWS) {
        if (board[*rows - 1][*cols] == -1) {
            board[*rows][*cols] = -1;
            board[*rows - 1][*cols] = tile;
            return;
            
        } else {
            return;
        }
        
    }

}",0
ejeo051,1695981951,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    if (*colPos > 0 && *colPos < NUM_COLS) {
        if (board[*rowPos][*colPos + 1] == -1) {
            board[*rowPos][*colPos] = -1;
            board[*rowPos][*colPos + 1] = tile;
            return;
            
        } else if (board[*rowPos][*colPos - 1] == -1) {
            board[*rowPos][*colPos] = -1;
            board[*rowPos][*colPos - 1] = tile;
            return;
            
        } else {
            return;
        }
    
    } 
    
    
    else if (*colPos == 0) {
        if (board[*rowPos][*colPos + 1] == -1) {
            board[*rowPos][*colPos] = -1;
            board[*rowPos][*colPos + 1] = tile;
            return;
            
        } else {
            return;
        }
        
    }
    
    else if (*colPos == NUM_COLS) {
        if (board[*rowPos][*colPos - 1] == -1) {
            board[*rowPos][*colPos] = -1;
            board[*rowPos][*colPos - 1] = tile;
            return;
            
        } else {
            return;
        }
        
    }
    
    if (*rowPos > 0 && *rowPos < NUM_ROWS) {
        if (board[*rowPos + 1][*colPos] == -1) {
            board[*rowPos][*colPos] = -1;
            board[*rowPos + 1][*colPos] = tile;
            return;
            
        } else if (board[*rowPos - 1][*colPos] == -1) {
            board[*rowPos][*colPos] = -1;
            board[*rowPos - 1][*colPos] = tile;
            return
            
        } else {
            return;
        }
    }
    
    else if (*rowPos == 0) {
        if (board[*rowPos + 1][*colPos] == -1) {
            board[*rowPos][*colPos] = -1;
            board[*rowPos + 1][*colPos] = tile;
            return;
            
        } else {
            return;
        }
        
    }
    
    else if (*rowPos == NUM_ROWS) {
        if (board[*rowPos - 1][*colPos] == -1) {
            board[*rowPos][*colPos] = -1;
            board[*rowPos - 1][*colPos] = tile;
            return;
            
        } else {
            return;
        }
        
    }

}",0
ejeo051,1696154526,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int colPos, rowPos;
    FindTile(board, -1, &rowPos, &colPos);
    
    if (colPos > 0 && colPos < NUM_COLS) {
        if (board[rowPos][colPos + 1] == -1) {
            board[rowPos][colPos] = -1;
            board[rowPos][colPos + 1] = tile;
            return;
            
        } else if (board[rowPos][colPos - 1] == -1) {
            board[rowPos][colPos] = -1;
            board[rowPos][colPos - 1] = tile;
            return;
            
        } else {
            return;
        }
    
    } 
    
    
    else if (colPos == 0) {
        if (board[rowPos][colPos + 1] == -1) {
            board[rowPos][colPos] = -1;
            board[rowPos][colPos + 1] = tile;
            return;
            
        } else {
            return;
        }
        
    }
    
    else if (colPos == NUM_COLS) {
        if (board[rowPos][colPos - 1] == -1) {
            board[rowPos][colPos] = -1;
            board[rowPos][colPos - 1] = tile;
            return;
            
        } else {
            return;
        }
        
    }
    
    if (rowPos > 0 && rowPos < NUM_ROWS) {
        if (board[rowPos + 1][colPos] == -1) {
            board[rowPos][colPos] = -1;
            board[rowPos + 1][colPos] = tile;
            return;
            
        } else if (board[rowPos - 1][colPos] == -1) {
            board[rowPos][colPos] = -1;
            board[rowPos - 1][colPos] = tile;
            return;
            
        } else {
            return;
        }
    }
    
    else if (rowPos == 0) {
        if (board[rowPos + 1][colPos] == -1) {
            board[rowPos][colPos] = -1;
            board[rowPos + 1][colPos] = tile;
            return;
            
        } else {
            return;
        }
        
    }
    
    else if (rowPos == NUM_ROWS) {
        if (board[rowPos - 1][colPos] == -1) {
            board[rowPos][colPos] = -1;
            board[rowPos - 1][colPos] = tile;
            return;
            
        } else {
            return;
        }
        
    }

}",0
ejeo051,1696156176,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int colPos, rowPos;
    FindTile(board, tile, &rowPos, &colPos);
    
    if (board[rowPos + 1][colPos] == -1 && rowPos + 1 < NUM_ROWS) {
        board[rowPos + 1][colPos] = tile;
        board[rowPos][colPos] = -1;
        return;
        
    } else if (board[rowPos - 1][colPos] == -1 && rowPos - 1 >= 0) {
        board[rowPos - 1][colPos] = tile;
        board[rowPos][colPos] = -1;
        return;
        
    } else if (colPos + 1 < NUM_COLS && board[rowPos][colPos + 1] == -1) {
        board[rowPos][colPos + 1] = tile;
        board[rowPos][colPos] = -1;
        return;
        
    } else if (colPos - 1 >= 0 && board[rowPos][colPos - 1] == -1) {
            // Move the tile to the left
            board[rowPos][colPos - 1] = tile;
            board[rowPos][colPos] = -1;
            return;
    }
}",1
ejeo051,1696156210,5,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int colPos, rowPos;
    FindTile(board, tile, &rowPos, &colPos);
    
    if (board[rowPos + 1][colPos] == -1 && rowPos + 1 < NUM_ROWS) {
        board[rowPos + 1][colPos] = tile;
        board[rowPos][colPos] = -1;
        return;
        
    } else if (board[rowPos - 1][colPos] == -1 && rowPos - 1 >= 0) {
        board[rowPos - 1][colPos] = tile;
        board[rowPos][colPos] = -1;
        return;
        
    } else if (colPos + 1 < NUM_COLS && board[rowPos][colPos + 1] == -1) {
        board[rowPos][colPos + 1] = tile;
        board[rowPos][colPos] = -1;
        return;
        
    } else if (colPos - 1 >= 0 && board[rowPos][colPos - 1] == -1) {
            board[rowPos][colPos - 1] = tile;
            board[rowPos][colPos] = -1;
            return;
    }
}",1
ejeo051,1696156248,6,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int colPos, rowPos;
    FindTile(board, tile, &rowPos, &colPos);
    
    if (board[rowPos + 1][colPos] == -1 && rowPos + 1 < NUM_ROWS) {
        board[rowPos + 1][colPos] = tile;
        board[rowPos][colPos] = -1;
        return;
        
    } else if (board[rowPos - 1][colPos] == -1 && rowPos - 1 >= 0) {
        board[rowPos - 1][colPos] = tile;
        board[rowPos][colPos] = -1;
        return;
        
    } else if (colPos + 1 < NUM_COLS && board[rowPos][colPos + 1] == -1) {
        board[rowPos][colPos + 1] = tile;
        board[rowPos][colPos] = -1;
        return;
        
    } else if (colPos - 1 >= 0 && board[rowPos][colPos - 1] == -1) {
        board[rowPos][colPos - 1] = tile;
        board[rowPos][colPos] = -1;
        return;
    }
}",1
ekmu195,1695644551,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{	
	int num_row = 0, num_col = 0;
	int space_row = 0, space_col = 0;
	int row = 0, col = 0;
	int number;

	FindTile(board, tile, &num_row, &num_col);
	FindTile(board, -1, &space_row, &space_col);

	row = ((num_row - 1 == space_row) || (num_row == space_row) || (num_row + 1 == space_row));
	col = ((num_col - 1 == space_col) || (num_col == space_col) || (num_col + 1 == space_col));

	if (row && col) {
		number = board[num_row][num_col];
		board[num_row][num_col] = board[space_row][space_col];
		board[space_row][space_col] = number;

	}


}",1
elau447,1696103985,1,"#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

/* The dimensions of the puzzle */
#define NUM_ROWS 4
#define NUM_COLS 4


void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int x = 0;
	int y = 0;
	for (int i = 0; i < NUM_ROWS; i++) {
		for (int j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == tile) {
				y = i;
				x = j;

			}


		}
	}
	if (x > 0) {
		if (board[y][x-1] == -1) {
			board[y][x-1] = board[y][x];
			board[y][x] = -1;
		}
	}
	if (x < NUM_COLS) {
		if (board[y][x + 1] == -1) {
			board[y][x + 1] = board[y][x];
			board[y][x] = -1;
		}
	}
	if (y > 0) {
		if (board[y-1][x] == -1) {
			board[y-1][x] = board[y][x];
			board[y][x] = -1;
		}
	}
	if (y < NUM_ROWS) {
		if (board[y+1][x] == -1) {
			board[y+1][x] = board[y][x];
			board[y][x] = -1;
		}
	}
}",1
eles952,1696235715,1,"/******************************************************************************

Welcome to GDB Online.
GDB online is an online compiler and debugger tool for C, C++, Python, Java, PHP, Ruby, Perl,
C#, OCaml, VB, Swift, Pascal, Fortran, Haskell, Objective-C, Assembly, HTML, CSS, JS, SQLite, Prolog.
Code, Compile, Run and Debug online from anywhere in world.

*******************************************************************************/
#include <stdio.h>

void MakeMove(int board[4][4], int tile)
{
int temp;
int space = -1;
int rowPos;
int colPos;
int rowPosTwo;
int colPosTwo;
 FindTile(board, space, &rowPos, &colPos);
 FindTile(board, tile, &rowPosTwo, &colPosTwo);
 
         if (rowPos - rowPosTwo == 1 || rowPos - rowPosTwo == -1){
             if (colPos - colPosTwo == 1 || colPos - colPosTwo == -1){
                 
          board[rowPos][colPos] = tile;
          board[rowPosTwo][colPosTwo] = -1;
             }
         }
}


",0
eles952,1696235736,2,"/******************************************************************************

Welcome to GDB Online.
GDB online is an online compiler and debugger tool for C, C++, Python, Java, PHP, Ruby, Perl,
C#, OCaml, VB, Swift, Pascal, Fortran, Haskell, Objective-C, Assembly, HTML, CSS, JS, SQLite, Prolog.
Code, Compile, Run and Debug online from anywhere in world.

*******************************************************************************/
#include <stdio.h>

void MakeMove(int board[4][4], int tile)
{
int space = -1;
int rowPos;
int colPos;
int rowPosTwo;
int colPosTwo;
 FindTile(board, space, &rowPos, &colPos);
 FindTile(board, tile, &rowPosTwo, &colPosTwo);
 
         if (rowPos - rowPosTwo == 1 || rowPos - rowPosTwo == -1){
             if (colPos - colPosTwo == 1 || colPos - colPosTwo == -1){
                 
          board[rowPos][colPos] = tile;
          board[rowPosTwo][colPosTwo] = -1;
             }
         }
}


",0
eles952,1696236005,3,"/******************************************************************************

Welcome to GDB Online.
GDB online is an online compiler and debugger tool for C, C++, Python, Java, PHP, Ruby, Perl,
C#, OCaml, VB, Swift, Pascal, Fortran, Haskell, Objective-C, Assembly, HTML, CSS, JS, SQLite, Prolog.
Code, Compile, Run and Debug online from anywhere in world.

*******************************************************************************/
#include <stdio.h>

void MakeMove(int board[4][4], int tile)
{
int space = -1;
int rowPos;
int colPos;
int rowPosTwo;
int colPosTwo;
 FindTile(board, space, &rowPos, &colPos);
 FindTile(board, tile, &rowPosTwo, &colPosTwo);
 
         if (abs(rowPos - rowPosTwo == 1)){
             if (abs(colPos - colPosTwo == 1)){
                 
          board[rowPos][colPos] = tile;
          board[rowPosTwo][colPosTwo] = -1;
             }
         }
}


",0
eles952,1696236214,4,"/******************************************************************************

Welcome to GDB Online.
GDB online is an online compiler and debugger tool for C, C++, Python, Java, PHP, Ruby, Perl,
C#, OCaml, VB, Swift, Pascal, Fortran, Haskell, Objective-C, Assembly, HTML, CSS, JS, SQLite, Prolog.
Code, Compile, Run and Debug online from anywhere in world.

*******************************************************************************/
#include <stdio.h>

void MakeMove(int board[4][4], int tile)
{
int space = -1;
int rowPos;
int colPos;
int rowPosTwo;
int colPosTwo;
 FindTile(board, space, &rowPos, &colPos);
 FindTile(board, tile, &rowPosTwo, &colPosTwo);
 
          if ((abs(rowPos - rowPosTwo) == 1 && colPos == colPosTwo) ||
        (abs(colPos - colPosTwo) == 1 && rowCol == rowColTwo)) {
                 
          board[rowPos][colPos] = tile;
          board[rowPosTwo][colPosTwo] = -1;
             }
         }
}


",0
eles952,1696236268,5,"/******************************************************************************

Welcome to GDB Online.
GDB online is an online compiler and debugger tool for C, C++, Python, Java, PHP, Ruby, Perl,
C#, OCaml, VB, Swift, Pascal, Fortran, Haskell, Objective-C, Assembly, HTML, CSS, JS, SQLite, Prolog.
Code, Compile, Run and Debug online from anywhere in world.

*******************************************************************************/
#include <stdio.h>

void MakeMove(int board[4][4], int tile)
{
int space = -1;
int rowPos;
int colPos;
int rowPosTwo;
int colPosTwo;
 FindTile(board, space, &rowPos, &colPos);
 FindTile(board, tile, &rowPosTwo, &colPosTwo);
 
          if ((abs(rowPos - rowPosTwo) == 1 && colPos == colPosTwo) ||
        (abs(colPos - colPosTwo) == 1 && rowPos == rowPosTwo)) {
                 
          board[rowPos][colPos] = tile;
          board[rowPosTwo][colPosTwo] = -1;
             }
         }
}


",0
eles952,1696236290,6,"/******************************************************************************

Welcome to GDB Online.
GDB online is an online compiler and debugger tool for C, C++, Python, Java, PHP, Ruby, Perl,
C#, OCaml, VB, Swift, Pascal, Fortran, Haskell, Objective-C, Assembly, HTML, CSS, JS, SQLite, Prolog.
Code, Compile, Run and Debug online from anywhere in world.

*******************************************************************************/
#include <stdio.h>

void MakeMove(int board[4][4], int tile)
{
int space = -1;
int rowPos;
int colPos;
int rowPosTwo;
int colPosTwo;
 FindTile(board, space, &rowPos, &colPos);
 FindTile(board, tile, &rowPosTwo, &colPosTwo);
 
          if ((abs(rowPos - rowPosTwo) == 1 && colPos == colPosTwo) ||
        (abs(colPos - colPosTwo) == 1 && rowPos == rowPosTwo)) {
                 
          board[rowPos][colPos] = tile;
          board[rowPosTwo][colPosTwo] = -1;
             }
         }



",1
elia955,1696238390,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRow, tileCol;
    int emptyRow, emptyCol;

    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol);

    if ((tileRow == emptyRow && (tileCol == emptyCol - 1 || tileCol == emptyCol + 1)) ||
        (tileCol == emptyCol && (tileRow == emptyRow - 1 || tileRow == emptyRow + 1))) {
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
    else {
        printf(""Cannot move tile %d\n"", tile);
    }
}",0
elia955,1696238507,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRow, tileCol;
    int emptyRow, emptyCol;

    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol);

    if ((tileRow == emptyRow && (tileCol == emptyCol - 1 || tileCol == emptyCol + 1)) ||
        (tileCol == emptyCol && (tileRow == emptyRow - 1 || tileRow == emptyRow + 1))) {
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
    else {
        return;
    }
}",1
else264,1696213415,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    
    int row, col, gap_row, gap_col;
    
    FindTile(board, tile, &row, &col);
    FindTile(board, -1, &gap_row, &gap_col);
    
    if (col-gap_col==0 && (row-gap_row==-1 || row-gap_row==1)){
        board[row][col]=-1;
        board[gap_row][gap_col]=tile;
    }
    else if (row-gap_row==0 && (col-gap_col==-1 || col-gap_col==1)){
        board[row][col]=-1;
        board[gap_row][gap_col]=tile;
    }
    else {
        
    }

}",1
ely207,1695697310,1,"// MakeMove moves the tiles if its a valid move
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowblank, colblank;
	int rownum, colnum;

	 //Identifying the location of the blank and tile position
	FindTile(board, -1, &rowblank, &colblank);
	FindTile(board, tile, &rownum, &colnum);

	if (rowblank + 1 == rownum && colblank == colnum) // if blank is above
	{
		board[rowblank][colblank] = board[rownum][colnum];
		board[rownum][colnum] = -1;
	} 
	else if(colblank + 1 == colnum && rowblank == rownum) // if blank is left
	{
		board[rowblank][colblank] = board[rownum][colnum];
		board[rownum][colnum] = -1;
	} 
	else if (rowblank - 1 == rownum && colblank == colnum) // if blank is below
	{
		board[rowblank][colblank] = board[rownum][colnum];
		board[rownum][colnum] = -1;
	} 
	else if (colblank - 1 == colnum && rowblank == rownum) // if blank is right
	{
		board[rowblank][colblank] = board[rownum][colnum];
		board[rownum][colnum] = -1;
	}

}",1
ema340,1695998115,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowEmpty, colEmpty;
	FindTile(board, -1, &rowEmpty, &colEmpty);

	int swapRow, swapCol;
	FindTile(board, tile, &swapRow, &swapCol);

	if (swapRow == rowEmpty || swapCol == colEmpty) {
		if (swapRow == rowEmpty+1 || swapRow == rowEmpty-1 || swapRow == rowEmpty) {	
			if (swapCol == colEmpty+1 || swapCol == colEmpty-1 || swapCol == colEmpty) {
				board[rowEmpty][colEmpty] = tile;
				board[swapRow][swapCol] = -1;
			}
		}
	}
}",1
emah834,1695868942,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int i;
    int j; 
    int emptyi;
    int emptyj;
    
    FindTile(board,-1, &emptyi, &emptyj);
    FindTile(board, tile, &i, &j);
        if( emptyj == j && ((i - emptyi == 1) || (i - emptyi == -1))){
            board[emptyi][emptyj] = board[i][j];
            board[i][j] = -1;
        }
        if( emptyi == i && ((j - emptyj == 1) || (j - emptyj == -1))){
            board[emptyi][emptyj] = board[i][j];
            board[i][j] = -1;
        }
}",1
emah921,1696119732,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) 
{
    int tileRow, tileCol, emptyRow, emptyCol;

    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol);

        board[tileRow][tileCol] = -1;
        board[emptyRow][emptyCol] = tile;
   
}",0
emar189,1696233288,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS],int tile) {
    int Row1,Col1;
    int Row2,Col2;
    int i;
    int Row3[4];
    int Col3[4];

    Row3[0]=0;
    Row3[1]=0; 
    Row3[2]=-1; 
    Row3[3]=1;
    
    Col3[0]=-1; 
    Col3[1] =1; 
    Col3[2]=0; 
    Col3[3]=0;

    FindTile(board,tile,&Row1,&Col1);
    FindTile(board,-1,&Row2,&Col2);

    i=0;
    while(i<4) {
        int NewRow=Row2+Row3[i];
        int NewCol=Col2+Col3[i];
        if(Row1==NewRow && Col1==NewCol) {
            board[Row2][Col2]=tile;
            board[Row1][Col1]=-1;
            break;
        }
        i=i+1;
    }
}",1
eqiu349,1695961443,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
	int rowtile, coltile, rowgap, colgap;
	FindTile(board, tile, &rowtile, &coltile);
	FindTile(board, -1, &rowgap, &colgap);


	if (rowtile == rowgap) {
		if (coltile == colgap + 1) {
			board[rowgap][colgap] = tile;
			board[rowtile][coltile] = -1;
		}
		else if (coltile == colgap - 1) {
			board[rowgap][colgap] = tile;
			board[rowtile][coltile] = -1;
		}
	}

if (rowtile - rowgap == 1) {
	if (coltile == colgap) {
		board[rowgap][colgap] = tile;
		board[rowtile][coltile] = -1;
	}
	else if (rowtile == rowgap) {
		board[rowgap][colgap] = tile;
		board[rowtile][coltile] = -1;
	}
}


	if (rowtile - rowgap == -1) {
		if (coltile == colgap) {
			board[rowgap][colgap] = tile;
			board[rowtile][coltile] = -1;
		}
		else if (rowtile == rowgap) {
			board[rowgap][colgap] = tile;
			board[rowtile][coltile] = -1;
		}
	}
}",1
eteo952,1695952753,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowPos, colPos;
    int moveRow, moveCol;

    FindTile(board, -1, &rowPos, &colPos);
    FindTile(board, tile, &moveRow, &moveCol);

    int rDiff = moveRow - rowPos;
    int cDiff = moveCol - colPos;

    if ((rDiff == 0 && (cDiff == 1 || cDiff == -1)) ||
        (cDiff == 0 && (rDiff == 1 || rDiff == -1))) {

        board[rowPos][colPos] = tile;
        board[moveRow][moveCol] = -1;
    }

}",1
evic904,1696138382,1,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int xRow, xCol;
	int tileRow, tileCol;

	// Obtain position of empty square
	FindTile(board, -1, &xRow, &xCol);

	// Find where the tile should be moved to
	FindTile(board, tile, &tileRow, &tileCol);

	if ((tileRow == xRow && (tileCol == xCol - 1 || tileCol == xCol + 1)) || (tileCol == xCol && (tileRow == xRow - 1 || tileRow == xRow + 1)))
	{
		int x = board[xRow][xCol];
		board[xRow][xCol] = board[tileRow][tileCol];
		board[tileRow][tileCol] = x;
	}



}
",1
ewil853,1695986190,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;
FindTile(board, -1, &row, &col);
for (int i =0;i<NUM_ROWS;i++){

	for (int j=0; j<NUM_COLS;j++){
		if (board[i][j] == tile){
			if(((i - row == 1) || (i - row == -1)) && ((j - col == 1) || (j - col == -1))){
                board[i][j] = tile;
				board[row][col] = -1;
			}
			else if ((i - row == 1) && (j == col)) {
                board[row][col] = board[i][j];
				board[i][j] = -1;

			}
			else if ((i - row == -1) && (j == col)){
                board[row][col] = board[i][j];
				board[i][j] = -1;
			}
			else if ((j - col == 1) && (i == row)){
				board[row][col] = board[i][j];
				board[i][j] = -1;

            }
			else if ((j - col == -1) && (i==row)){
			    board[row][col] = board[i][j];
				board[i][j] = -1;
		}
		
	}
}

}
}",1
exu922,1696243436,1,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos) {
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == tile) {
                *rowPos = i;
                *colPos = j;
                return;
            }
        }
    }
    *rowPos = -1;
    *colPos = -1;
}

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol, tileRow, tileCol;
    FindTile(board, -1, &emptyRow, &emptyCol); 
    FindTile(board, tile, &tileRow, &tileCol); 

    if ((emptyRow == tileRow && abs(emptyCol - tileCol) == 1) || 
        (emptyCol == tileCol && abs(emptyRow - tileRow) == 1)) {
        
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}

void PrintBoard(int board[NUM_ROWS][NUM_COLS]) {
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == -1) {
                printf(""_  "");
            } else {
                printf(""%d  "", board[i][j]);
            }
        }
        printf(""\n"");
    }
}",0
exu922,1696243935,2,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

// The FindTile function
void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos) {
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == tile) {
                *rowPos = i;
                *colPos = j;
                return;
            }
        }
    }
    *rowPos = -1;
    *colPos = -1;
}

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol, tileRow, tileCol;
    FindTile(board, -1, &emptyRow, &emptyCol); // Find the empty tile (-1)
    FindTile(board, tile, &tileRow, &tileCol); // Find the tile to be moved

    // Check if the tile to be moved is adjacent to the empty tile
    if ((emptyRow == tileRow && abs(emptyCol - tileCol) == 1) || 
        (emptyCol == tileCol && abs(emptyRow - tileRow) == 1)) {
        
        // Swap the tiles
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}

void PrintBoard(int board[NUM_ROWS][NUM_COLS]) {
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == -1) {
                printf(""_  "");
            } else {
                printf(""%d  "", board[i][j]);
            }
        }
        printf(""\n"");
    }
}",0
exu922,1696244334,3,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

// The FindTile function
void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos) {
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == tile) {
                *rowPos = i;
                *colPos = j;
                return;
            }
        }
    }
    *rowPos = -1;
    *colPos = -1;
}

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol, tileRow, tileCol;
    FindTile(board, -1, &emptyRow, &emptyCol); // Find the empty tile (-1)
    FindTile(board, tile, &tileRow, &tileCol); // Find the tile to be moved

    // Check if the tile to be moved is adjacent to the empty tile
    if ((emptyRow == tileRow && abs(emptyCol - tileCol) == 1) || 
        (emptyCol == tileCol && abs(emptyRow - tileRow) == 1)) {
        
        // Swap the tiles
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}

void PrintBoard(int board[NUM_ROWS][NUM_COLS]) {
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == -1) {
                printf("" _ "");
            } else if (board[i][j] < 10) {
                printf("" %d "", board[i][j]);
            } else {
                printf(""%d "", board[i][j]);
            }
        }
        printf(""\n"");
    }
}",0
eyeo346,1696164733,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int i, j, row = 0, col = 0;
    for (i = 0; i < NUM_ROWS; i++) {
        for (j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == tile) {
                row = i;
                col = j;
            }
        }
    }
    
    // find adjacent tiles and see if they are empty (-1)
    int a = board[row+1][col];//below
    int b = board[row-1][col];//above
    int c = board[row][col+1];//right
    int d = board[row][col-1];//left
    
    if (a == -1 | b == -1 | c == -1 | d == -1) {
        int e, f, rowPos = 0, colPos = 0;
        for (e = 0; e < NUM_ROWS; e++) {
            for (f = 0; f < NUM_COLS; f++) {
                if (board[e][f] == -1) {
                    rowPos = e;
                    colPos = f;
                    board[rowPos][colPos] = tile;
                    board[row][col] = -1;
                }
            }
        }
    }
    
}",0
eyeo346,1696164949,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int i, j, row = 0, col = 0;
    for (i = 0; i < NUM_ROWS; i++) {
        for (j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == tile) {
                row = i;
                col = j;
            }
        }
    }
    
    // find adjacent tiles and see if they are empty (-1)
    int a = board[row+1][col];//below
    int b = board[row-1][col];//above
    int c = board[row][col+1];//right
    int d = board[row][col-1];//left
    
    if ((a == -1) | (b == -1) | (c == -1) | (d == -1)) {
        int e, f, rowPos = 0, colPos = 0;
        for (e = 0; e < NUM_ROWS; e++) {
            for (f = 0; f < NUM_COLS; f++) {
                if (board[e][f] == -1) {
                    rowPos = e;
                    colPos = f;
                    board[rowPos][colPos] = tile;
                    board[row][col] = -1;
                }
            }
        }
    }
    
}",0
eyeo346,1696199969,3,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int i, j, row = 0, col = 0;
    for (i = 0; i < NUM_ROWS; i++) {
        for (j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == tile) {
                row = i;
                col = j;
            }
        }
    }
    
    // find adjacent tiles and see if they are empty (-1)
    int a = board[row+1][col];//below
    int b = board[row-1][col];//above
    int c = board[row][col+1];//right
    int d = board[row][col-1];//left
    if (row == 0 && col < 3 && col > 0) {
        if ((a == -1) | (c == -1) | (d == -1)) {
            int e, f, rowPos = 0, colPos = 0;
            for (e = 0; e < NUM_ROWS; e++) {
                for (f = 0; f < NUM_COLS; f++) {
                    if (board[e][f] == -1) {
                        rowPos = e;
                        colPos = f;
                        board[rowPos][colPos] = tile;
                        board[row][col] = -1;
                    }
                }
            }
        }
    }
    
    if (row == 3 && col < 3 && col > 0) {
        if ((b == -1) | (c == -1) | (d == -1)) {
            int e, f, rowPos = 0, colPos = 0;
            for (e = 0; e < NUM_ROWS; e++) {
                for (f = 0; f < NUM_COLS; f++) {
                    if (board[e][f] == -1) {
                        rowPos = e;
                        colPos = f;
                        board[rowPos][colPos] = tile;
                        board[row][col] = -1;
                    }
                }
            }
        }
    }
    if (col == 0) {
        if ((a == -1) | (b == -1) | (c == -1)) {
            int e, f, rowPos = 0, colPos = 0;
            for (e = 0; e < NUM_ROWS; e++) {
                for (f = 0; f < NUM_COLS; f++) {
                    if (board[e][f] == -1) {
                        rowPos = e;
                        colPos = f;
                        board[rowPos][colPos] = tile;
                        board[row][col] = -1;
                    }
                }
            }
        }
    }
    if (col == 3) {
        if ((a == -1) | (b == -1) | (d == -1)) {
            int e, f, rowPos = 0, colPos = 0;
            for (e = 0; e < NUM_ROWS; e++) {
                for (f = 0; f < NUM_COLS; f++) {
                    if (board[e][f] == -1) {
                        rowPos = e;
                        colPos = f;
                        board[rowPos][colPos] = tile;
                        board[row][col] = -1;
                    }
                }
            }
        }
    }
    if (col > 0 && row > 0 && col < 3 && row < 3) {
        if ((a == -1) | (b == -1) | (c == -1) | (d == -1)) {
            int e, f, rowPos = 0, colPos = 0;
            for (e = 0; e < NUM_ROWS; e++) {
                for (f = 0; f < NUM_COLS; f++) {
                    if (board[e][f] == -1) {
                        rowPos = e;
                        colPos = f;
                        board[rowPos][colPos] = tile;
                        board[row][col] = -1;
                    }
                }
            }
        }
    }
   
}",1
fcoo305,1696163670,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j, k;

	for (i = 0; i < NUM_ROWS; i++)
	{
		for (j = 0; j < NUM_COLS; j++)
		{
			if (board[i][j] == tile)
			{
				for (k = 0; k < 4; k++)
				{
					int colMod = 0;
					int rowMod = 0;

					if (k == 0)
					{
						colMod = 1;
					}
					if (k == 1)
					{
						colMod = -1;
					}
					if (k == 2)
					{
						rowMod = 1;
					}
					if (k == 3)
					{
						rowMod = -1;
					}
					if (0 <= i + rowMod < NUM_ROWS && 0 <= j + colMod < NUM_COLS)
					{
						if (board[i + rowMod][j + colMod] == -1)
						{
							board[i + rowMod][j + colMod] = board[i][j];
							board[i][j] = -1;
						}
					}
				}
			}
		}
	}
}",0
fcoo305,1696218364,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j, k;

	for (i = 0; i < NUM_ROWS; i++)
	{
		for (j = 0; j < NUM_COLS; j++)
		{
			if (board[i][j] == tile)
			{
				for (k = 0; k < 4; k++)
				{
					int colMod = 0;
					int rowMod = 0;

					if (k == 0)
					{
						colMod = 1;
					}
					if (k == 1)
					{
						colMod = -1;
					}
					if (k == 2)
					{
						rowMod = 1;
					}
					if (k == 3)
					{
						rowMod = -1;
					}
					if (0 <= i + rowMod < NUM_ROWS && 0 <= j + colMod < NUM_COLS)
					{
						if (board[i + rowMod][j + colMod] == -1)
						{
							board[i + rowMod][j + colMod] = board[i][j];
							board[i][j] = -1;
							k = 4;
							i = NUM_ROWS;
							j = NUM_COLS;
						}
					}
				}
			}
		}
	}
}",0
fcoo305,1696218623,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j, k;

	for (i = 0; i < NUM_ROWS; i++)
	{
		for (j = 0; j < NUM_COLS; j++)
		{
			if (board[i][j] == tile)
			{
				for (k = 0; k < 4; k++)
				{
					int colMod = 0;
					int rowMod = 0;

					if (k == 0)
					{
						colMod = 1;
					}
					if (k == 1)
					{
						colMod = -1;
					}
					if (k == 2)
					{
						rowMod = 1;
					}
					if (k == 3)
					{
						rowMod = -1;
					}
					if ((0 <= (i + rowMod)) && ((i + rowMod) < NUM_ROWS) && (0 <= (j + colMod)) && ((j + colMod) < NUM_COLS))
					{
						if (board[i + rowMod][j + colMod] == -1)
						{
							board[i + rowMod][j + colMod] = board[i][j];
							board[i][j] = -1;
							k = 4;
							i = NUM_ROWS;
							j = NUM_COLS;
						}
					}
				}
			}
		}
	}
}",1
fesp714,1695883128,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyR, emptyC;
    int tileR, tileC;
    
    // Finding the empty(-1) tile position
    FindTile(board, -1, &emptyR, &emptyC);
    
    // Finding the wanted tile position
    FindTile(board, tile, &tileR, &tileC);
    
    // Checking if the empty tile is next to/adjacent to the selected tile, swapping can happen.
    if (( tileR == emptyR && (tileC == emptyC - 1 || tileC == emptyC + 1)) || (tileC == emptyC && (tileR == emptyR - 1 || tileR == emptyR 
    +1))) {
        // Swapping the positions of the empty tile with the selected tile if conditions are met 
        int store = board[emptyR][emptyC];
        board[emptyR][emptyC] = board[tileR][tileC];
        board[tileR][tileC] = store;
    }
}",1
fgor787,1696231804,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyROW, emptyCOL, tileROW, tileCOL;
    

    FindTile(board, &emptyROW, &emptyCOL);
    FindTile(board, tile, &tileROW, &tileCOL);

    if ((emptyROW - tileROW == 1 && emptyCOL == tileCOL) ||
        (emptyROW - tileROW == -1 && emptyCOL == tileCOL) ||
        (emptyROW == tileROW && emptyCOL - tileCOL == 1) ||
        (emptyROW == tileROW && emptyCOL - tileCOL == -1)) 
        {
        int temp = board[emptyRow][emptyCOL];
        board[emptyROW][emptyCOL] = board[tileROW][tileCOL];
        board[tileROW][tileCOL] = temp;
        }
        return 0;
}",0
fgor787,1696233048,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyROW, emptyCOL, tileROW, tileCOL;
    

    FindTile(board, -1, &emptyROW, &emptyCOL);
    FindTile(board, tile, &tileROW, &tileCOL);

    if ((emptyROW - tileROW == 1 && emptyCOL == tileCOL) ||
        (emptyROW - tileROW == -1 && emptyCOL == tileCOL) ||
        (emptyROW == tileROW && emptyCOL - tileCOL == 1) ||
        (emptyROW == tileROW && emptyCOL - tileCOL == -1)) 
        {
        int temp = board[emptyRow][emptyCOL];
        board[emptyROW][emptyCOL] = board[tileROW][tileCOL];
        board[tileROW][tileCOL] = temp;
        }
        return 0;
}",0
fkee774,1695989216,1,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {

    int emptyRowPos, emptyColPos, tileRowPos, tileColPos;
    FindTile(board, -1, &emptyRowPos, &emptyColPos); 

    FindTile(board, tile, &tileRowPos, &tileColPos); 

    int rowMargin = tileRowPos - emptyRowPos); 

    int rowMargin = tileColPosPos - emptyColPos); 

    if ((rowMargin == 1 || rowMargin == -1) && rowMargin == 0) {
        board[emptyRowPos][emptyColPos] = tile;
        board[tileRowPos][tileColPos] = -1;
    } 
    else if (rowMargin == 0 && (rowMargin == 1 || rowMargin == -1)) {
        board[emptyRowPos][emptyColPos] = tile;
        board[tileRowPos][tileColPos] = -1;
    }
}",0
fkee774,1695989376,2,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {

    int emptyRowPos, emptyColPos, tileRowPos, tileColPos;
    FindTile(board, -1, &emptyRowPos, &emptyColPos); 

    FindTile(board, tile, &tileRowPos, &tileColPos); 

    int rowMargin = tileRowPos - emptyRowPos; 

    int colMargin = tileColPosPos - emptyColPos; 

    if ((rowMargin == 1 || rowMargin == -1) && colMargin == 0) {
        board[emptyRowPos][emptyColPos] = tile;
        board[tileRowPos][tileColPos] = -1;
    } 
    else if ((colMargin == 1 || colMargin == -1) && rowMargin == 0) {
        board[emptyRowPos][emptyColPos] = tile;
        board[tileRowPos][tileColPos] = -1;
    }
}",0
fkee774,1695989411,3,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {

    int emptyRowPos, emptyColPos, tileRowPos, tileColPos;
    FindTile(board, -1, &emptyRowPos, &emptyColPos); 

    FindTile(board, tile, &tileRowPos, &tileColPos); 

    int rowMargin = tileRowPos - emptyRowPos; 

    int colMargin = tileColPos - emptyColPos; 

    if ((rowMargin == 1 || rowMargin == -1) && colMargin == 0) {
        board[emptyRowPos][emptyColPos] = tile;
        board[tileRowPos][tileColPos] = -1;
    } 
    else if ((colMargin == 1 || colMargin == -1) && rowMargin == 0) {
        board[emptyRowPos][emptyColPos] = tile;
        board[tileRowPos][tileColPos] = -1;
    }
}",1
fobr691,1696232848,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row, col;
    FindTile(board, tile, &row, &col);

    int emptyRow, emptyCol;
    FindTile(board, -1, &emptyRow, &emptyCol);

    if ((abs(row - emptyRow) == 1 && col == emptyCol) || 
        (row == emptyRow && abs(col - emptyCol) == 1)) {
        board[emptyRow][emptyCol] = tile;
        board[row][col] = -1;
    }
}",1
fwij709,1695632485,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowTile, colTile;
	int rowEmpty, colEmpty;
	FindTile(board, tile, &rowTile, &colTile);
	FindTile(board, -1, &rowEmpty, &colEmpty);
	if (((rowTile - rowEmpty) == 0) && (((colTile - colEmpty)>=-1) && ((colTile - colEmpty)<=1))) {
		board[rowTile][colTile] = -1;
		board[rowEmpty][colEmpty] = tile;
	}
	else if (((colTile - colEmpty) == 0) && (((rowTile - rowEmpty)>=-1) && ((rowTile - rowEmpty)<=1))) {
		board[rowTile][colTile] = -1;
		board[rowEmpty][colEmpty] = tile;
	}
}",1
fwil727,1696113269,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRow, tileCol, emptyRow, emptyCol;

    // Find the specified tile and the empty square
    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol);

    // Check if the tile can be moved (adjacent to the empty square)
    if ((tileRow == emptyRow && (tileCol == emptyCol - 1 || tileCol == emptyCol + 1)) ||
        (tileCol == emptyCol && (tileRow == emptyRow - 1 || tileRow == emptyRow + 1))) {
        // Swap the tile with the empty square
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}
",1
fyan180,1696235813,1,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowPos, colPos;
    FindTile(board, tile, &rowPos, &colPos);

    if (rowPos > 0 && board[rowPos - 1][colPos] == 0)
    {
        board[rowPos - 1][colPos] = tile;
        board[rowPos][colPos] = 0;
    }
    else if (rowPos < NUM_ROWS - 1 && board[rowPos + 1][colPos] == 0)
    {
        board[rowPos + 1][colPos] = tile;
        board[rowPos][colPos] = 0;
    }
    else if (colPos > 0 && board[rowPos][colPos - 1] == 0)
    {
        board[rowPos][colPos - 1] = tile;
        board[rowPos][colPos] = 0;
    }
    else if (colPos < NUM_COLS - 1 && board[rowPos][colPos + 1] == 0)
    {
        board[rowPos][colPos + 1] = tile;
        board[rowPos][colPos] = 0;
    }
}",0
fyan180,1696240250,2,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowPos, colPos;
    FindTile(board, tile, &rowPos, &colPos);

    if (rowPos > 0 && board[rowPos - 1][colPos] == -1)
    {
    board[rowPos - 1][colPos] == tile;
    board[rowPos][colPos] = -1;
    }

    if (rowPos < NUM_ROWS && board[rowPos + 1][colPos] == -1)
    {
    board[rowPos + 1][colPos] == tile;
    board[rowPos][colPos] = -1;
    }

    if (colPos > 0 && board[rowPos][colPos - 1] == -1)
    {
    board[rowPos][colPos - 1] == tile;
    board[rowPos][colPos] = -1;
    }

    if (colPos < NUM_COLS && board[rowPos][colPos + 1] == -1)
    {   
    board[rowPos][colPos + 1] == tile;
    board[rowPos][colPos] = -1;
    }

}",0
fyan180,1696242750,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowPos, colPos, rowPosn, colPosn;

    FindTile(board, tile, &rowPos, &colPos);
    FindTile(board, -1, &rowPosn, &colPosn);

    if ((rowPos + 1 == rowPosn) && (colPos == colPosn))
    {
    board[rowPosn][colPosn] = tile;
    board[rowPos][colPos] = -1;
    } else if ((rowPos - 1 == rowPosn) && (colPos == colPosn))
    {
    board[rowPosn][colPosn] = tile;
    board[rowPos][colPos] = -1;
    } else if ((rowPos == rowPosn) && (colPos - 1 == colPosn))
    {
    board[rowPosn][colPosn] = tile;
    board[rowPos][colPos] = -1;
    } else if ((rowPos == rowPosn) && (colPos + 1 == colPosn))
    {   
    board[rowPos][colPosn] = tile;
    board[rowPos][colPos] = -1;
    }

}",1
gcha636,1696139144,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {

    int rowPos, colPos, rowPos1, colPos1;

    FindTile(board, -1, &rowPos1, &colPos1);
    FindTile(board, tile, &rowPos, &colPos);

    if (rowPos + 1 >= rowPos1) {
        if (colPos1 == colPos) {

            board[rowPos][colPos] = -1;
            board[rowPos1][colPos1] = tile;

        }
    }

    if (rowPos - 1 >= rowPos1) {
        if (colPos1 == colPos) {

            board[rowPos][colPos] = -1;
            board[rowPos1][colPos1] = tile;

        }
    }

    if (colPos + 1 >= colPos1) {
        if (rowPos == rowPos1) {

            board[rowPos][colPos] = -1;
            board[rowPos1][colPos1] = tile;

        }

    }

    if (colPos + 1 >= colPos1) {
        if (rowPos == rowPos1) {

            board[rowPos][colPos] = -1;
            board[rowPos1][colPos1] = tile;

        }
    }
}",0
gcha636,1696140275,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {

    int rowPos, colPos, rowPos1, colPos1;

    FindTile(board, -1, &rowPos1, &colPos1);
    FindTile(board, tile, &rowPos, &colPos);

    if (rowPos + 1 == rowPos1) {
        if (colPos1 == colPos) {

            board[rowPos][colPos] = -1;
            board[rowPos1][colPos1] = tile;

        }
    }

    if (rowPos - 1 == rowPos1) {
        if (colPos1 == colPos) {

            board[rowPos][colPos] = -1;
            board[rowPos1][colPos1] = tile;

        }
    }

    if (colPos + 1 == colPos1) {
        if (rowPos == rowPos1) {

            board[rowPos][colPos] = -1;
            board[rowPos1][colPos1] = tile;

        }

    }

    if (colPos - 1 == colPos1) {
        if (rowPos == rowPos1) {

            board[rowPos][colPos] = -1;
            board[rowPos1][colPos1] = tile;

        }
    }
}
",1
ggao363,1695635404,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
int tileRow, tileCol, emptyRow, emptyCol;
    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol);
if(tileRow == emptyRow ^ tileCol == emptyCol){
    int temp = board[tileRow][tileCol];
    board[tileRow][tileCol] = -1;
    board[emptyRow][emptyCol] = temp;
}
}",0
ggao363,1695636126,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int tileRow, tileCol, emptyRow, emptyCol;
    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol);
    if((tileRow == emptyRow) != (tileCol == emptyCol)){
        int temp = board[tileRow][tileCol];
        board[tileRow][tileCol] = -1;
        board[emptyRow][emptyCol] = temp;
    }
}",0
ggao363,1695638336,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int tileRow, tileCol, emptyRow, emptyCol;
    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol);
    if((tileRow == emptyRow) != (tileCol == emptyCol)){
        if((((tileRow - emptyRow) >= -1) && ((tileRow - emptyRow) <= 1)) && (((tileCol - emptyCol) >= -1) && ((tileCol - emptyCol) <= 1))){
        int temp = board[tileRow][tileCol];
        board[tileRow][tileCol] = -1;
        board[emptyRow][emptyCol] = temp;}
    }
}",1
gge561,1695776889,1,"#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {

	int row, col;
	int rowspace, colspace;
	int p, s;
	FindTile(board, tile, &row, &col);
	FindTile(board, -1, &rowspace, &colspace);

	if (rowspace + 1 == row && row > 0 && col == colspace) {
		p = board[row][col];
		s = board[rowspace][colspace];
		board[rowspace][colspace] = p;
		board[row][col] = s;
	}
	else if (rowspace - 1 == row && row < 3 && col == colspace) {
		p = board[row][col];
		s = board[rowspace][colspace];
		board[rowspace][colspace] = p;
		board[row][col] = s;
	}
	else if (colspace + 1 == col && col > 0 && row == rowspace) {
		p = board[row][col];
		s = board[rowspace][colspace];
		board[rowspace][colspace] = p;
		board[row][col] = s;
	}
	else if (colspace - 1 == col && col < 3 && row == rowspace) {
		p = board[row][col];
		s = board[rowspace][colspace];
		board[rowspace][colspace] = p;
		board[row][col] = s;
	}
}",1
gjom886,1696229695,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
#define NUM_ROWS 4
#define NUM_COLS 4
int r;
int c;

  FindTile(board, tile, &row, &col)
   if row > 0 {
       if col > 0 {
    if (row + 1 == -1) && (col + 1 == -1) {
      board[row+1][col+1] = tile;
      board[row][col] = -1;
     }
    if (row - 1 == -1) && (col + 1 == -1) {
    board[row-1][col+1] = tile;
      board[row][col] = -1;
    }
    if (row - 1 == -1) && (col - 1 == -1) {
        board[row-1][col-1] = tile;
      board[row][col] = -1;
    }
    if (row + 1 = -1) && (col - 1 == -1) {
        board[row+1][col-1] = tile;
      board[row][col] = -1;
      return 
    }
       }
   }
}",0
gjom886,1696235548,2,"#include <stdio.h>
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {

int r;
int c;
int row;
int col;
int row_negone;
int col_negone;
  FindTile(board, tile, &row, &col);
  FindTile(board, -1, &row_negone,&col_negone);
int Absence_r_right = row_negone + 1;
int Absence_r_left = row_negone - 1;
int Absence_col_up = col_negone + 1;
int Absence_col_down = col_negone - 1;
  
 

if (row ==row_negone){
    if (col == Absence_col_up || col == Absence_col_down){
        
    }
} else if(col == col_negone){
    if (row == Absence_r_right|| row == Absence_r_left)
   
board[row_negone][col_negone] = tile;
        board[row][col] = -1;
}     
}
",0
gjom886,1696236272,3,"#include <stdio.h>
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {

int r;
int c;
int row;
int col;
int row_negone;
int col_negone;
  FindTile(board, tile, &row, &col);
  FindTile(board, -1, &row_negone,&col_negone);

int Absence_col_up = col_negone + 1;
int Absence_col_down = col_negone - 1;
  
 
if(row == row_negone && (col == Absence_col_up || col == Absence_col_down)) {
    
}
int Absence_r_right = row_negone + 1;
int Absence_r_left = row_negone - 1;
if (col == col_negone && (row == Absence_r_right|| row == Absence_r_left)) {
  board[row_negone][col_negone] = tile;
        board[row][col] = -1;
}

  
}

",0
gjom886,1696236279,4,"#include <stdio.h>
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {


int row;
int col;
int row_negone;
int col_negone;
  FindTile(board, tile, &row, &col);
  FindTile(board, -1, &row_negone,&col_negone);

int Absence_col_up = col_negone + 1;
int Absence_col_down = col_negone - 1;
  
 
if(row == row_negone && (col == Absence_col_up || col == Absence_col_down)) {
    
}
int Absence_r_right = row_negone + 1;
int Absence_r_left = row_negone - 1;
if (col == col_negone && (row == Absence_r_right|| row == Absence_r_left)) {
  board[row_negone][col_negone] = tile;
        board[row][col] = -1;
}

  
}

",0
gjom886,1696237221,5,"#include <stdio.h>
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {


int row;
int col;
int row_negone;
int col_negone;
  FindTile(board, tile, &row, &col);
  FindTile(board, -1, &row_negone,&col_negone);

int Absence_col_up = col_negone + 1;
int Absence_col_down = col_negone - 1;
  
 
int Absence_r_right = row_negone + 1;
int Absence_r_left = row_negone - 1;
if((row == row_negone && (col == Absence_col_up || col == Absence_col_down)) || (col == col_negone && (row == Absence_r_right|| row == Absence_r_left))) {
  board[row_negone][col_negone] = tile;
        board[row][col] = -1;
}

  
}

",1
gmal045,1695682625,1,"#include <stdio.h>

void MakeMove(int board[4][4], int tile)
{
    for (int i=0;i < 4;i++)
    {
        for (int j=0;j < 4;j++)
        {
            if (board[i][j] == -1)
            {
                if (board[i-1][j] == tile) {
                    board[i][j] = tile;
                    board[i-1][j] = -1;
                }
                else if (board[i][j-1] == tile) {
                    board[i][j] = tile;
                    board[i][j-1] = -1;
                }
                else if (board[i+1][j] == tile) {
                    board[i][j] = tile;
                    board[i+1][j] = -1;

                }
                else if (board[i][j+1] == tile) {
                    board[i][j] = tile;
                    board[i][j+1] = -1;
                }
            }
        }
    }
} ",0
gmal045,1695703618,2,"#include <stdio.h>
#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    for (int i=0;i < 4;i++)
    {
        for (int j=0;j < 4;j++)
        {
            if (board[i][j] == -1)
            {
                if (board[i-1][j] == tile) {
                    board[i][j] = tile;
                    board[i-1][j] = -1;
                }
                else if (board[i][j-1] == tile) {
                    board[i][j] = tile;
                    board[i][j-1] = -1;
                }
                else if (board[i+1][j] == tile) {
                    board[i][j] = tile;
                    board[i+1][j] = -1;
                }
                else if (board[i][j+1] == tile) {
                    board[i][j] = tile;
                    board[i][j+1] = -1;
                }
                break;
            }
        }
    }
} ",0
gmal045,1695707751,3,"#include <stdio.h>
#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    for (int i=0;i < 4;i++) {
        for (int j=0;j < 4;j++) {
            if (board[i][j] == -1) {
                if (board[i-1][j] == tile) {
                    board[i][j] = tile;
                    board[i-1][j] = -1;
                }
                else if (board[i][j-1] == tile) {
                    board[i][j] = tile;
                    board[i][j-1] = -1;
                }
                if (board[i+1][j] == tile) {
                    board[i][j] = tile;
                    board[i+1][j] = -1;
                }
                else if (board[i][j+1] == tile) {
                    board[i][j] = tile;
                    board[i][j+1] = -1;
                }
                goto Pass;
            }
        }
    }
    Pass:
}",0
gmal045,1695708028,4,"#include <stdio.h>
#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    for (int i=0;i < 4;i++) {
        for (int j=0;j < 4;j++) {
            if (board[i][j] == -1) {
                if (board[i-1][j] == tile && i-1 >= 0) {
                    board[i][j] = tile;
                    board[i-1][j] = -1;
                    return;
                }
                else if (board[i][j-1] == tile && j-1 >= 0) {
                    board[i][j] = tile;
                    board[i][j-1] = -1;
                    return;
                }
                if (board[i+1][j] == tile && i+1 <= 3) {
                    board[i][j] = tile;
                    board[i+1][j] = -1;
                    return;
                }
                else if (board[i][j+1] == tile && j+1 <= 3) {
                    board[i][j] = tile;
                    board[i][j+1] = -1;
                    return;
                }
            }
        }
    }
}",1
gmoh887,1695711576,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tileRow, tileCol, blankRow, blankCol;

	FindTile(board, tile, &tileRow, &tileCol);
	FindTile(board, -1, &blankRow, &blankCol);

	if (((tileRow == blankRow) && (tileCol == blankCol+1 || tileCol == blankCol-1)) ||
		((tileCol == blankCol) && (tileRow == blankRow+1 || tileRow == blankRow-1))) {
		board[blankRow][blankCol] = tile;
		board[tileRow][tileCol] = -1;
	}
}",1
gpen695,1695895842,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) 
{
    int emptyRow, emptyCol, tileRow, tileCol;
    
    FindTile(board, -1, &emptyRow, &emptyCol);
    
    FindTile(board, tile, &tileRow, &tileCol);

    if ((abs(emptyRow - tileRow) == 1 && emptyCol == tileCol) ||
    
        (abs(emptyCol - tileCol) == 1 && emptyRow == tileRow))
        {
        
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
   
}
",1
gvan573,1696230313,1,"#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>


void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int moverow, row, movecol, col;

	//row and col become the co ordinates of the tile we choose
	FindTile(board, tile, &moverow, &movecol);
	
	//row1 and col1 become the co ordinates of the tile with the value of -1
	FindTile(board, -1, &row, &col);

	//if it is one to the left, one to the right, one up, or one dow, swap the values
	
	if ((row == moverow) && (movecol == (col - 1) || movecol == (col + 1))) {
		board[row][col] = tile;
		board[moverow][movecol] = -1;
	}

	if ((col == movecol) && (moverow == (row - 1) || moverow == (row + 1))) {
		board[row][col] = tile;
		board[moverow][movecol] = -1;
	}
}
",1
gxu660,1695705332,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;
	int row_empty, col_empty;
	
	FindTile(board, tile, &row, &col);
	FindTile(board, -1, &row_empty, &col_empty);

	if ((row == row_empty && ((col - col_empty) * (col - col_empty) == 1)) 
		|| (col == col_empty && ((row - row_empty) * (row - row_empty) == 1))) {
		board[row_empty][col_empty] = tile;
		board[row][col] = -1;
	}

}",1
gzho986,1695898187,1,"#include <stdio.h>
#include <stdlib.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int emptyRow, emptyCol, tileRow, tileCol;
	FindTile(board, -1, &emptyRow, &emptyCol);
	FindTile(board, tile, &tileRow, &tileCol);

	if ((emptyRow == tileRow && abs (emptyCol- tileCol)==1) || (emptyCol == tileCol && abs(emptyRow - tileRow) == 1)){
		
		board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;

	}
	
}",1
hama210,1695858686,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;
	int row_tile, col_tile;

	FindTile(board, -1, &row, &col);
	FindTile(board, tile, &row_tile, &col_tile);

	if (row_tile + 1 <= 3 && board[row_tile + 1][col_tile] == board[row][col]) {
		board[row][col] = tile;
		board[row_tile][col_tile]= -1; 
	}

	if (row_tile - 1 >= 0 && board[row_tile - 1][col_tile] == board[row][col]) {
		board[row][col] = tile; 
		board[row_tile][col_tile] = -1;
	}

	if (col_tile + 1 <= 3 && board[row_tile][col_tile + 1] == board[row][col]) {
		board[row][col] = tile; 
		board[row_tile][col_tile] = -1; 
	}
	if (col_tile - 1 >= 0 && board[row_tile][col_tile - 1] == board[row][col]) {
		board[row][col] = tile; 
		board[row_tile][col_tile] = -1; 
	}
}",1
hbas168,1696056947,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowPos;
	int colPos;

	FindTile(board, tile, &rowPos, &colPos);

	int emptyRowPos;
	int emptyColPos;

	FindTile(board, -1, &emptyRowPos, &emptyColPos);

	if (rowPos == emptyRowPos && (colPos == emptyColPos + 1 || colPos == emptyColPos - 1)) {
		board[emptyRowPos][emptyColPos] = board[rowPos][colPos];
		board[rowPos][colPos] = -1;
	}
	else if (colPos == emptyColPos && (rowPos == emptyRowPos + 1 || rowPos == emptyRowPos - 1)) {
		board[emptyRowPos][emptyColPos] = board[rowPos][colPos];
		board[rowPos][colPos] = -1;
	}

}",1
hber510,1695884176,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col, rowTile, colTile;
    int goodMove = 0;
    FindTile(board, -1, &row, &col);
    FindTile(board, tile, &rowTile, &colTile);
    
    //tile in first row
    if (row==0) {
        if (col == 0) {
            if (tile == board[row][col + 1] || tile == board[row + 1][col]) {
                goodMove = 1;
            } 
        } else if (col == 3) {
            
            if (tile == board[row][col - 1] || tile == board[row + 1][col]) {
                goodMove = 1;
            }
        } else {
            if (tile == board[row][col - 1] || tile == board[row][col + 1] || tile == board[row + 1][col]) {
            goodMove = 1;
            }
        }
    //tile in last row  
    } else if (row==3) {
        if (col == 0) {
            if (tile == board[row][col + 1] || tile == board[row - 1][col]) {
                goodMove = 1;
            } 
        } else if (col == 3) {
            
            if (tile == board[row][col - 1] || tile == board[row - 1][col]) {
                goodMove = 1;
            }
        } else {
            if (tile == board[row][col - 1] || tile == board[row][col + 1] || tile == board[row - 1][col]) {
            goodMove = 1;
            }
        }
        
    //tile in middle of first col  
    } else if (col==0) {
        if (tile == board[row - 1][col] || tile == board[row + 1][col] || tile == board[row][col + 1]) {
            goodMove = 1;
        }
    //tile in middle of last col
    } else if (col==3) {
        if (tile == board[row - 1][col] || tile == board[row + 1][col] || tile == board[row][col - 1]) {
            goodMove = 1;
        }
    //tile in centre of board
    } else {
        if (tile == board[row - 1][col] || tile == board[row + 1][col] || tile == board[row][col - 1] || tile == board[row][col + 1]) {
            goodMove = 1;
        }
    }

    
    if (goodMove == 1) {
        board[row][col] = tile;
        board[rowTile][colTile] = -1;
        
    }
    

}",1
hbou314,1695867528,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row_empty, col_empty, row, col;

	FindTile(board, -1, &row_empty, &col_empty);
	FindTile(board, tile, &row, &col);

	if ((row_empty + 1 < 4) && (row == row_empty + 1) && (col_empty == col)) {
		//swap tiles
		board[row_empty][col_empty] = tile;
		board[row][col] = -1;
	}
	if ((row_empty - 1 > -1) && (row == row_empty - 1) && (col_empty == col)) {
		//swap tiles
		board[row_empty][col_empty] = tile;
		board[row][col] = -1;
	}
	if ((col_empty + 1 < 4) && (col == col_empty + 1) && (row_empty == row)) {
		//swap tiles
		board[row_empty][col_empty] = tile;
		board[row][col] = -1;
	}
	if ((col_empty - 1 > -1) && (col == col_empty - 1) && (row_empty == row)) {
		//swap tiles
		board[row_empty][col_empty] = tile;
		board[row][col] = -1;
	}
}",1
hcha410,1695899639,1,"#include <stdio.h>
#include <stdlib.h> 

#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int rowTile, colTile, rowEmpty, colEmpty;
    
    FindTile(board, tile, &rowTile, &colTile);
    FindTile(board, -1, &rowEmpty, &colEmpty);
    
    if ((rowTile == rowEmpty && abs(colTile - colEmpty) == 1) ||
        (colTile == colEmpty && abs(rowTile - rowEmpty) == 1)) {
            
        board[rowEmpty][colEmpty] = tile;
        board[rowTile][colTile] = -1;
        
    }
}",1
hche410,1696218297,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol, tileRow, tileCol;
    FindTile(board, 1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);
    if ((abs(emptyRow - tileRow) = 1 && emptyCol = tileCol) ||
        (abs(emptyCol - tileCol) = 1 && emptyRow = tileRow)) {
        // Swap the tile and the empty square.
        int temp = board[emptyRow][emptyCol];
        board[emptyRow][emptyCol] = board[tileRow][tileCol];
        board[tileRow][tileCol] = temp;
    }
}",0
hche410,1696218303,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol, tileRow, tileCol;
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);
    if ((abs(emptyRow - tileRow) == 1 && emptyCol == tileCol) ||
        (abs(emptyCol - tileCol) == 1 && emptyRow == tileRow)) {
        // Swap the tile and the empty square.
        int temp = board[emptyRow][emptyCol];
        board[emptyRow][emptyCol] = board[tileRow][tileCol];
        board[tileRow][tileCol] = temp;
    }
}",1
hche864,1695871524,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row;
	int col;
	int i;
	int j;
	int temp;
	FindTile(board, -1, &row, &col);
	int old_row = row;
	int old_col = col;

	FindTile(board, tile, &row, &col);

	if (row == old_row || col == old_col) {
		temp = board[old_row][old_col];
		board[old_row][old_col] = board[row][col];
		board[row][col] = temp;

	}

}",0
hche864,1695871644,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row;
	int col;
	int temp;
	FindTile(board, -1, &row, &col);
	int old_row = row;
	int old_col = col;

	FindTile(board, tile, &row, &col);

	if (row == old_row || col == old_col) {
		temp = board[old_row][old_col];
		board[old_row][old_col] = board[row][col];
		board[row][col] = temp;

	}

}",0
hche864,1695872668,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row;
	int col;
	int temp;
	FindTile(board, -1, &row, &col);
	int old_row = row;
	int old_col = col;

	FindTile(board, tile, &row, &col);

	if (row == old_row && (col == old_col - 1 || col == old_col + 1) || col == old_col && (row == old_row+1 || row == old_row -1) ) {
		temp = board[old_row][old_col];
		board[old_row][old_col] = board[row][col];
		board[row][col] = temp;

	}

}",0
hche864,1695873653,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row;
	int col;
	int temp;
	FindTile(board, -1, &row, &col);
	int old_row = row;
	int old_col = col;

	FindTile(board, tile, &row, &col);

	if (((row == old_row) && (col == old_col - 1) || (col == old_col + 1)) || ((col == old_col) && (row == old_row + 1) || (row == old_row - 1))) {
		temp = board[old_row][old_col];
		board[old_row][old_col] = board[row][col];
		board[row][col] = temp;

	}

}",0
hche864,1695873906,5,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row;
	int col;
	int temp;
	FindTile(board, -1, &row, &col);
	int old_row = row;
	int old_col = col;

	FindTile(board, tile, &row, &col);

	if ((row == old_row && (col == old_col - 1 || col == old_col + 1)) || (col == old_col && (row == old_row + 1 || row == old_row - 1)) {
		temp = board[old_row][old_col];
		board[old_row][old_col] = board[row][col];
		board[row][col] = temp;

	}

}",0
hche864,1695874321,6,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row;
	int col;
	int temp;
	FindTile(board, -1, &row, &col);
	int old_row = row;
	int old_col = col;
	FindTile(board, tile, &row, &col);

	if ((row == old_row && (col == old_col - 1 || col == old_col + 1)) || (col == old_col && (row == old_row + 1 || row == old_row - 1))) {
		temp = board[old_row][old_col];
		board[old_row][old_col] = board[row][col];
		board[row][col] = temp;

	}

}",1
hcop563,1695718401,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	/* Creates integer variables for the rows and columns of 
	both the user inputted tile and the empty tile */ 
	int emptyRow, emptyCol, tileRow, tileCol;

	/* Uses the find tile function to find the user inputted tile
	and the empty tile and assigns the positions of each to their
	approite varibales */
	FindTile(board, -1, &emptyRow, &emptyCol);
	FindTile(board, tile, &tileRow, &tileCol);

	int colDiff, rowDiff;

	colDiff = emptyCol - tileCol;
	rowDiff = emptyRow - tileRow;

	// Does the logic to stop unwanted tile movements
	if ((((colDiff == 1) || (colDiff == -1)) && (rowDiff == 0)) ||
		(((rowDiff == 1) || (rowDiff == -1)) && (colDiff == 0))) {
		board[emptyRow][emptyCol] = tile;
		board[tileRow][tileCol] = -1;
	}
}",1
hcro730,1695788249,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tileRow, tileCol, blankRow, blankCol;

	FindTile(board, tile, &tileRow, &tileCol);
	FindTile(board, -1, &blankRow, &blankCol);

	if ((blankRow == tileRow + 1 || blankRow == tileRow - 1) && blankCol == tileCol) {
		board[blankRow][blankCol] = tile;
		board[tileRow][tileCol] = -1;
	}
	else if ((blankCol == tileCol + 1 || blankCol == tileCol - 1) && blankRow == tileRow) {
		board[blankRow][blankCol] = tile;
		board[tileRow][tileCol] = -1;
	}
}",1
hdeg917,1696224878,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, row1, col, col1;
	FindTile(board, tile, &row, &col);
	FindTile(board, -1, &row1, &col1);
	if (!((row - row1 == -1 || row - row1 == 1) && (col - col1 == -1 || col - col1 == 1))) {
		if ((row - row1 >= -1 && row - row1 <= 1) && (col - col1 >= -1 && col - col1 <= 1)) {
			board[row1][col1] = tile;
			board[row][col] = -1;
		}

	}
	
}",1
hgao080,1695619704,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, eRow, eCol;

	FindTile(board, tile, &row, &col);
	FindTile(board, -1, &eRow, &eCol);

	if ((row - eRow <= 1 && row - eRow >= -1) && (col - eCol <= 1 && col - eCol >= -1)) {
		board[eRow][eCol] = board[row][col];
		board[row][col] = -1;
	}
}",1
hgou636,1695902438,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col, emptyRow, emptyCol;
    FindTile(board, tile, &row, &col);
    FindTile(board,-1, &emptyRow, &emptyCol);
    if (emptyRow == row && (emptyCol == col + 1 || emptyCol == col - 1)) {
        board[row][col] = -1;
        board[emptyRow][emptyCol] = tile;
    }
        else if (emptyCol == col && (emptyRow == row + 1 || emptyRow == row - 1)) {
        board[row][col] = -1;
        board[emptyRow][emptyCol] = tile;
    }
}",1
hjoo911,1695951922,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    // initialise index values
    int i, j;
    
    // count through the tiles
    
    for (i = 0 ; i < NUM_ROWS ; i++) {
       for (j = 0 ; j < NUM_COLS ; j++) {
           
        if (board[i][j] == -1) {
            board[i][j] = tile;
        }
        
        else if (board[i][j+1] == -1) {
        board[i][j+1] = tile;
        }
        
        else if (board[i+1][j] == -1) {
            board[i+1][j] = tile;
        }
        
        }
        j++;
        i++;
       }
       
       //replace the number where moved tile moved from to -1
       FindTile(board, tile, &i, &j);
       board[i][j] = -1 ;
       
       
    }",0
hjoo911,1695954692,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    
    // initialise index value
    int i, j;
    // count through the tiles
           
     FindTile(board, tile, &i, &j);
           
           //if i,j is already -1
       // if (board[i][j] == ) {
          //  board[i][j] = tile;
        
        //condition for moving right
        if (j < 3) {
            //right
        if (board[i][j+1] == -1) {
            board[i][j+1] = tile;
            board[i][j] = -1;
        }
        }
        //condition for moving down
        if (i < 3) {
            //down
        if (board[i+1][j] == -1) {
            board[i+1][j] = tile;
            board[i][j] = -1;
        }
        }
        //condition for moving up
        if (i > 0) {
            //up
          if (board[i-1][j] == -1) {
            board[i-1][j] = tile;
            board[i][j] = -1;
        }
        }
        //condition for moving left
        if (j > 0) {
            //left
            if (board[i][j-1] == -1) {
            board[i][j-1] = tile;
            board[i][j] = -1;
        }
        }


       
       //replace the number where moved tile moved from to -1
       
     }",1
hkah523,1696141600,1,"#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
/*author:Harshdeep Kahlon*/

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    
    int emptyRow, emptyCol, tileRow, tileCol;
    FindTile(board, -1, &emptyRow, &emptyCol); // Find the empty square
    FindTile(board, tile, &tileRow, &tileCol); // Find the specified tile

    // Check if the tile can be moved (adjacent to the empty square)
    if ((tileRow == emptyRow && (tileCol == emptyCol - 1 || tileCol == emptyCol + 1)) ||
        (tileCol == emptyCol && (tileRow == emptyRow - 1 || tileRow == emptyRow + 1))) {

        // Swap the tile and the empty square
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}",1
hkim807,1696058682,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row;
	int col;
	int blank = -1;
	FindTile(board, tile, &row, &col);

	if (row > 0) {
		if (board[row-1][col] == blank){
			blank = board[row-1][col];
			board[row-1][col] = board[row][col];
		    board[row][col] = blank;
		}
	} 

	if (col > 0) {
		if (board[row][col-1] == blank){
			blank = board[row][col-1];
			board[row][col-1] = board[row][col];
			board[row][col] = blank;
		}
	}

	if (col < 3) {
		if (board[row][col+1] == blank){
			blank = board[row][col+1];
			board[row][col+1] = board[row][col];
			board[row][col] = blank;
		}
	}

	if (row < 3) {
		if (board[row+1][col] == blank){
			blank = board[row+1][col];
			board[row+1][col] = board[row][col];
			board[row][col] = blank;
		}
	}
}",1
hlee999,1695853098,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, Row, Col;
	FindTile(board, -1, &row, &col);
	FindTile(board, tile, &Row, &Col);

	if (abs(row - Row) == 1 && col == Col || abs(col - Col) == 1 && row == Row) {
		board[Row][Col] = -1;
		board[row][col] = tile;
	}
}",0
hlee999,1695853531,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, Row, Col;
	FindTile(board, -1, &row, &col);
	FindTile(board, tile, &Row, &Col);

	if (((abs(row - Row) == 1) && (col == Col)) || ((abs(col - Col) == 1) && (row == Row))) {
		board[Row][Col] = -1;
		board[row][col] = tile;
	}
}",1
hleu459,1696238304,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyRow, emptyCol, tileRow, tileCol;

    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);

    if (((emptyRow - tileRow) == 1 || emptyRow == tileRow) || 
        ((emptyCol - tileCol) == 1 && emptyCol == tileCol)) {
        
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}",0
hleu459,1696238422,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyRow, emptyCol, tileRow, tileCol;

    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);

    if (((emptyRow - tileRow) == 1 || emptyRow == tileRow) || 
        ((emptyCol - tileCol) == 1 || emptyCol == tileCol)) {
        
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}",0
hleu459,1696240383,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyRow, emptyCol, tileRow, tileCol;
    
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);
    
    if ((tileRow == emptyRow && (tileCol == emptyCol - 1 || tileCol == emptyCol + 1)) ||
        (tileCol == emptyCol && (tileRow == emptyRow - 1 || tileRow == emptyRow + 1))) {
        
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}",1
hliu836,1695913607,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col,row1,col1;
    FindTile(board, -1, &row, &col);
    if ((board[row+1][col] == tile) || (board[row-1][col] == tile) || (board[row][col+1] == tile) || (board[row][col-1] == tile)){
        FindTile(board, tile, &row1, &col1);
        board[row][col] = tile;
        board[row1][col1] = -1;
        
    }
    
    
}",0
hliu836,1695957252,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col,row1,col1;

    
    FindTile(board, tile, &row1, &col1);
    FindTile(board, -1, &row, &col);
    
    
    if ((row-1==-1)&&(col-1==-1))  {
        if ((board[row+1][col]==tile)||(board[row][col+1]==tile)){
            board[row][col] = tile;
            board[row1][col1] = -1;
        }
    } else if ((row-1==-1)) {
        if ((board[row+1][col]==tile)||(board[row][col+1]==tile)||(board[row][col-1]==tile)) {
            board[row][col] = tile;
            board[row1][col1] = -1;
        }
    } else if ((row-1==-1) && (col+1==NUM_COLS)) {
        if ((board[row+1][col]==tile)||(board[row][col-1]==tile)) {
            board[row][col] =tile;
            board[row1][col1] = -1;
        }
    } else if (col+1 == NUM_COLS) {
        if ((board[row+1][col]==tile)||(board[row][col-1]==tile)||(board[row-1][col-1]==tile)){
            board[row][col] = tile;
            board[row1][col1] = -1;
        }
    } else if ((col+1==NUM_COLS)&&(row+1==NUM_ROWS)){
        if ((board[row][col-1]==tile)||(board[row-1][col]==tile)) {
            board[row][col] = tile;
            board[row1][col1] = -1;
        }
    } else if (row+1==NUM_ROWS) {
        if ((board[row-1][col]==tile)||(board[row][col+1]==tile)||(board[row][col-1]==tile)) {
            board[row][col] = tile;
            board[row1][col1] = -1;
        }
    } else if ((col-1==-1)&&(row+1==NUM_ROWS)) {
        if ((board[row][col+1]==tile)||(board[row-1][col]==tile)) {
            board[row][col] = tile;
            board[row1][col1] = -1;
        }
    } else if (col-1==-1) {
        if ((board[row+1][col]==tile)||(board[row-1][col]==tile)||(board[row][col+1]==tile)){
            board[row][col] = tile;
            board[row1][col1] = -1;
        }
    } else {
        if ((board[row+1][col] == tile) || (board[row-1][col] == tile) || (board[row][col+1] == tile) || (board[row][col-1] == tile)) {
            board[row][col] = tile;
            board[row1][col1] = -1;
        }
    }
       
    
    
}",1
hly852,1696213160,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col, trow, tcol;
    FindTile(board, -1, &row, &col);
    FindTile(board, tile, &trow, &tcol);

    if (((trow==row+1 || trow==row-1) && tcol == col) || ((tcol==col+1 || tcol==col-1) && trow == row)){
            board[row][col] = board[trow][tcol];
            board[trow][tcol] = -1;
    }
}",1
hma481,1696165849,1,"void PrintBoard(int board[NUM_ROWS][NUM_COLS])
{
	int i, j;
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == -1) {
				printf("" _ "");
			}
			else if (board[i][j] > 9) {   // align two-digit numbers
				printf("" %d"", board[i][j]);
			}
			else {
				printf("" %d "", board[i][j]);
			}
		}
		printf(""\n"");
	}
	printf(""\n"");
}
",0
hma481,1696165876,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, tRow, tCol;
	FindTile(board, -1, &row, &col);
	FindTile(board, tile, &tRow, &tCol);
	if ((((tRow - row) == 1) || ((tRow - row) == -1) || ((tRow - row) == 0)) && (((tCol - col) == 1) || ((tCol - col) == -1) || ((tCol - col) == 0))) {
		int temp = board[row][col];
		board[row][col] = board[tRow][tCol];
		board[tRow][tCol] = temp;
	}
}
",1
hmcm582,1695696276,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
	int emptyRow, emptyCol, tileRow, tileCol;

	// Find the positions of the empty tile and the specified tile
	FindTile(board, -1, &emptyRow, &emptyCol);
	FindTile(board, tile, &tileRow, &tileCol);

	// Check if the specified tile is adjacent to the empty tile
	if ((abs(emptyRow - tileRow) == 1 && emptyCol == tileCol) ||
		(abs(emptyCol - tileCol) == 1 && emptyRow == tileRow)) {
		// Swap the empty tile and the specified tile
		board[emptyRow][emptyCol] = tile;
		board[tileRow][tileCol] = -1;
	}
}",1
hmel649,1695714366,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row, col;
    FindTile(board, -1, &row, &col);
    int row2, col2;
    FindTile(board, tile, &row2, &col2);
    
    if (row == row2 && (col == col2 - 1 || col == col2 + 1)) {
        board[row][col] = tile;
        board[row2][col2] = -1;
    }
    if (col == col2 && (row == row2 - 1 || row == row2 + 1)) {
        board[row][col] = tile;
        board[row2][col2] = -1;
    }
}",1
hmof971,1695878025,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col,row2,col2;
	FindTile(board, tile, &row, &col);
	FindTile(board, -1, &row2, &col2);
	if (row + 1 == row2 && row!=3&&col==col2){
		board[row][col] = -1;
		board[row2][col2] = tile;
	}
	else if	(row - 1 == row2 && row!=0&&col==col2) {
		board[row][col] = -1;
		board[row2][col2] = tile;
	}
		else if(col + 1 == col2 && col!=3&&row==row2){
			board[row][col] = -1;
			board[row2][col2] = tile;
		}
		else if(col - 1 == col2 && col!=0&&row==row2) {
		board[row][col] = -1;
		board[row2][col2] = tile;
	}	
		}",1
hnew638,1695635157,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int empRow, empCol, tileRow, tileCol;
	FindTile(board, -1, &empRow, &empCol);
	FindTile(board, tile, &tileRow, &tileCol);
	if (tileRow == empRow + 1 || tileRow == empRow - 1 || tileCol == empCol + 1 || tileCol == empCol - 1)
	{
		board[empRow][empCol] = tile;
		board[tileRow][tileCol] = -1;
	};

}",0
hnew638,1695690423,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int empRow, empCol, tileRow, tileCol;
	FindTile(board, -1, &empRow, &empCol);
	FindTile(board, tile, &tileRow, &tileCol);
	if (((tileRow == empRow + 1) && (tileCol == empCol)) || ((tileRow == empRow - 1) && (tileCol == empCol)) || ((tileCol == empCol + 1) && (tileRow == empRow)) || ((tileCol == empCol - 1) && (tileRow == empRow)))
	{
		board[empRow][empCol] = tile;
		board[tileRow][tileCol] = -1;
	}

}",1
hpan363,1696243850,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
// void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos)
{
    int Row_Tile, Column_Tile, Row_Empty, Column_Empty;
    FindTile(board, tile, &Row_Tile, &Column_Tile);
    FindTile(board, -1, &Row_Empty, &Column_Empty);
    if ((Row_Tile == Row_Empty && (Column_Tile - Column_Empty) == 1) || (Column_Tile == Column_Empty && (Row_Tile - Row_Empty) == 1))
    {
            board[Row_Empty][Column_Empty] = tile;
            board[Row_Tile][Column_Tile] = -1;
    }
}
",0
hpan363,1696244141,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
// void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos)
{
    int Row_Tile, Column_Tile, Row_Empty, Column_Empty;
    FindTile(board, tile, &Row_Tile, &Column_Tile);
    FindTile(board, -1, &Row_Empty, &Column_Empty);
    if ((Row_Tile == Row_Empty && abs(Column_Tile - Column_Empty) == 1) || (Column_Tile == Column_Empty && abs(Row_Tile - Row_Empty) == 1))
    {
            board[Row_Empty][Column_Empty] = tile;
            board[Row_Tile][Column_Tile] = -1;
    }
}
",1
hpat916,1695763884,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	/* Declaring variables to be used and then passing through the FindTile function in order to obtain the positions of the moving tiles and the empty tiles.*/
	int movingTileRow;
	int movingTileCol;
	int	emptyTileRow;
	int	emptyTileCol;
	FindTile(board, tile, &movingTileRow, &movingTileCol);
	FindTile(board, -1, &emptyTileRow, &emptyTileCol);
	

	/* Individual conditional for when the moving rows by checking input is in the same column and directly above or below blank tile. */
	if ((movingTileRow == (emptyTileRow + 1) || movingTileRow == (emptyTileRow - 1)) && movingTileCol == emptyTileCol) { 
		board[emptyTileRow][emptyTileCol] = board[movingTileRow][movingTileCol];
		board[movingTileRow][movingTileCol] = -1;
	}

	/* Set of conditionals for checking situations of blank tile being to the left or right of the moving tile. Esspecially for boundary positions when the position may be on a higher row. */
	if (emptyTileCol == 0) { 

		/* Checking to make sure that the moving tile is to the right of the empty tile and are on the same row. */
		if (movingTileCol == (emptyTileCol + 1) && movingTileRow == emptyTileRow) {
			board[emptyTileRow][emptyTileCol] = board[movingTileRow][movingTileCol];
			board[movingTileRow][movingTileCol] = -1;
		}
	} 
	else if (emptyTileCol == 3) {
		/* Checking to make sure that the moving tile is to the left of the empty tile and are on the same row. */
		if (movingTileCol == (emptyTileCol - 1) && movingTileRow == emptyTileRow) {
			board[emptyTileRow][emptyTileCol] = board[movingTileRow][movingTileCol];
			board[movingTileRow][movingTileCol] = -1;
		}
	}
	/* Runs on any alternative situation where there is a standard left or right movement when they are on the same row. */
	else if ((movingTileCol == (emptyTileCol + 1) || movingTileCol == (emptyTileCol - 1) && movingTileRow == emptyTileRow)) {
			board[emptyTileRow][emptyTileCol] = board[movingTileRow][movingTileCol];
			board[movingTileRow][movingTileCol] = -1;
		}	
}",0
hpat916,1695763970,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	/* Declaring variables to be used and then passing through the FindTile function in order to obtain the positions of the moving tiles and the empty tiles.*/
	int movingTileRow;
	int movingTileCol;
	int	emptyTileRow;
	int	emptyTileCol;
	FindTile(board, tile, &movingTileRow, &movingTileCol);
	FindTile(board, -1, &emptyTileRow, &emptyTileCol);
	

	/* Individual conditional for when the moving rows by checking input is in the same column and directly above or below blank tile. */
	if ((movingTileRow == (emptyTileRow + 1) || movingTileRow == (emptyTileRow - 1)) && movingTileCol == emptyTileCol) { 
		board[emptyTileRow][emptyTileCol] = board[movingTileRow][movingTileCol];
		board[movingTileRow][movingTileCol] = -1;
	}

	/* Set of conditionals for checking situations of blank tile being to the left or right of the moving tile. Esspecially for boundary positions when the position may be on a higher row. */
	if (emptyTileCol == 0) { 

		/* Checking to make sure that the moving tile is to the right of the empty tile and are on the same row. */
		if (movingTileCol == (emptyTileCol + 1) && movingTileRow == emptyTileRow) {
			board[emptyTileRow][emptyTileCol] = board[movingTileRow][movingTileCol];
			board[movingTileRow][movingTileCol] = -1;
		}
	} 
	else if (emptyTileCol == 3) {
		/* Checking to make sure that the moving tile is to the left of the empty tile and are on the same row. */
		if (movingTileCol == (emptyTileCol - 1) && movingTileRow == emptyTileRow) {
			board[emptyTileRow][emptyTileCol] = board[movingTileRow][movingTileCol];
			board[movingTileRow][movingTileCol] = -1;
		}
	}
	/* Runs on any alternative situation where there is a standard left or right movement when they are on the same row. */
	else if ((movingTileCol == (emptyTileCol + 1) || movingTileCol == (emptyTileCol - 1)) && movingTileRow == emptyTileRow) {
			board[emptyTileRow][emptyTileCol] = board[movingTileRow][movingTileCol];
			board[movingTileRow][movingTileCol] = -1;
		}	
}",1
hpir641,1695875193,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, rowe, cole;
	FindTile(board, tile, &row, &col);
	FindTile(board, -1, &rowe, &cole);

	if ((row - rowe) * (row - rowe) + (col - cole) * (col - cole) == 1) {
		board[rowe][cole] = board[row][col];
		board[row][col] = -1;
	}

}",1
hrob997,1696167849,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	//Calls Find Tile function to find the locations of the empty tile and moving tile.
	int rowSpace, colSpace; 
	FindTile(board, -1, &rowSpace, &colSpace);

	int rowMove, colMove; 
	FindTile(board, tile, &rowMove, &colMove);
	//if statements which sets move to 1 if the requested move is possible.
	int move = 0; 
	if (rowMove == rowSpace) {
		if (colMove - 1 == colSpace || colMove + 1 == colSpace) {
			move = 1;
		}
		else {
			move = 0; 
		}
	}
	if (colMove == colSpace) {
		if (rowMove - 1 == rowSpace || rowMove + 1 == rowSpace) {
			move = 1;
		}
		else {
			move = 0; 
		}
	}
	//if move is possible the requested tile is swapped with the empty tile. 
	if (move == 1) {
		board[rowSpace][colSpace] = tile;
		board[rowMove][colMove] = -1;
	}	
}",1
hsan267,1696130048,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int i;
    int j;
    int rowspace;
    int colspace;
    int row;
    int col;
    int tilelocation[1][2] = {0};
    int spacelocation[1][2] = {0};
    
    FindTile(board, tile, &row, &col);
    
    for (i = 0; i < NUM_ROWS; i++) {
    	for (j = 0; j < NUM_COLS; j++) {
    		if (board[i][j] == tile) {
    			tilelocation[0][0] = i;
    			tilelocation[0][1] = j;
    		}
    	}
    }
    
    FindTile(board, -1, &rowspace, &colspace);
    
    for (i = 0; i < NUM_ROWS; i++) {
    	for (j = 0; j < NUM_COLS; j++) {
    		if (board[i][j] == -1) {
    			spacelocation[0][0] = i;
    			spacelocation[0][1] = j;
    		}
    	}
    }
    
    if ((tilelocation[0][0] == spacelocation[0][0]) && ((tilelocation[0][1] + 1) == (spacelocation[0][1])) && (tilelocation[0][1] != NUM_COLS)) {
        for (i = 0; i < NUM_ROWS; i++) {
    	    for (j = 0; j < NUM_COLS; j++) {
    		    if (board[i][j] == tile) {
    			    board[i][j] = -1;
    			    board[i][j+1] = tile;
    			    return;
    		    }
    	    }
        }
    }
    
    if ((tilelocation[0][0] == spacelocation[0][0]) && ((tilelocation[0][1] - 1) == (spacelocation[0][1])) && (tilelocation[0][1] != 0)) {
        for (i = 0; i < NUM_ROWS; i++) {
    	    for (j = 0; j < NUM_COLS; j++) {
    		    if (board[i][j] == tile) {
    			    board[i][j] = -1;
    			    board[i][j-1] = tile;
    			    return;
    		    }
    	    }
        }
    }
    
    if (((tilelocation[0][0] + 1) == spacelocation[0][0]) && ((tilelocation[0][1]) == (spacelocation[0][1])) && (tilelocation[0][0] != NUM_ROWS)) {
        for (i = 0; i < NUM_ROWS; i++) {
    	    for (j = 0; j < NUM_COLS; j++) {
    		    if (board[i][j] == tile) {
    			    board[i][j] = -1;
    			    board[i+1][j] = tile;
    			    return;
    		    }
    	    }
        }
    }
    
    if (((tilelocation[0][0] - 1) == spacelocation[0][0]) && ((tilelocation[0][1]) == (spacelocation[0][1])) && (tilelocation[0][0] != 0)) {
        for (i = 0; i < NUM_ROWS; i++) {
    	    for (j = 0; j < NUM_COLS; j++) {
    		    if (board[i][j] == tile) {
    			    board[i][j] = -1;
    			    board[i-1][j] = tile;
    			    return;
    		    }
    	    }
        }
    }
    			
}",1
hson435,1696239433,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tilerow = 0;
    int tilecol = 0;
    tileposition = FindTile(board, tile, &tilerow, &tilecol);
    int emptyrow = 0;
    int emptycol = 0;
    emptyposition = FindTile(board, -1, &emptyrow, &emptycol);
    if (board[tilerow][(tilecol + 1)]) == -1 {
        board[tilerow][tilecol] = ""_"";
        board[emptyrow][emptycol] = tile;
    }
    else if (board[tilerow][(tilecol - 1)]) == -1 {
        board[tilerow][tilecol] = ""_"";
        board[emptyrow][emptycol] = tile;
    }
    else if (board[(tilerow + 1)][tilecol]) == -1 {
        board[tilerow][tilecol] = ""_"";
        board[emptyrow][emptycol] = tile;
    }
    else if (board[(tilerow - 1)][tilecol]) == -1 {
        board[tilerow][tilecol] = ""_"";
        board[emptyrow][emptycol] = tile;
    }
    else if (board[tilerow][(tilecol + 1)]) != -1 {
        board[emptyrow][emptycol] = ""_"";
    }
    else if (board[tilerow][(tilecol - 1)]) != -1 {
        board[emptyrow][emptycol] = ""_"";
    }
    else if (board[(tilerow + 1)][tilecol]) != -1 {
        board[emptyrow][emptycol] = ""_"";
    }
    else if (board[(tilerow - 1)][tilecol]) != -1 {
        board[emptyrow][emptycol] = ""_"";
    }
}",0
hson435,1696241669,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tilerow = 0;
    int tilecol = 0;
    int tileposition = FindTile(board, tile, &tilerow, &tilecol);
    int emptyrow = 0;
    int emptycol = 0;
    int emptyposition = FindTile(board, -1, &emptyrow, &emptycol);

    if (tileposition != -1) {
        if (tilecol + 1 < NUM_COLS && board[tilerow][tilecol + 1] == -1) {
            board[tilerow][tilecol] = -1;
            board[tilerow][tilecol + 1] = tile;
        }
        else if (tilecol - 1 >= 0 && board[tilerow][tilecol - 1] == -1) {
            board[tilerow][tilecol] = -1;
            board[tilerow][tilecol - 1] = tile;
        }
        else if (tilerow + 1 < NUM_ROWS && board[tilerow + 1][tilecol] == -1) {
            board[tilerow][tilecol] = -1;
            board[tilerow + 1][tilecol] = tile;
        }
        else if (tilerow - 1 >= 0 && board[tilerow - 1][tilecol] == -1) {
            board[tilerow][tilecol] = -1;
            board[tilerow - 1][tilecol] = tile;
        }
    }

    board[emptyrow][emptycol] = -1;
}
",0
hson435,1696241752,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tilerow = 0;
    int tilecol = 0;
    int tileposition = FindTile(board, tile, &tilerow, &tilecol);
    int emptyrow = 0;
    int emptycol = 0;
    FindTile(board, -1, &emptyrow, &emptycol);
    if (tileposition != -1) {
        if (tilecol + 1 < NUM_COLS && board[tilerow][tilecol + 1] == -1) {
            board[tilerow][tilecol] = -1;
            board[tilerow][tilecol + 1] = tile;
        }
        else if (tilecol - 1 >= 0 && board[tilerow][tilecol - 1] == -1) {
            board[tilerow][tilecol] = -1;
            board[tilerow][tilecol - 1] = tile;
        }
        else if (tilerow + 1 < NUM_ROWS && board[tilerow + 1][tilecol] == -1) {
            board[tilerow][tilecol] = -1;
            board[tilerow + 1][tilecol] = tile;
        }
        else if (tilerow - 1 >= 0 && board[tilerow - 1][tilecol] == -1) {
            board[tilerow][tilecol] = -1;
            board[tilerow - 1][tilecol] = tile;
        }
    }
    board[emptyrow][emptycol] = -1;
}",0
hson435,1696242000,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tilerow = 0;
    int tilecol = 0;
    int emptyrow = 0;
    int emptycol = 0;
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == tile) {
                tilerow = i;
                tilecol = j;
            }
            else if (board[i][j] == -1) {
                emptyrow = i;
                emptycol = j;
            }
        }
    }
    if (tilerow == emptyrow && (tilecol == emptycol + 1 || tilecol == emptycol - 1) ||
        tilecol == emptycol && (tilerow == emptyrow + 1 || tilerow == emptyrow - 1)) {
        board[tilerow][tilecol] = -1;
        board[emptyrow][emptycol] = tile;
    }
}",0
hson435,1696242045,5,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tilerow = 0;
    int tilecol = 0;
    int emptyrow = 0;
    int emptycol = 0;
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == tile) {
                tilerow = i;
                tilecol = j;
            }
            else if (board[i][j] == -1) {
                emptyrow = i;
                emptycol = j;
            }
        }
    }
    if ((tilerow == emptyrow && (tilecol == emptycol + 1 || tilecol == emptycol - 1)) ||
        (tilecol == emptycol && (tilerow == emptyrow + 1 || tilerow == emptyrow - 1))) {
        board[tilerow][tilecol] = -1;
        board[emptyrow][emptycol] = tile;
    }
}",1
htew916,1695976600,1,"#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>

/* The dimensions of the puzzle */
#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int emptyRow, emptyCol;
	int tileRow, tileCol;

	// get pos of empty tile
	FindTile(board, -1, &emptyRow, &emptyCol);
	// get  get selected tile
	FindTile(board, tile, &tileRow, &tileCol);

	// Check if selected tile can be moved which are only adjacent to empty tile
	if ((abs(emptyRow - tileRow) == 1 && emptyCol == tileCol) || (abs(emptyCol - tileCol) == 1 && emptyRow == tileRow)) {
		// Swap the positions of the empty tile and the selected tile
		board[emptyRow][emptyCol] = tile;
		board[tileRow][tileCol] = -1;
	}
	else {
		printf(""Invalid move. Try again.\n"");
	}
}",0
htew916,1695978780,2,"#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>

/* The dimensions of the puzzle */

void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int* rowPos, int* colPos)
{
	for (int i = 0; i < NUM_ROWS; i++) {
		for (int j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == tile) {
				*rowPos = i;
				*colPos = j;
				return;
			}
		}
	}
	*rowPos = -1;
	*colPos = -1;
}

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int emptyRow, emptyCol;
	int tileRow, tileCol;

	// Find the positions of the empty tile and the selected tile
	FindTile(board, -1, &emptyRow, &emptyCol);
	FindTile(board, tile, &tileRow, &tileCol);

	// Check if the selected tile can be moved (adjacent to the empty tile)
	if ((abs(emptyRow - tileRow) == 1 && emptyCol == tileCol) || (abs(emptyCol - tileCol) == 1 && emptyRow == tileRow)) {
		// Swap the positions of the empty tile and the selected tile
		board[emptyRow][emptyCol] = tile;
		board[tileRow][tileCol] = -1;
	}
	else {
		printf(""Invalid move. Try again.\n"");
		// Invalid move. Try again
	}
}",0
htew916,1696215856,3,"#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>

/* The dimensions of the puzzle */
#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int emptyRow, emptyCol;
	int tileRow, tileCol;

	// Find the positions of the empty tile and the selected tile
	FindTile(board, -1, &emptyRow, &emptyCol);
	FindTile(board, tile, &tileRow, &tileCol);

	// Check if the selected tile can be moved (adjacent to the empty tile)
	if ((abs(emptyRow - tileRow) == 1 && emptyCol == tileCol) || (abs(emptyCol - tileCol) == 1 && emptyRow == tileRow)) {
		// Swap the positions of the empty tile and the selected tile
		board[emptyRow][emptyCol] = tile;
		board[tileRow][tileCol] = -1;
	}
	else {
		printf(""Invalid move. Try again.\n"");
		// Invalid move. Try again
	}
}",0
htew916,1696216136,4,"#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>

/* The dimensions of the puzzle */
#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int emptyRow, emptyCol;
	int tileRow, tileCol;

	// Find the positions of the empty tile and the selected tile
	FindTile(board, -1, &emptyRow, &emptyCol);
	FindTile(board, tile, &tileRow, &tileCol);

	// Check if the selected tile can be moved (adjacent to the empty tile)
	if ((abs(emptyRow - tileRow) == 1 && emptyCol == tileCol) || (abs(emptyCol - tileCol) == 1 && emptyRow == tileRow)) {
		// Swap the positions of the empty tile and the selected tile
		board[emptyRow][emptyCol] = tile;
		board[tileRow][tileCol] = -1;
	}
}",1
htho943,1695710902,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    // initialising the variables as type int
    // author Hamish thompson
    int newrow, newcol,tilerow, tilecol;
    
    // using FindTile to scan the board 
    FindTile(board, -1, &newrow, &newcol);
    FindTile(board, tile, &tilerow, &tilecol);
    
// chonky if chain then set new values if true
    if ((tilerow - newrow == -1 && tilecol == newcol) || (tilerow - newrow == 1 && tilecol == newcol) || (tilecol - newcol == 1 && tilerow == newrow) || (tilecol - newcol == -1 && tilerow == newrow)) {
        // swap the values around
        board[newrow][newcol] = tile;
        board[tilerow][tilecol] = -1;
    }
}",1
htyl682,1696238902,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col, tilerow,tilecol;
    FindTile( board, tile, &row, &col);
    tilerow = row;
    tilecol = col;
    FindTile( board, -1, &row, &col);
    if ((row==tilerow-1 || row==tilerow+1)||((col==tilecol-1) || (col==tilecol+1))){
        board[row][col]= tile;
        board[tilerow][tilecol] = -1;
    }
}",0
htyl682,1696239107,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col, tilerow,tilecol;
    FindTile( board, tile, &row, &col);
    tilerow = row;
    tilecol = col;
    FindTile( board, -1, &row, &col);
    if (((row==tilerow-1 || row==tilerow+1)&&(col==tilecol))||(((col==tilecol-1) || (col==tilecol+1))&&(row==tilerow))){
        board[row][col]= tile;
        board[tilerow][tilecol] = -1;
    }
}",1
hugn924,1696242904,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int blankrow, blankcol;
	Findtile(board, -1, &blankrow, &blankcol);

	int tilerow, tilecol;
	Findtile(board, tile, &tilerow, &tilecol);

	board[tilerow][tilecol] = -1;
	board[blankrow][blankcol] = tile;
}",0
hugn924,1696242965,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int blankrow, blankcol;
	FindTile(board, -1, &blankrow, &blankcol);

	int tilerow, tilecol;
	FindTile(board, tile, &tilerow, &tilecol);

	board[tilerow][tilecol] = -1;
	board[blankrow][blankcol] = tile;
}",0
hugn924,1696243286,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int blankrow, blankcol;
	FindTile(board, -1, &blankrow, &blankcol);

	int tilerow, tilecol;
	FindTile(board, tile, &tilerow, &tilecol);

	if(
		(blankrow == tilerow - 1 && blankcol == tilecol) || 
		(blankrow == tilerow + 1 && blankcol == tilecol) ||
		(blankrow == tilerow && blankcol == tilecol + 1) ||
		(blankrow == tilerow && blankcol == tilecol - 1)
	){
		return; }

	board[tilerow][tilecol] = -1;
	board[blankrow][blankcol] = tile;
}",0
hugn924,1696243380,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int blankrow, blankcol;
	FindTile(board, -1, &blankrow, &blankcol);

	int tilerow, tilecol;
	FindTile(board, tile, &tilerow, &tilecol);

	if(
		(blankrow == tilerow - 1 && blankcol == tilecol) || 
		(blankrow == tilerow + 1 && blankcol == tilecol) ||
		(blankrow == tilerow && blankcol == tilecol + 1) ||
		(blankrow == tilerow && blankcol == tilecol - 1)
	)
	 
	{
	board[tilerow][tilecol] = -1;
	board[blankrow][blankcol] = tile;}
}",1
hwen116,1695695583,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;
	FindTile(board,tile,&row,&col);
	int temp = tile;
	//Check if the -1 tile is above the chosen tile; -1 tile is below the chosen tile; -1 tile is to the left of 
	//the chosen tile; -1 tile is to the right of the chosen tile
	if (board[row-1][col]==-1){

		board[row][col]=-1;
		board[row-1][col]=temp;
	
	 }else if(board[row+1][col]==-1){

		board[row][col]=-1;
		board[row+1][col]=temp;
		
	 }else if(board[row][col-1]==-1){

		board[row][col]=-1;
		board[row][col-1]=temp;

	 }else if (board[row][col+1]==-1){
		
		board[row][col]=-1;
		board[row][col+1]=temp;
	//If the value is not adjacent else nothing happens
	}
}
",0
hwen116,1695718013,2,"void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos)
{
	int i, j;
	for (i=0; i<NUM_ROWS; i++){
		for (j=0; j<NUM_COLS; j++){
			if (board[i][j]==tile){
				*rowPos = i;
				*colPos = j;
			}
		}
	}
}

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col;
    FindTile(board, tile, &row, &col);
    int temp = tile;
    // Check to see if the tile is in the left or right edge
    if (col==0){ //Left edge
        if (board[row-1][col]==-1){ //Down
            board[row][col] = -1;
            board[row - 1][col] = temp;
        }else if(board[row+1][col]==-1){ //Up
            board[row][col] = -1;
            board[row + 1][col] = temp;
        }else if(board[row][col+1]==-1){ //Right
            board[row][col] = -1;
            board[row][col+1] = temp;
        }
    }else if (col==NUM_COLS - 1){ //Right edge
        if (board[row-1][col]==-1){ //Down
            board[row][col] = -1;
            board[row-1][col] = temp;
        }else if (board[row+1][col]==-1){ //Up
            board[row][col] = -1;
            board[row+1][col] = temp;
        }else if (board[row][col-1]==-1){//Left
            board[row][col] = -1;
            board[row][col-1] = temp;
        }
    }else{
    
        if (board[row - 1][col] == -1){
        // Up
            board[row][col] = -1;
            board[row - 1][col] = temp;
        }else if(board[row + 1][col] == -1){
        // Down
            board[row][col] = -1;
            board[row + 1][col] = temp;
        }else if (board[row][col - 1] == -1){ 
            // Left. 
            board[row][col] = -1;
            board[row][col - 1] = temp;
        }else if (board[row][col + 1] == -1){ 
            // Right
            board[row][col] = -1;
            board[row][col + 1] = temp;

        } 
   }
}",0
hwen116,1695718038,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col;
    FindTile(board, tile, &row, &col);
    int temp = tile;
    // Check to see if the tile is in the left or right edge
    if (col==0){ //Left edge
        if (board[row-1][col]==-1){ //Down
            board[row][col] = -1;
            board[row - 1][col] = temp;
        }else if(board[row+1][col]==-1){ //Up
            board[row][col] = -1;
            board[row + 1][col] = temp;
        }else if(board[row][col+1]==-1){ //Right
            board[row][col] = -1;
            board[row][col+1] = temp;
        }
    }else if (col==NUM_COLS - 1){ //Right edge
        if (board[row-1][col]==-1){ //Down
            board[row][col] = -1;
            board[row-1][col] = temp;
        }else if (board[row+1][col]==-1){ //Up
            board[row][col] = -1;
            board[row+1][col] = temp;
        }else if (board[row][col-1]==-1){//Left
            board[row][col] = -1;
            board[row][col-1] = temp;
        }
    }else{
    
        if (board[row - 1][col] == -1){
        // Up
            board[row][col] = -1;
            board[row - 1][col] = temp;
        }else if(board[row + 1][col] == -1){
        // Down
            board[row][col] = -1;
            board[row + 1][col] = temp;
        }else if (board[row][col - 1] == -1){ 
            // Left. 
            board[row][col] = -1;
            board[row][col - 1] = temp;
        }else if (board[row][col + 1] == -1){ 
            // Right
            board[row][col] = -1;
            board[row][col + 1] = temp;

        } 
   }
}",1
hwin877,1695868765,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tile_row, tile_col, empty_row, empty_col;
	int x = 0;

	FindTile(board, tile, &tile_row, &tile_col);
	FindTile(board, -1, &empty_row, &empty_col);

	if ((abs(tile_row - empty_row) <= 1) && (abs(tile_col - empty_col) <= 1))
	{
		if ((abs(tile_row - empty_row)) * (abs(tile_col - empty_col)) == 0)
		{
			board[tile_row][tile_col] = -1;
			board[empty_row][empty_col] = tile;
		}
	}
}",0
hwin877,1695868786,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tile_row, tile_col, empty_row, empty_col;

	FindTile(board, tile, &tile_row, &tile_col);
	FindTile(board, -1, &empty_row, &empty_col);

	if ((abs(tile_row - empty_row) <= 1) && (abs(tile_col - empty_col) <= 1))
	{
		if ((abs(tile_row - empty_row)) * (abs(tile_col - empty_col)) == 0)
		{
			board[tile_row][tile_col] = -1;
			board[empty_row][empty_col] = tile;
		}
	}
}",1
hyan713,1695853813,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int i,j,rowPos,colPos;
    
    for (i=0;i<NUM_ROWS;i++) {
        for (j=0;j<NUM_COLS;j++) {
            if (board[i][j] == -1){
                rowPos = i;
                colPos = j;
            }
        }
    }
    
    if (board[rowPos-1][colPos] == tile && (rowPos-1)>-1 ){
        board[rowPos-1][colPos] = -1;
        board[rowPos][colPos] = tile;
    } else if (board[rowPos+1][colPos] == tile && (rowPos+1)<NUM_ROWS ){
        board[rowPos+1][colPos] = -1;
        board[rowPos][colPos] = tile;
    } else if (board[rowPos][colPos-1] == tile && (colPos-1)>-1 ){
        board[rowPos][colPos-1] = -1;
        board[rowPos][colPos] = tile;
    } else if (board[rowPos][colPos+1] == tile && (colPos+1)<NUM_COLS ){
        board[rowPos][colPos+1] = -1;
        board[rowPos][colPos] = tile;
    }
    
}",1
hye071,1695753176,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    
    int Tile_Row_empty;
    int Tile_Col_empty;
    int Tile_Row;
    int Tile_Col;
    
   
    
    FindTile(board,-1, &Tile_Row_empty, &Tile_Col_empty);
    FindTile(board, tile, &Tile_Row, &Tile_Col);
    
     int Diff_row=Tile_Row_empty-Tile_Row;
    int Diff_col=Tile_Col_empty-Tile_Col;
    
    if ((Diff_row==1 && Diff_col==0) || ( Diff_col==1 && Diff_row==0)){
           
           board[Tile_Row_empty][Tile_Col_empty]=tile;
           board[Tile_Row][Tile_Col]=-1;
       }

}
",0
hye071,1695763437,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    
    int Tile_Row_empty;
    int Tile_Col_empty;
    int Tile_Row;
    int Tile_Col;
    int Temp_board;
    
  
    
    FindTile(board,-1, &Tile_Row_empty, &Tile_Col_empty);
    FindTile(board, tile, &Tile_Row, &Tile_Col);
    
    int Diff_row=(Tile_Row_empty-Tile_Row);
    int Diff_col=(Tile_Col_empty-Tile_Col);
    
    if ((Diff_row==1 && Tile_Col_empty==Tile_Col) || ( Diff_col==1 && Tile_Row_empty==Tile_Row) || (Diff_col==-1 && Tile_Row_empty==Tile_Row) || (Diff_row==-1 && Tile_Col_empty==Tile_Col)){
        
        Temp_board=board[Tile_Row_empty][Tile_Col_empty];
           
           board[Tile_Row_empty][Tile_Col_empty]=board[Tile_Row][Tile_Col];
           board[Tile_Row][Tile_Col]=Temp_board;
       }

}
",1
ibha186,1696119410,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row,col;
    for (int i = 0; i < NUM_COLS; i++) {
        for (int j = 0; j < NUM_ROWS; j++) {
            int index = board[i][j];
            if (tile == index) {
                FindTile(board, -1, &row, &col);
				printf(""Row:%d\nCol:%d\n"",row,col);
				printf(""i:%d\nj:%d\n"",i,j);
                if ((row == i - 1 || row == i + 1) && (col == j) || ((row == i) && (col == j - 1 || col == j + 1))) {
					printf(""Inside condition:\n"");
                    board[i][j] = -1;
                    board[row][col] = index;
					return;
                }
            }   
        }
    }    
}",0
ibha186,1696120530,2,"#define _CRT_SECURE_NO_WARNINGS
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row,col;
    for (int i = 0; i < NUM_COLS; i++) {
        for (int j = 0; j < NUM_ROWS; j++) {
            int index = board[i][j];
            if (tile == index) {
                FindTile(board, -1, &row, &col);
				printf(""Row:%d\nCol:%d\n"",row,col);
				printf(""i:%d\nj:%d\n"",i,j);
                if ((row == i - 1 || row == i + 1) && (col == j) || ((row == i) && (col == j - 1 || col == j + 1))) {
					printf(""Inside condition:\n"");
                    board[i][j] = -1;
                    board[row][col] = index;
					return;
                }
            }   
        }
    }    
}",0
ibha186,1696121296,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row,col;
    for (int i = 0; i < NUM_COLS; i++) {
        for (int j = 0; j < NUM_ROWS; j++) {
            int index = board[i][j];
            if (tile == index) {
                FindTile(board, -1, &row, &col);
                if ((row == i - 1 || row == i + 1) && (col == j)) {
                    board[i][j] = -1;
                    board[row][col] = index;
					return;
                }
				else if (((row == i) && (col == j - 1 || col == j + 1)))
				{
                    board[i][j] = -1;
                    board[row][col] = index;
					return;
				}
				
            }   
        }
    }    
}",1
ibur427,1695723901,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int blankrow, blankcol;
	int row, col;

	FindTile(board, -1, &blankrow, &blankcol);
	FindTile(board, tile, &row, &col);
	
	if ((blankrow == (row + 1) || blankrow == (row - 1)) && (blankcol != (col + 1) && blankcol != (col - 1))) {
		board[blankrow][blankcol] = tile;
		board[row][col] = -1;
	}

	if ((blankrow != (row + 1) && blankrow != (row - 1)) && (blankcol == (col + 1) || blankcol == (col - 1))) {
		board[blankrow][blankcol] = tile;
		board[row][col] = -1;
	}
}
",0
ibur427,1695792431,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int blankrow, blankcol;
	int row, col;

	FindTile(board, -1, &blankrow, &blankcol);
	FindTile(board, tile, &row, &col);
	
	if ((blankrow == (row + 1) && blankcol == col) || (blankrow == (row - 1) && blankcol == col) || (blankrow == row && blankcol == (col + 1)) || (blankrow == row && blankcol == (col - 1))) {
		board[blankrow][blankcol] = tile;
		board[row][col] = -1;
	}
}",1
iche428,1696153025,1,"oid MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tileRow, tileCol;
	FindTile(board, tile, &tileRow, &tileCol);

	int spaceRow, spaceCol;
	FindTile(board, -1, &spaceRow, &spaceCol);

	if (tileCol == 0 && spaceCol == tileCol+1) {
		board[spaceRow][spaceCol] = tile;
		board[tileRow][tileCol] = -1;
	} 
	else if (tileCol == NUM_COLS-1 && spaceCol == tileCol-1) {
		board[spaceRow][spaceCol] = tile;
		board[tileRow][tileCol] = -1;
	}
	else if (tileRow == 0 && spaceRow == tileRow+1) {
		board[spaceRow][spaceCol] = tile;
		board[tileRow][tileCol] = -1;
	}
	else if (tileRow == NUM_ROWS-1 && spaceRow == tileRow-1) {
		board[spaceRow][spaceCol] = tile;
		board[tileRow][tileCol] = -1;
	}
	else if (spaceCol == tileCol+1 && spaceRow == tileRow) {
		board[spaceRow][spaceCol] = tile;
		board[tileRow][tileCol] = -1;
	}
	else if (spaceCol == tileCol-1 && spaceRow == tileRow) {
		board[spaceRow][spaceCol] = tile;
		board[tileRow][tileCol] = -1;
	}
	else if (spaceRow == tileRow+1 && spaceCol == tileCol) {
		board[spaceRow][spaceCol] = tile;
		board[tileRow][tileCol] = -1;
	}
	else if (spaceRow == tileRow-1 && spaceCol == tileCol) {
		board[spaceRow][spaceCol] = tile;
		board[tileRow][tileCol] = -1;
	}
	else {
		board[spaceRow][spaceCol] = -1;
		board[tileRow][tileCol] = tile;
	}

}
",0
iche428,1696153037,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tileRow, tileCol;
	FindTile(board, tile, &tileRow, &tileCol);

	int spaceRow, spaceCol;
	FindTile(board, -1, &spaceRow, &spaceCol);

	if (tileCol == 0 && spaceCol == tileCol+1) {
		board[spaceRow][spaceCol] = tile;
		board[tileRow][tileCol] = -1;
	} 
	else if (tileCol == NUM_COLS-1 && spaceCol == tileCol-1) {
		board[spaceRow][spaceCol] = tile;
		board[tileRow][tileCol] = -1;
	}
	else if (tileRow == 0 && spaceRow == tileRow+1) {
		board[spaceRow][spaceCol] = tile;
		board[tileRow][tileCol] = -1;
	}
	else if (tileRow == NUM_ROWS-1 && spaceRow == tileRow-1) {
		board[spaceRow][spaceCol] = tile;
		board[tileRow][tileCol] = -1;
	}
	else if (spaceCol == tileCol+1 && spaceRow == tileRow) {
		board[spaceRow][spaceCol] = tile;
		board[tileRow][tileCol] = -1;
	}
	else if (spaceCol == tileCol-1 && spaceRow == tileRow) {
		board[spaceRow][spaceCol] = tile;
		board[tileRow][tileCol] = -1;
	}
	else if (spaceRow == tileRow+1 && spaceCol == tileCol) {
		board[spaceRow][spaceCol] = tile;
		board[tileRow][tileCol] = -1;
	}
	else if (spaceRow == tileRow-1 && spaceCol == tileCol) {
		board[spaceRow][spaceCol] = tile;
		board[tileRow][tileCol] = -1;
	}
	else {
		board[spaceRow][spaceCol] = -1;
		board[tileRow][tileCol] = tile;
	}

}
",0
iche428,1696155688,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tileRow, tileCol;
	FindTile(board, tile, &tileRow, &tileCol);

	int spaceRow, spaceCol;
	FindTile(board, -1, &spaceRow, &spaceCol);
	
	if (tileCol>0 && spaceCol == tileCol-1 && spaceRow == tileRow) {
		board[spaceRow][spaceCol] = tile;
		board[tileRow][tileCol] = -1;
	}
	else if (tileCol<NUM_COLS-1 && spaceCol == tileCol+1 && spaceRow == tileRow) {
		board[spaceRow][spaceCol] = tile;
		board[tileRow][tileCol] = -1;
	}
	else if (tileRow>0 && spaceRow == tileRow-1 && spaceCol == tileCol) {
		board[spaceRow][spaceCol] = tile;
		board[tileRow][tileCol] = -1;
	}
	else if (tileRow<NUM_ROWS+1 && spaceRow == tileRow+1 && spaceCol == tileCol) {
		board[spaceRow][spaceCol] = tile;
		board[tileRow][tileCol] = -1;
	}
}",1
ihoo440,1696218612,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int EmptyRow, EmptyCol;
	int TileRow, TileCol;

	FindTile(board, -1, &EmptyRow, &EmptyCol);
	FindTile(board, tile, &TileRow, &TileCol);

	if((TileCol == EmptyCol && (TileRow == EmptyRow + 1 || TileRow == EmptyRow - 1)) || (TileRow == EmptyRow && (TileCol == EmptyCol + 1 || TileCol == EmptyCol - 1)))
	{
		board[EmptyRow][EmptyCol] = tile;
		board[TileRow][TileCol] = -1;
	}
}",1
ikis164,1696202639,1,"#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row;
    int col;
    int temp;
    FindTile(board, -1, &row, &col);

    if (col - 1 >= 0 && board[row][col - 1] == tile) {
        temp = board [row][col];
        board [row][col] = board [row][col - 1];
        board [row][col - 1] = temp;
    }

    if (col + 1 < NUM_COLS && board[row][col + 1] == tile) {
        temp = board [row][col];
        board [row][col] = board [row][col + 1];
        board [row][col + 1] = temp;
    }

    if (row - 1 >= 0 && board[row - 1][col] == tile) {
        temp = board [row][col];
        board [row][col] = board [row - 1][col];
        board [row - 1][col] = temp;
    }

    if (row + 1 < NUM_ROWS && board[row + 1][col] == tile) {
        temp = board [row][col];
        board [row][col] = board [row + 1][col];
        board [row + 1][col] = temp;
    }
}",1
iko203,1696047304,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int TileRow, TileCol;

    //Call Find Tile Function
    FindTile(board, tile, &TileRow, &TileCol);

    if (TileCol > 0 && board[TileRow][TileCol - 1] == -1) {
        board[TileRow][TileCol - 1] = tile;
        board[TileRow][TileCol] = -1;
    }
    else if (TileRow > 0 && board[TileRow - 1][TileCol] == -1) {
        board[TileRow - 1][TileCol] = tile;
        board[TileRow][TileCol] = -1;
    }
    else if (TileCol < NUM_COLS-1 && board[TileRow][TileCol + 1] == -1) {
        board[TileRow][TileCol + 1] = tile;
        board[TileRow][TileCol] = -1;
    }

    else if (TileRow < NUM_ROWS-1 && board[TileRow + 1][TileCol] == -1) {
        board[TileRow + 1][TileCol] = tile;
        board[TileRow][TileCol] = -1;
    }
    }",1
ilee973,1696134505,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row_tile;
    int col_tile;
    int empt_row;
    int empt_col;
    
    FindTile(board,tile, &row_tile, &col_tile);
    FindTile(board, -1, &empt_row, &empt_col);
    
     if (((row_tile == empt_row) && (abs(col_tile - empt_col) == 1)) || 
     ((col_tile == empt_col) && (abs(row_tile - empt_row) == 1))){
       
    
    board[empt_row][empt_col] = board[row_tile][col_tile];
    board[row_tile][col_tile] = -1;
     }
}",1
imac384,1695853474,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int spacerow, spacecol, tilerow, tilecol;
	FindTile(board, -1, &spacerow, &spacecol);
	FindTile(board, tile, &tilerow, &tilecol);

	int row = tilerow - spacerow;
	int	col = tilecol - spacecol;

	if ((row == 1 && col == 0) || (row == -1 && col == 0) || (row == 0 && col == 1) || (row == 0 && col == -1)) {

		if (tilerow >= 0 && tilerow < NUM_ROWS && tilecol >= 0 && tilecol < NUM_COLS) {
			int temp;
			temp = board[spacerow][spacecol];
			board[spacerow][spacecol] = board[tilerow][tilecol];
			board[tilerow][tilecol] = temp;
		}
	}
	

	
}",1
imoh000,1695807353,1,"#include <stdio.h>

//calling the previous findtile function
void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos)
{
    for(int i = 0; i < NUM_ROWS; i++)
    {
        for(int j = 0; j < NUM_COLS; j++)
        {
            if(board[i][j] == tile)
            {
                *rowPos = i;
                *colPos = j;
                return;
            }
        }
    }
}

//Creating the makemove function
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int TileRow, TileColumn, EmptyRow, EmptyColumn; //storing int value(s)

    //Finding the position(s) of the tile and the empty square by calling the previous function
    FindTile(board, tile, &TileRow, &TileColumn);
    FindTile(board, -1, &EmptyRow, &EmptyColumn); //swapping with negative 1 so it satisfies the brief

    //Checking if the tile and the empty square are adjacent 
    if((TileRow == EmptyRow && abs(TileColumn - EmptyColumnumn) == 1) || (TileColumn == EmptyColumnumn && abs(TileRow - EmptyRow) == 1)) //using absolute function to our benefit
    {
        //Finally, swapping the tile and the empty square (so the game behaves how it should)
        board[EmptyRow][EmptyColumn] = board[TileRow][TileColumn];
        board[TileRow][TileColumn] = -1;
    }
}
",0
imoh000,1695808292,2,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	{
		int TileRow, TileColumn, EmptyRow, EmptyColumn;

		//Finding the position(s) of the tile and the empty square by calling the previous function
		FindTile(board, tile, &TileRow, &TileColumn);
		FindTile(board, -1, &EmptyRow, &EmptyColumn);

		//Checking if the tile and the empty square are adjacent 
		if ((TileRow == EmptyRow && ((TileColumn > EmptyColumn) ? (TileColumn - EmptyColumn == 1) : (EmptyColumn - TileColumn == 1))) || //'?' is shorthand for 'if-else'
			(TileColumn == EmptyColumn && ((TileRow > EmptyRow) ? (TileRow - EmptyRow == 1) : (EmptyRow - TileRow == 1))))
		{
			//Finally, swapping the tile and the empty square (so the game behaves how it should)
			board[EmptyRow][EmptyColumn] = board[TileRow][TileColumn];
			board[TileRow][TileColumn] = -1;
		}
	}

}",1
iwes050,1695761508,1,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int empty_row;
	int empty_col;
	int tile_row;
	int tile_col;

//If -1 is not where the empty row and column is, then the empty square isn't found.
if (!FindTile(board, -1, &empty_row, &empty_col)) {
	printf(""Empty square not found!\n"");
	return;
}
//If the tile being searched for isn't where the row and col of the tile is, then the tile isn't found.
if (!FindTile(board, tile, &tile_row, &tile_col)) {
	printf(""Tile not found!\n"");
	return;
}

//Check is tile is adjacent to empty square
if (((empty_row - tile_row) == 1 && empty_col == tile_col) ||
        ((empty_col - tile_col) == 1 && empty_row == tile_row)) {
        // If one of the conditions above are met then swap the tile and the empty square
        int empty_pos = board[empty_row][empty_col];
		board[empty_row][empty_col] = board[tile_row][tile_col];
        board[tile_row][tile_col] = empty_pos;		
        printf(""Move successful!\n"");

    } else {
        printf(""Tile is not adjacent to the empty square!\n"");
    }

}

",0
iwes050,1695776438,2,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int empty_row;
	int empty_col;
	int tile_row;
	int tile_col;

//If -1 is not where the empty row and column is, then the empty square isn't found.
if (FindTile(board, -1, &empty_row, &empty_col)) {
	printf(""Empty square not found!\n"");
	return;
}
//If the tile being searched for isn't where the row and col of the tile is, then the tile isn't found.
if (FindTile(board, tile, &tile_row, &tile_col)) {
	printf(""Tile not found!\n"");
	return;
}

//Check is tile is adjacent to empty square
if (((empty_row - tile_row) == 1 && empty_col == tile_col) ||
        ((empty_col - tile_col) == 1 && empty_row == tile_row)) {
        // If one of the conditions above are met then swap the tile and the empty square
        int empty_pos = board[empty_row][empty_col];
		board[empty_row][empty_col] = board[tile_row][tile_col];
        board[tile_row][tile_col] = empty_pos;		
        printf(""Move successful!\n"");

    } else {
        printf(""Tile is not adjacent to the empty square!\n"");
    }

}

",0
iwes050,1695777951,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int empty_row;
	int empty_col;
	int tile_row;
	int tile_col;

(FindTile(board, -1, &empty_row, &empty_col));
(FindTile(board, tile, &tile_row, &tile_col)); 

//Check is tile is adjacent to empty square
//printf(""%d %d \n"", tile_row, tile_col);
if (((empty_row - tile_row) == 1 && (empty_col == tile_col)) ||
        ((empty_col - tile_col) == 1 && (empty_row == tile_row))) {
        // If one of the conditions above are met then swap the tile and the empty square
        int empty_pos = board[empty_row][empty_col];
		board[empty_row][empty_col] = board[tile_row][tile_col];
        board[tile_row][tile_col] = empty_pos;		
}
}

",0
iwes050,1695779017,4,"#include <stdio.h>
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int empty_row;
	int empty_col;
	int tile_row;
	int tile_col;

(FindTile(board, -1, &empty_row, &empty_col));
(FindTile(board, tile, &tile_row, &tile_col)); 

//Check is tile is adjacent to empty square
//printf(""%d %d \n"", tile_row, tile_col);
if (((empty_row - tile_row) == 1) && (empty_col == tile_col))
         {
        // If one of the conditions above are met then swap the tile and the empty square
        int empty_pos = board[empty_row][empty_col];
		board[empty_row][empty_col] = board[tile_row][tile_col];
        board[tile_row][tile_col] = empty_pos;		
}
if (((empty_col - tile_col) == 1) && (empty_row == tile_row))
        {
        // If one of the conditions above are met then swap the tile and the empty square
        int empty_pos = board[empty_row][empty_col];
		board[empty_row][empty_col] = board[tile_row][tile_col];
        board[tile_row][tile_col] = empty_pos;		
}

if (((empty_row - tile_row) == -1) && (empty_col == tile_col))
         {
        // If one of the conditions above are met then swap the tile and the empty square
        int empty_pos = board[empty_row][empty_col];
		board[empty_row][empty_col] = board[tile_row][tile_col];
        board[tile_row][tile_col] = empty_pos;		
}
if (((empty_col - tile_col) == -1) && (empty_row == tile_row))
        {
        // If one of the conditions above are met then swap the tile and the empty square
        int empty_pos = board[empty_row][empty_col];
		board[empty_row][empty_col] = board[tile_row][tile_col];
        board[tile_row][tile_col] = empty_pos;		
}

}",1
iwoo382,1695724328,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row1, col1, row2, col2;
	FindTile(board, tile, &row1, &col1);
	FindTile(board, -1, &row2, &col2);

	if ((row1 == row2 && col1 == col2 - 1) || (row1 == row2 && col1 == col2 + 1) || (col1 == col2 && row1 == row2 - 1) || (col1 == col2 && row1 == row2 + 1)) {
		board[row1][col1] = board[row2][col2];
		board[row2][col2] = tile;

	}
}",1
ixia229,1696162896,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int EmptyRow, EmptyCol;
	int TileRow, TileCol;
	
	FindTile(board, -1 , &EmptyRow, &EmptyCol);
	FindTile(board, tile, &TileRow, &TileCol);

	if ((TileRow == EmptyRow && (TileCol == EmptyCol + 1 || TileCol == EmptyCol - 1)) ||
		(TileCol == EmptyCol && (TileRow == EmptyRow + 1 || TileRow == EmptyRow - 1))){
			board[EmptyRow][EmptyCol] = tile;
			board[TileRow][TileCol] = -1;
			}
			else{
			}
}",1
ixu871,1695876001,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
   int i, j, tileR, tileC;
   
   FindTile(board, -1, &i, &j);
   FindTile(board, tile, &tileR, &tileC);

if ((tileR == i && (tileC == j + 1 || tileC == j - 1)) ||
        (tileC == j && (tileR == i + 1 || tileR == i - 1))) {
    int *emptytile = &board[i][j];
        int *Movedtile = &board[tileR][tileC];

         int Tile2 = *emptytile;
        *emptytile = *Movedtile;
        *Movedtile = Tile2;
                Movedtile = &tile;
            }
        }",1
jahn224,1695793590,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int i,j;
    int tile_row, tile_col;
    int empty_row, empty_col;
    
    //find posotion of tile
    for (i=0; i<NUM_ROWS; i++) {
        for (j=0; j<NUM_COLS; j++) {
            if (board[i][j]==tile) {
                tile_row = i;
                tile_col = j;
            }
            if (board[i][j]==-1) {
                empty_row = i;
                empty_col = j;
            }
        }
    }
    
    if ((tile_row - empty_row == -1 || tile_row - empty_row == 1) || (tile_col - empty_col == -1 || tile_col - empty_col == 1)) {
 
       board[tile_row][tile_col] = -1;
       board[empty_row][empty_col] = tile;
    }
}
",0
jahn224,1695801188,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int i,j;
    int tile_row, tile_col;
    int empty_row, empty_col;
    
    //find posotion of tile
    for (i=0; i<NUM_ROWS; i++) {
        for (j=0; j<NUM_COLS; j++) {
            if (board[i][j]==tile) {
                tile_row = i;
                tile_col = j;
            }
            if (board[i][j]==-1) {
                empty_row = i;
                empty_col = j;
            }
        }
    }
    
    if ((tile_row - empty_row == -1 || tile_row - empty_row == 1) && (tile_col==empty_col)) {
        board[tile_row][tile_col] = -1;
       board[empty_row][empty_col] = tile;
    }
    
    if ((tile_col - empty_col == -1 || tile_col - empty_col == 1) && (tile_row==empty_row)) {
 
       board[tile_row][tile_col] = -1;
       board[empty_row][empty_col] = tile;
    }
}
",1
jbag235,1696237744,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j, tile2, temp;
	tile2 = -1;
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == tile2) {
				if (tile == board[i-1][j]) {
					board[i][j] = tile;
					board[i-1][j] = tile2;
				}
				else if (tile == board[i][j-1]) {
					board[i][j] = tile;
					board[i][j-1] = tile2;
				}
				else if (tile == board[i+1][j]) {
					board[i][j] = tile;
					board[i+1][j] = tile2;
				}
				else if (tile == board[i][j+1]) {
					board[i][j] = tile;
					board[i][j+1] = tile2;
				}
			}
		}
	}
}",0
jbag235,1696237758,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j, tile2;
	tile2 = -1;
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == tile2) {
				if (tile == board[i-1][j]) {
					board[i][j] = tile;
					board[i-1][j] = tile2;
				}
				else if (tile == board[i][j-1]) {
					board[i][j] = tile;
					board[i][j-1] = tile2;
				}
				else if (tile == board[i+1][j]) {
					board[i][j] = tile;
					board[i+1][j] = tile2;
				}
				else if (tile == board[i][j+1]) {
					board[i][j] = tile;
					board[i][j+1] = tile2;
				}
			}
		}
	}
}",0
jbam701,1696222754,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int valuerow;
	int valuecol;
	FindTile(board, tile, &valuerow, &valuecol);

	int emptyrow;
	int emptycol;
	FindTile(board, -1, &emptyrow, &emptycol);


	if (valuerow >= 0 && valuerow < NUM_ROWS) {
		if (valuerow == (emptyrow - 1)) {
			if (valuecol == emptycol) {
				board[emptyrow][emptycol] = tile;
				board[valuerow][valuecol] = -1;
			}
		}
	}

	if (valuecol >= 0 && valuecol < NUM_COLS) {
		if (valuecol == (emptycol - 1)) {
			if (valuerow == emptyrow) {
				board[emptyrow][emptycol] = tile;
				board[valuerow][valuecol] = -1;
			}
		}
	}

	if (valuerow > 0 && valuerow <= NUM_ROWS) {
		if (valuerow == (emptyrow + 1)) {
			if (valuecol == emptycol) {
				board[emptyrow][emptycol] = tile;
				board[valuerow][valuecol] = -1;
			}
		}
	}

	if (valuecol > 0 && valuecol <= NUM_COLS) {
		if (valuecol == emptycol + 1) {
			if (valuerow == emptyrow) {
				board[emptyrow][emptycol] = tile;
				board[valuerow][valuecol] = -1;
			}
		}
	}
}",1
jbis394,1696238587,1,"void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos)
{
for (int row = 0; row<NUM_ROWS; row++)
{
for (int col = 0; col<NUM_COLS; col++)
{
if (board[row][col] == tile)
{
    *rowPos = row;
    *colPos = col;
return;
}
}
}
}",0
jbis394,1696238892,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
int emptyRow, emptyCol;
FindTile(board, -1, &emptyRow, &emptyCol);
int tileRow, tileCol;
FindTile(board, tile, &tileRow, &tileCol);
if ((tileRow == emptyRow && (tileCol == emptyCol - 1 || tileCol == emptyCol + 1)) ||
(tileCol == emptyCol && (tileRow == emptyRow - 1 || tileRow == emptyRow + 1)))
{
board[emptyRow][emptyCol] = tile;
board[tileRow][tileCol] = -1;}
}",1
jbro301,1695792681,1,"// This moves the selected piece into the position of the empy tile
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

{   int i;
    int j;
    int emptyrow;
    int emptycol;
    int tilerow;
    int tilecol;
  
    
// Find position of empty tile and store address   
    for (i=0;i<NUM_ROWS;i++) {
    for (j=0;j<NUM_COLS;j++) {
    if (board[i][j]==-1) {
    emptyrow = i;
    emptycol= j;
    }
    }
    }
    
    int *blank = &board[emptyrow][emptycol];

// Find position of value tile and store address    
    for (i=0;i<NUM_ROWS;i++) {
    for (j=0;j<NUM_COLS;j++) {
    if (board[i][j]==tile) {
    tilerow = i;
    tilecol= j;
    }
    }
    }
    
    int *t = &board[tilerow][tilecol];
// Calculate space between empty tile and value tile    
    int rowdiff;
    rowdiff = (tilerow-emptyrow);
    int coldiff;
    coldiff = (tilecol-emptycol);
    
// If space is greater than one in any direction, do not move tile     
    if ((rowdiff <-1) || (coldiff < -1) || (rowdiff > 1 )|| (coldiff > 1)) {
             
    } 
    
// If space is zero in any one direction, then move tile    
    else if ((rowdiff ==0)||(coldiff ==0)) {
       
        
        *blank = *t;
        *t = -1;
    }
    else {
            
    }
    
  
    return;
}",1
jcha513,1695994246,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int findRow, findCol, row, col;
    
    FindTile(board, tile, &findRow, &findCol);
    FindTile(board, -1, &row, &col);

    if((findRow==row && (findCol==col+1||findCol==col-1)) || (findCol==col && (findRow==row+1||findRow==row-1))) {
     
        board[findRow][findCol]= -1;
        board[row][col] = tile;
        
    }
}",1
jcha574,1695941814,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int i,j,row,col;
    int cngr,cngc;
    
    for(i=0;i<NUM_ROWS;i++) {
        for(j=0;j<NUM_COLS;j++) {
            if (board[i][j]==-1) {
                row = i;
                col = j;
                break;
            }

    }
    }
    for(i=0;i<NUM_ROWS;i++) {
        for(j=0;j<NUM_COLS;j++){
            if (board[i][j] == tile) {
            cngr = i;
            cngc =j;
        }

    }
    }
    if ((cngr==row-1) && (cngc ==col-1)) {
        board[row][col] = tile;
        board[cngr][cngc] = -1;
    }
    else if ((cngr==row+1) && (cngc==col-1)) {
        board[row][col] = tile;
        board[cngr][cngc] = -1;

    }
    else if ((cngr==row+1) && (cngc== col+1)) {
        board[row][col] = tile;
        board[cngr][cngc] = -1;
    }
    else if ((cngr==row-1) && (cngc==col+1)) {
        board[row][col] = tile;
        board[cngr][cngc] = -1;
    }
    else if ((cngr== row) && (cngc == col+1)) {
        board[row][col] = tile;
        board[cngr][cngc] = -1;
    }
    else if ((cngr== row) && (cngc == col-1)) {
        board[row][col] = tile;
        board[cngr][cngc] = -1;
    }
    else if ((cngr==row-1)&&(cngc==col)) {
        board[row][col] = tile;
        board[cngr][cngc] = -1;
    }
    else if ((cngr==row+1) && (cngc==col)) {
        board[row][col] = tile;
        board[cngr][cngc] = -1;
    }
}",1
jcha972,1696218261,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowTile, colTile;
    int rowEmpty, colEmpty;
    FindTile(board, tile, &rowTile, &colTile);
    FindTile(board, -1, &rowEmpty, &colEmpty);
    
    if (rowTile == rowEmpty) {
        if ((colTile - colEmpty == 1) || (colEmpty - colTile == 1)) {
            board[rowEmpty][colEmpty] = tile;
            board[rowTile][colTile] = -1;
        }
        
    }
    else if(colTile == colEmpty) {
        if ((rowTile - rowEmpty == 1) || (rowEmpty - rowTile == 1)) {
            board[rowEmpty][colEmpty] = tile;
            board[rowTile][colTile] = -1;
        }    
    }
}",1
jche456,1696237300,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int emptyrow, emptycol, tilerow, tilecol, rowdiff, coldiff;
	FindTile(board, -1, &emptyrow, &emptycol);
	FindTile(board, tile, &tilerow, &tilecol);
	rowdiff = emptyrow - tilerow;
	
	if (rowdiff < 0) {
		rowdiff = rowdiff * -1;
	}
	coldiff = emptycol - tilecol;
	if (coldiff < 0) {
		coldiff = coldiff * -1;
	}

	if ((rowdiff == 1 && coldiff == 0) || (rowdiff == 0 && coldiff == 1)) {
		board[emptyrow][emptycol] = tile;
		board[tilerow][tilecol] = -1;
	}
}",1
jchi648,1696157791,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    
    int temp, aRow, aCol, bRow, bCol, row, col;
    FindTile(board, -1, &row, &col);
    aRow = row;
    aCol = col;
    FindTile(board, tile, &row, &col);
    bRow = row;
    bCol = col;
    
    if(aCol == bCol) {
        if (abs(aRow-bRow) <= 1) {
            temp = board[aRow][aCol];
            board[aRow][aCol] = board[bRow][bCol];
            board[bRow][bCol] = temp;
        }
    }
}",0
jchi648,1696158194,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    
    int temp, aRow, aCol, bRow, bCol, row, col;
    FindTile(board, -1, &row, &col);
    aRow = row;
    aCol = col;
    FindTile(board, tile, &row, &col);
    bRow = row;
    bCol = col;
    
    if(aCol == bCol || aRow == bRow) {
        if (abs(aRow-bRow) <= 1) {
            temp = board[aRow][aCol];
            board[aRow][aCol] = board[bRow][bCol];
            board[bRow][bCol] = temp;
        }
    }
    
}",1
jchu579,1695958776,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int temp;

	int emptyRow, emptyCol;
	FindTile(board, -1, &emptyRow, &emptyCol);
	printf(""%d %d\n"", emptyRow, emptyCol);

	int test = board[emptyRow][emptyCol];
	printf(""%d\n"", test);

	int moveRow, moveCol;
	FindTile(board, tile, &moveRow, &moveCol);
	printf(""%d %d\n"", moveRow, moveCol);

	if (moveRow == emptyRow && moveCol == emptyCol) {
		printf(""All equal\n"");
		return;
	}

    // top
	if ((emptyRow - 1) == moveRow && emptyCol == moveCol) {
		temp = board[moveRow][moveCol];
		printf(""%d\n"", temp);
		board[emptyRow][emptyCol] = temp;
		printf(""%d\n"", board[emptyRow][emptyCol]);
		board[moveRow][moveCol] = -1;
		printf(""%d\n"", board[moveRow][moveRow]);
		printf(""Top\n"");
	}

	// bottom
	if ((emptyRow + 1) == moveRow && emptyCol == moveCol) {
		temp = board[moveRow][moveCol];
		board[emptyRow][emptyCol] = temp;
		board[moveRow][moveRow] = -1;
		printf(""bot\n"");
	}

	// right 
	if (emptyRow == moveRow && (emptyCol + 1) == moveCol) {
		temp = board[moveRow][moveCol];
		board[emptyRow][emptyCol] = temp;
		board[moveRow][moveRow] = -1;
		printf(""right\n"");
	}

	// left
	if (emptyRow == moveRow && (emptyCol - 1) == moveCol) {
		temp = board[moveRow][moveCol];
		board[emptyRow][emptyCol] = temp;
		board[moveRow][moveRow] = -1;
		printf(""left\n"");
	}
};
",0
jchu579,1695958822,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int temp;

	int emptyRow, emptyCol;
	FindTile(board, -1, &emptyRow, &emptyCol);

	int test = board[emptyRow][emptyCol];
	
	int moveRow, moveCol;
	FindTile(board, tile, &moveRow, &moveCol);

	if (moveRow == emptyRow && moveCol == emptyCol) {
		return;
	}

    // top
	if ((emptyRow - 1) == moveRow && emptyCol == moveCol) {
		temp = board[moveRow][moveCol];
		board[emptyRow][emptyCol] = temp;
		board[moveRow][moveCol] = -1;
	}

	// bottom
	if ((emptyRow + 1) == moveRow && emptyCol == moveCol) {
		temp = board[moveRow][moveCol];
		board[emptyRow][emptyCol] = temp;
		board[moveRow][moveRow] = -1;
	}

	// right 
	if (emptyRow == moveRow && (emptyCol + 1) == moveCol) {
		temp = board[moveRow][moveCol];
		board[emptyRow][emptyCol] = temp;
		board[moveRow][moveRow] = -1;
	}

	// left
	if (emptyRow == moveRow && (emptyCol - 1) == moveCol) {
		temp = board[moveRow][moveCol];
		board[emptyRow][emptyCol] = temp;
		board[moveRow][moveRow] = -1;
	}
};
",0
jchu579,1695958836,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int temp;

	int emptyRow, emptyCol;
	FindTile(board, -1, &emptyRow, &emptyCol);

	int moveRow, moveCol;
	FindTile(board, tile, &moveRow, &moveCol);

	if (moveRow == emptyRow && moveCol == emptyCol) {
		return;
	}

    // top
	if ((emptyRow - 1) == moveRow && emptyCol == moveCol) {
		temp = board[moveRow][moveCol];
		board[emptyRow][emptyCol] = temp;
		board[moveRow][moveCol] = -1;
	}

	// bottom
	if ((emptyRow + 1) == moveRow && emptyCol == moveCol) {
		temp = board[moveRow][moveCol];
		board[emptyRow][emptyCol] = temp;
		board[moveRow][moveRow] = -1;
	}

	// right 
	if (emptyRow == moveRow && (emptyCol + 1) == moveCol) {
		temp = board[moveRow][moveCol];
		board[emptyRow][emptyCol] = temp;
		board[moveRow][moveRow] = -1;
	}

	// left
	if (emptyRow == moveRow && (emptyCol - 1) == moveCol) {
		temp = board[moveRow][moveCol];
		board[emptyRow][emptyCol] = temp;
		board[moveRow][moveRow] = -1;
	}
};
",0
jchu579,1695959064,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int temp;

	int emptyRow, emptyCol;
	FindTile(board, -1, &emptyRow, &emptyCol);

	int test = board[emptyRow][emptyCol];
	
	int moveRow, moveCol;
	FindTile(board, tile, &moveRow, &moveCol);

	if (moveRow == emptyRow && moveCol == emptyCol) {
		return;
	}

    // top
	if ((emptyRow - 1) == moveRow && emptyCol == moveCol) {
		temp = board[moveRow][moveCol];
		board[emptyRow][emptyCol] = temp;
		board[moveRow][moveCol] = -1;
	}

	// bottom
	if ((emptyRow + 1) == moveRow && emptyCol == moveCol) {
		temp = board[moveRow][moveCol];
		board[emptyRow][emptyCol] = temp;
		board[moveRow][moveCol] = -1;
	}

	// right 
	if (emptyRow == moveRow && (emptyCol + 1) == moveCol) {
		temp = board[moveRow][moveCol];
		board[emptyRow][emptyCol] = temp;
		board[moveRow][moveCol] = -1;
	}

	// left
	if (emptyRow == moveRow && (emptyCol - 1) == moveCol) {
		temp = board[moveRow][moveCol];
		board[emptyRow][emptyCol] = temp;
		board[moveRow][moveCol] = -1;
	}
};
",0
jchu579,1695959133,5,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int temp;

	int emptyRow, emptyCol;
	FindTile(board, -1, &emptyRow, &emptyCol);

	int moveRow, moveCol;
	FindTile(board, tile, &moveRow, &moveCol);

	if (moveRow == emptyRow && moveCol == emptyCol) {
		return;
	}

    // top
	if ((emptyRow - 1) == moveRow && emptyCol == moveCol) {
		temp = board[moveRow][moveCol];
		board[emptyRow][emptyCol] = temp;
		board[moveRow][moveCol] = -1;
	}

	// bottom
	if ((emptyRow + 1) == moveRow && emptyCol == moveCol) {
		temp = board[moveRow][moveCol];
		board[emptyRow][emptyCol] = temp;
		board[moveRow][moveCol] = -1;
	}

	// right 
	if (emptyRow == moveRow && (emptyCol + 1) == moveCol) {
		temp = board[moveRow][moveCol];
		board[emptyRow][emptyCol] = temp;
		board[moveRow][moveCol] = -1;
	}

	// left
	if (emptyRow == moveRow && (emptyCol - 1) == moveCol) {
		temp = board[moveRow][moveCol];
		board[emptyRow][emptyCol] = temp;
		board[moveRow][moveCol] = -1;
	}
};
",1
jcla431,1695718186,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowPosition;
	int colPosition;
	int emptyRow;
	int emptyCol;
	int temp;
	FindTile(board, tile, &rowPosition, &colPosition);
	FindTile(board, -1, &emptyRow, &emptyCol);

	if (board[rowPosition][colPosition + 1] != -1 && board[rowPosition][colPosition - 1] != -1 && board[rowPosition + 1][colPosition] != -1 && board[rowPosition - 1][colPosition] != -1)
	{
		return;
	}

	else
	{
		temp = board[rowPosition][colPosition]; 
		board[rowPosition][colPosition] = board[emptyRow][emptyCol]; 
		board[emptyRow][emptyCol] = temp; 
	}

}",0
jcla431,1695870306,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowPosition;
	int colPosition;
	int emptyRow;
	int emptyCol;
	int temp;
	FindTile(board, tile, &rowPosition, &colPosition);
	FindTile(board, -1, &emptyRow, &emptyCol);

	if (board[rowPosition][colPosition + 1] != -1 && board[rowPosition][colPosition - 1] != -1 && board[rowPosition + 1][colPosition] != -1 && board[rowPosition - 1][colPosition] != -1)
	{
		return;
	}

	else if (colPosition == 3 && emptyCol == 0)
	{
		return;
	}

	else if (colPosition == 0 && emptyCol == 3)
	{
		return;
	}

	else
	{
		temp = board[rowPosition][colPosition]; 
		board[rowPosition][colPosition] = board[emptyRow][emptyCol]; 
		board[emptyRow][emptyCol] = temp; 
	}

}",1
jcla755,1695781977,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowPos, colPos;
    FindTile(board, tile, &rowPos, &colPos);

    int emptyRowPos, emptyColPos;
    FindTile(board, -1, &emptyRowPos, &emptyColPos);

    // Check if empty is one space away from tile to be moved
    int move = 0;
    // Above
    if(board[emptyRowPos-1][emptyColPos] == tile && emptyRowPos-1 > 0)
    {
        move = 1;
    }

    // Left
    else if(board[emptyRowPos][emptyColPos-1] == tile && emptyColPos-1 > 0)
    {
        move = 1;
    }

    // Right
    else if(board[emptyRowPos][emptyColPos+1] == tile && emptyColPos+1 < NUM_COLS)
    {
        move = 1;
    }

    // Down
    else if(board[emptyRowPos+1][emptyColPos] == tile && emptyRowPos+1 < NUM_ROWS)
    {
        move = 1;
    }

    // Move 
    if(move == 1)
    {
        board[emptyRowPos][emptyColPos] = tile;
        board[rowPos][colPos] = -1;
    }

}",0
jcla755,1695782125,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowPos, colPos;
    FindTile(board, tile, &rowPos, &colPos);

    int emptyRowPos, emptyColPos;
    FindTile(board, -1, &emptyRowPos, &emptyColPos);

    // Check if empty is one space away from tile to be moved
    int move = 0;
    // Above
    if(board[emptyRowPos-1][emptyColPos] == tile && emptyRowPos-1 > -1)
    {
        move = 1;
    }

    // Left
    else if(board[emptyRowPos][emptyColPos-1] == tile && emptyColPos-1 > -1)
    {
        move = 1;
    }

    // Right
    else if(board[emptyRowPos][emptyColPos+1] == tile && emptyColPos+1 < NUM_COLS)
    {
        move = 1;
    }

    // Down
    else if(board[emptyRowPos+1][emptyColPos] == tile && emptyRowPos+1 < NUM_ROWS)
    {
        move = 1;
    }

    // Move 
    if(move == 1)
    {
        board[emptyRowPos][emptyColPos] = tile;
        board[rowPos][colPos] = -1;
    }

}",1
jdal353,1696235293,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {

    int tileRow, tileCol;
    int emptyRow, emptyCol;

    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol);

    if ((abs(tileRow - emptyRow) == 1 && tileCol == emptyCol) ||
        (abs(tileCol - emptyCol) == 1 && tileRow == emptyRow)) {
    
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}",1
jdea126,1695996513,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j;
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == tile) {


				if (i > 0 && board[i - 1][j] == -1) {
					board[i - 1][j] = board[i][j];
					board[i][j] = -1;
				} else if (i < (NUM_ROWS - 1) && board[i + 1][j] == -1) {
					board[i+1][j] = board[i][j];
					board[i][j] = -1;
				} else if (j > 0 && board[i][j - 1] == -1) {
					board[i][j - 1] = board[i][j];
					board[i][j] = -1;
				} else if (j < (NUM_COLS-1) && board[i][j + 1] == -1) {
					board[i][j + 1] = board[i][j];
					board[i][j] = -1;
				}
			}
		}
	}
}",0
jdea126,1695999374,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j;
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == tile) {

				if (i > 0 && board[i-1][j] == -1) {
					board[i-1][j] = board[i][j];
					board[i][j] = -1;
					return;
				}
				if (i < (NUM_ROWS-1) && board[i+1][j] == -1) {
					board[i+1][j] = board[i][j];
					board[i][j] = -1;
					return;
				}
				if (j > 0 && board[i][j-1] == -1) {
					board[i][j-1] = board[i][j];
					board[i][j] = -1;
					return;
				}
				if (j < (NUM_COLS-1) && board[i][j+1] == -1) {
					board[i][j+1] = board[i][j];
					board[i][j] = -1;
					return;
				}
			}
		}
	}
}",1
jdu853,1695725220,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowPos, colPos ;

	FindTile(board, tile, &rowPos, &colPos );

	int temp = board[rowPos][colPos];

// if in middle 4 things of board
if (rowPos > 0 && rowPos < NUM_ROWS -1 && colPos > 0 && colPos < NUM_COLS -1)
{
	// check above
	if (board[rowPos - 1][colPos] == -1){
		board[rowPos][colPos] = board[rowPos -1][colPos];
		board[rowPos -1][colPos] = temp;
	}

	// check below
	if (board[rowPos + 1][colPos] == -1){
		board[rowPos][colPos] = board[rowPos +1][colPos];
		board[rowPos +1][colPos] = temp;
	}

	// check right
	if (board[rowPos][colPos +1] == -1){
		board[rowPos][colPos] = board[rowPos][colPos +1];
		board[rowPos][colPos +1] = temp;
	}
	
	// check left
	if (board[rowPos][colPos -1] == -1){
		board[rowPos][colPos] = board[rowPos][colPos -1];
		board[rowPos][colPos -1] = temp;
	}

	}

// if we are rop left cormner only look down and right
if (rowPos == 0 && colPos == 0){
	
	// check below
	if (board[rowPos + 1][colPos] == -1){
		board[rowPos][colPos] = board[rowPos +1][colPos];
		board[rowPos +1][colPos] = temp;
	}

	// check right
	if (board[rowPos][colPos +1] == -1){
		board[rowPos][colPos] = board[rowPos][colPos +1];
		board[rowPos][colPos +1] = temp;
	}

}

// if in top right corner look down and left
if (rowPos == 0 && colPos == NUM_COLS -1)
{

	// check below
	if (board[rowPos + 1][colPos] == -1){
		board[rowPos][colPos] = board[rowPos +1][colPos];
		board[rowPos +1][colPos] = temp;
	}

	// check left
	if (board[rowPos][colPos -1] == -1){
		board[rowPos][colPos] = board[rowPos][colPos -1];
		board[rowPos][colPos -1] = temp;
	}
}

// if in bottom left corner, look up and right
if(rowPos == NUM_ROWS-1 && colPos == 0){
	// check above
	if (board[rowPos - 1][colPos] == -1){
		board[rowPos][colPos] = board[rowPos -1][colPos];
		board[rowPos -1][colPos] = temp;
	}

	// check right
	if (board[rowPos][colPos +1] == -1){
		board[rowPos][colPos] = board[rowPos][colPos +1];
		board[rowPos][colPos +1] = temp;
	}

}

// if in bottom right corner look up and left
if(rowPos == NUM_ROWS -1 && colPos == NUM_COLS -1){
	// check above
	if (board[rowPos - 1][colPos] == -1){
		board[rowPos][colPos] = board[rowPos -1][colPos];
		board[rowPos -1][colPos] = temp;
	}
	// check left
	if (board[rowPos][colPos -1] == -1){
		board[rowPos][colPos] = board[rowPos][colPos -1];
		board[rowPos][colPos -1] = temp;
	}
}

// if in left middle two look up down and right
if (rowPos > 0 && rowPos < NUM_ROWS-1 && colPos == 0)
{
	// check above
	if (board[rowPos - 1][colPos] == -1){
		board[rowPos][colPos] = board[rowPos -1][colPos];
		board[rowPos -1][colPos] = temp;
	}

	// check below
	if (board[rowPos + 1][colPos] == -1){
		board[rowPos][colPos] = board[rowPos +1][colPos];
		board[rowPos +1][colPos] = temp;
	}

	// check right
	if (board[rowPos][colPos +1] == -1){
		board[rowPos][colPos] = board[rowPos][colPos +1];
		board[rowPos][colPos +1] = temp;
	}

}

// if in right middle 2 look right and up and down
if (rowPos > 0 && rowPos < NUM_ROWS-1 && colPos == NUM_COLS - 1)
{
	// check above
	if (board[rowPos - 1][colPos] == -1){
		board[rowPos][colPos] = board[rowPos -1][colPos];
		board[rowPos -1][colPos] = temp;
	}

	// check below
	if (board[rowPos + 1][colPos] == -1){
		board[rowPos][colPos] = board[rowPos +1][colPos];
		board[rowPos +1][colPos] = temp;
	}

	// check left
	if (board[rowPos][colPos -1] == -1){
		board[rowPos][colPos] = board[rowPos][colPos -1];
		board[rowPos][colPos -1] = temp;
	}
}

// if in middle top 2 look left right down
if (rowPos ==0 && colPos>0 && colPos < NUM_COLS-1)
{
	// check below
	if (board[rowPos + 1][colPos] == -1){
		board[rowPos][colPos] = board[rowPos +1][colPos];
		board[rowPos +1][colPos] = temp;
	}

	// check right
	if (board[rowPos][colPos +1] == -1){
		board[rowPos][colPos] = board[rowPos][colPos +1];
		board[rowPos][colPos +1] = temp;
	}
	
	// check left
	if (board[rowPos][colPos -1] == -1){
		board[rowPos][colPos] = board[rowPos][colPos -1];
		board[rowPos][colPos -1] = temp;
	}
}

// if in middle bottm 2 look up legft right
if (rowPos == NUM_ROWS-1 && colPos>0 && colPos < NUM_COLS-1)
{

	// check above
	if (board[rowPos - 1][colPos] == -1){
		board[rowPos][colPos] = board[rowPos -1][colPos];
		board[rowPos -1][colPos] = temp;
	}
	
	// check right
	if (board[rowPos][colPos +1] == -1){
		board[rowPos][colPos] = board[rowPos][colPos +1];
		board[rowPos][colPos +1] = temp;
	}
	
	// check left
	if (board[rowPos][colPos -1] == -1){
		board[rowPos][colPos] = board[rowPos][colPos -1];
		board[rowPos][colPos -1] = temp;
	}
}

}",1
jear460,1696225971,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row, col, row1, col1;
    
    FindTile(board, tile, &row1, &col1);
    FindTile(board, -1, &row, &col);

    if (
        ((row - 1 == -1) && ((board[row + 1][col] == tile) || (board[row][col + 1] == tile))) ||
        ((row - 1 == -1) && (col + 1 == NUM_COLS) && (board[row + 1][col] == tile) && (board[row][col - 1] == tile)) ||
        ((col + 1 == NUM_COLS) && (board[row + 1][col] == tile) && (board[row][col - 1] == tile) && (board[row - 1][col] == tile)) ||
        ((col - 1 == -1) && (row + 1 == NUM_ROWS) && (board[row][col + 1] == tile) && (board[row - 1][col] == tile)) ||
        ((row + 1 == NUM_ROWS) && (board[row - 1][col] == tile) && (board[row][col + 1] == tile) && (board[row][col - 1] == tile))
    ) {
        board[row][col] = tile;
        board[row1][col1] = -1;
    }
}",0
jear460,1696226292,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row, col, row1, col1;

    FindTile(board, tile, &row1, &col1);
    FindTile(board, -1, &row, &col);

    if (
        ((row - 1 == row1) && (col == col1)) ||
        ((row + 1 == row1) && (col == col1)) ||
        ((row == row1) && (col - 1 == col1)) ||
        ((row == row1) && (col + 1 == col1))
    ) {
        board[row][col] = tile;
        board[row1][col1] = -1;
    }
}",1
jfen705,1695948042,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int a;
	int ro;
	int co;
	int rol;
	int col;
	a = 0;
	FindTile(board, tile, &ro, &co);
	FindTile(board, -1, &rol, &col);
	if (ro > 0) {
		if (ro + 1 == rol) {
			a = 1;
		}
		if (ro - 1 == rol) {
			a = 1;
		}
	}
	if (co > 0) {
		if (co + 1 == col) {
			a = 1;
		}
		if (co - 1 == col) {
			a = 1;
		}
	}
	if (ro == 0) {
		if (ro + 1 == rol) {
			a = 1;
		}
		if (col + 1) {
			a = 1;
		}
	}
	if (a == 1) {
		board[rol][col] = tile;
		board[ro][co] = -1;
	}
}",0
jfen705,1695948314,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int a;
	int ro;
	int co;
	int rol;
	int col;
	a = 0;
	FindTile(board, tile, &ro, &co);
	FindTile(board, -1, &rol, &col);
	if (ro > 0) {
		if (ro + 1 == rol) {
			a = 1;
		}
		if (ro - 1 == rol) {
			a = 1;
		}
	}
	if (co > 0) {
		if (co + 1 == col) {
			a = 1;
		}
		if (co - 1 == col) {
			a = 1;
		}
	}
	if (ro == 0) {
		if (ro + 1 == rol) {
			a = 1;
		}
		if (co + 1==col) {
			a = 1;
		}
	}
	if (a == 1) {
		board[rol][col] = tile;
		board[ro][co] = -1;
	}
}",0
jfen705,1695950443,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) 
{
	int a;
	int ro;
	int co;
	int rol;
	int col;
	a = 0;
	FindTile(board, tile, &ro, &co);
	FindTile(board, -1, &rol, &col);
	
	if ((ro - rol == 1 || rol - ro == 1)&&(col==co)) {
		a = 1;
	}
	if ((col - co == 1 || co - col == 1)&&ro==rol) {
		a = 1;
	}

	if (a == 1) {
		board[rol][col] = tile;
		board[ro][co] = -1;
	}

}",1
jfet156,1696202143,1,"
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{

int rowEmpty;
int colEmpty;
FindTile(board, -1, &rowEmpty, &colEmpty);

int rowTile;
int colTile;
FindTile(board, tile, &rowTile, &colTile);


if (colEmpty > 0)
{
    if ((colTile == colEmpty - 1) && (rowTile == rowEmpty))
    {
        board[rowTile][colTile] = -1;
        board[rowEmpty][colEmpty] = tile;
        return;
    }
}

if (colEmpty < NUM_COLS)
{
    if ((colTile == colEmpty + 1) && (rowTile == rowEmpty))
    {
        board[rowTile][colTile] = -1;
        board[rowEmpty][colEmpty] = tile;
        return;
    }
}

if (rowEmpty > 0)
{
    if ((rowTile == rowEmpty - 1) && (colTile == colEmpty))
    {
        board[rowTile][colTile] = -1;
        board[rowEmpty][colEmpty] = tile;
        return;
    }
    
}

if (rowEmpty < NUM_ROWS) 
{
    if ((rowTile = rowEmpty + 1) && (colTile == colEmpty))
    {
        board[rowTile][colTile] = -1;
        board[rowEmpty][colEmpty] = tile;
        return;
    }
}

}

",0
jfet156,1696202275,2,"
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{

int rowEmpty;
int colEmpty;
FindTile(board, -1, &rowEmpty, &colEmpty);

int rowTile;
int colTile;
FindTile(board, tile, &rowTile, &colTile);


if (colEmpty > 0)
{
    if ((colTile == colEmpty - 1) && (rowTile == rowEmpty))
    {
        board[rowTile][colTile] = -1;
        board[rowEmpty][colEmpty] = tile;
        return;
    }
}

if (colEmpty < NUM_COLS)
{
    if ((colTile == colEmpty + 1) && (rowTile == rowEmpty))
    {
        board[rowTile][colTile] = -1;
        board[rowEmpty][colEmpty] = tile;
        return;
    }
}

if (rowEmpty > 0)
{
    if ((rowTile == rowEmpty - 1) && (colTile == colEmpty))
    {
        board[rowTile][colTile] = -1;
        board[rowEmpty][colEmpty] = tile;
        return;
    }
    
}

if (rowEmpty < NUM_ROWS) 
{
    if ((rowTile == rowEmpty + 1) && (colTile == colEmpty))
    {
        board[rowTile][colTile] = -1;
        board[rowEmpty][colEmpty] = tile;
        return;
    }
}

}

",1
jgeo610,1695907320,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row;
	int col;
	int store;

	FindTile(board, tile, &row, &col);
	
	store = board[row][col];

	if ((board[row][col + 1] == -1) && (col < NUM_COLS - 1)) {
		board[row][col] = -1;
		board[row][col + 1] = store;

	} else if ((board[row][col - 1] == -1) && (col > 0)) {
		board[row][col] = -1;
		board[row][col - 1] = store;

	} else if ((board[row + 1][col] == -1) && (row < NUM_ROWS - 1)) {
		board[row][col] = -1;
		board[row + 1][col] = store;

	} else if ((board[row - 1][col] == -1) && (row > 0)) {
		board[row][col] = -1;
		board[row - 1][col] = store;
	}
}",1
jgol495,1695616891,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int search){
    int rs, cs; // Our tile
    FindTile(board, search, &rs, &cs);
    int re, ce; // Empty tile
    FindTile(board, -1, &re, &ce);

    // We are exactly one tile away on either axis (XOR)
    if( abs(rs-re) == 1 ^ abs(cs - ce) == 1 ){
        // Swapping time
        board[re][ce] = board[rs][cs];
        board[rs][cs] = -1;
    }
}",0
jgol495,1695616917,2,"#include <math.h>
void MakeMove(int board[NUM_ROWS][NUM_COLS], int search){
    int rs, cs; // Our tile
    FindTile(board, search, &rs, &cs);
    int re, ce; // Empty tile
    FindTile(board, -1, &re, &ce);

    // We are exactly one tile away on either axis (XOR)
    if((abs(rs-re) == 1) ^ (abs(cs - ce) == 1)){
        // Swapping time
        board[re][ce] = board[rs][cs];
        board[rs][cs] = -1;
    }
}",0
jgol495,1695617091,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    int rs, cs; // Our tile
    FindTile(board, tile, &rs, &cs);
    int re, ce; // Empty tile
    FindTile(board, -1, &re, &ce);

    // We are exactly one tile away on either axis (XOR)
    int rowdelta = rs - re;
    if(rowdelta < 0){ rowdelta *= -1; }
    int coldelta = cs - ce;
    if(coldelta < 0){ coldelta *= -1; }

    if((rowdelta == 1) ^ (coldelta == 1)){
        // Swapping time
        board[re][ce] = board[rs][cs];
        board[rs][cs] = -1;
    }
}",0
jgol495,1695730867,4,"#include <math.h>
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    int rs, cs; // Our tile
    FindTile(board, tile, &rs, &cs);
    int re, ce; // Empty tile
    FindTile(board, -1, &re, &ce);

    printf(""RS: %d, CS: %d.  RE: %d, CE: %d\n"", rs, cs, re, ce);
    if( (abs(rs - re) == 1) & (abs(cs - ce) == 0)
     || (abs(rs - re) == 0) & (abs(cs - ce) == 1) ){
        // Swapping time
        board[re][ce] = board[rs][cs];
        board[rs][cs] = -1;
    }
}",0
jgol495,1695730900,5,"#include <math.h>
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    int rs, cs; // Our tile
    FindTile(board, tile, &rs, &cs);
    int re, ce; // Empty tile
    FindTile(board, -1, &re, &ce);

    if( (abs(rs - re) == 1) & (abs(cs - ce) == 0)
     || (abs(rs - re) == 0) & (abs(cs - ce) == 1) ){
        // Swapping time
        board[re][ce] = board[rs][cs];
        board[rs][cs] = -1;
    }
}",1
jhor229,1696223469,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) 
{
  int old_row, old_col, new_row, new_col;

  FindTile(board, -1, &old_row, &old_col);
  FindTile(board, tile, &new_row, &new_col);
  if (old_row +- 1 == new_row || new_col +- 1 == old_col) 
  {
    board[old_row][old_col] = tile;
    board[new_row][new_col] = -1;
  }
}",0
jhor229,1696224226,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) 
{
  int old_row, old_col, new_row, new_col;

  FindTile(board, -1, &old_row, &old_col);
  FindTile(board, tile, &new_row, &new_col);
  if ((old_row == new_row && abs(old_col - new_col) == 1) || (old_col == new_col && abs(old_row - new_row) == 1)) 
  {
    board[old_row][old_col] = tile;
    board[new_row][new_col] = -1;
  }
}",1
jhwa027,1696159385,1,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos) {
    for(int i = 0; i < NUM_ROWS; i++) {
        for(int j = 0; j < NUM_COLS; j++) {
            if(board[i][j] == tile) {
                *rowPos = i;
                *colPos = j;
                return;
            }
        }
    }
}

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRow, tileCol, emptyRow, emptyCol;

    FindTile(board, tile, &tileRow, &tileCol); // Find the position of the specified tile
    FindTile(board, -1, &emptyRow, &emptyCol); // Find the position of the empty tile

    // Check if the specified tile and the empty tile are adjacent
    if((tileRow == emptyRow && (tileCol == emptyCol - 1 || tileCol == emptyCol + 1)) ||
       (tileCol == emptyCol && (tileRow == emptyRow - 1 || tileRow == emptyRow + 1))) {
        // Swap the specified tile and the empty tile
        board[emptyRow][emptyCol] = tile;
       
",0
jhwa027,1696159410,2,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos) {
    for(int i = 0; i < NUM_ROWS; i++) {
        for(int j = 0; j < NUM_COLS; j++) {
            if(board[i][j] == tile) {
                *rowPos = i;
                *colPos = j;
                return;
            }
        }
    }
}

       
",0
jhwa027,1696159599,3,"
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRow, tileCol, emptyRow, emptyCol;
    
    // Finding the positions of the specified tile and the empty tile.
    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol);
    
    // Checking if the specified tile and the empty tile are adjacent, and swapping them if they are.
    if((tileRow == emptyRow && abs(tileCol - emptyCol) == 1) || (tileCol == emptyCol && abs(tileRow - emptyRow) == 1)) {
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}

",1
jjos057,1696162027,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int tileRow;
    int tileCol;
    FindTile(board, tile, &tileRow, &tileCol);

    int emptyRow;
    int emptyCol;
    FindTile(board, -1, &emptyRow, &emptyCol); 

    if (((emptyRow - tileRow == 1 || emptyRow - tileRow == -1) && emptyCol == tileCol) || ((emptyCol - tileCol == 1 || emptyCol - tileCol == -1) && emptyRow == tileRow)) {
        
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}",1
jjun879,1695950881,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowPosTile, colPosTile;
	int rowPosEmptytile, colPosEmptytile;

	// Find the positions of the tile to be moved and the empty square
	FindTile(board, tile, &rowPosTile, &colPosTile);
	FindTile(board, -1, &rowPosEmptytile, &colPosEmptytile);

	// Check if the tile and empty square are adjacent
	if ((rowPosTile == rowPosEmptytile && abs(colPosTile - colPosEmptytile)) || (colPosTile == colPosEmptytile && abs(rowPosTile - rowPosEmptytile))) {
		// Swap the tile and the empty square
		board[rowPosEmptytile][colPosEmptytile] = board[rowPosTile][colPosTile];
			board[rowPosTile][colPosTile] = -1;
	}

}",0
jjun879,1695951744,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowPos, colPos;
	int rowPosEmptytile, colPosEmptytile;

	// Find the positions of the tile to be moved and the empty square
	FindTile(board, tile, &rowPos, &colPos);
	FindTile(board, -1, &rowPosEmptytile, &colPosEmptytile);

	// Check if the tile and empty square are adjacent
	if ((abs(rowPos - rowPosEmptytile) == 1 && colPos == colPosEmptytile) || (rowPos == rowPosEmptytile && abs(colPos - colPosEmptytile) == 1)) {
		board[rowPosEmptytile][colPosEmptytile] = board[rowPos][colPos];
			board[rowPos][colPos] = -1;
	}
",0
jjun879,1695951772,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowPos, colPos;
	int rowPosEmptytile, colPosEmptytile;

	// Find the positions of the tile to be moved and the empty square
	FindTile(board, tile, &rowPos, &colPos);
	FindTile(board, -1, &rowPosEmptytile, &colPosEmptytile);

	// Check if the tile and empty square are adjacent
	if ((abs(rowPos - rowPosEmptytile) == 1 && colPos == colPosEmptytile) || (rowPos == rowPosEmptytile && abs(colPos - colPosEmptytile) == 1)) {
		board[rowPosEmptytile][colPosEmptytile] = board[rowPos][colPos];
			board[rowPos][colPos] = -1;
	}

}",1
jkah253,1695986106,1,"
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rEmpty, cEmpty, rTile, cTile;

    // find the r,c of empty, then of the tile
    FindTile(board, -1, &rEmpty, &cEmpty);
    FindTile(board, tile, &rTile, &cTile);

    // move above
    if (rTile > 0 && cEmpty == cTile) {
        if(rEmpty == (rTile-1)) {
            // if in same column, and empty is above, swap
            board[rEmpty][cEmpty] = tile;
            board[rTile][cTile] = -1;
        }
    } 
    // move down
    if (rTile < 3 && cEmpty == cTile) {
        if(rEmpty == (rTile+1)) {
            board[rEmpty][cEmpty] = tile;
            board[rTile][cTile] = -1;
        }
    }
    // move LEFT
    if (cTile > 0 && rEmpty == rTile) {
        if(cEmpty == (cTile-1)) {
            board[rEmpty][cEmpty] = tile;
            board[rTile][cTile] = -1;
        }
    }
    // move RIGHT
    if (cTile < 3 && rEmpty == rTile) {
        if(cEmpty == (cTile+1)) {
            board[rEmpty][cEmpty] = tile;
            board[rTile][cTile] = -1;
        }
    }
}",1
jkan172,1695898097,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int i,j;
    int spaceRow, spaceCol;
    int tileRow, tileCol;

    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if (board[i][j] == tile){
                tileRow = i;
                tileCol = j;
            }
        }
    }

    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if (board[i][j] == -1){
                spaceRow = i;
                spaceCol = j;
            }
        }
    }

}",0
jkan172,1695900516,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){

    int i,j;
    int spaceRow, spaceCol;
    int tileRow, tileCol;

    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if (board[i][j] == tile){
                tileRow = i;
                tileCol = j;
            }
        }
    }

    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if (board[i][j] == -1){
                spaceRow = i;
                spaceCol = j;
            }
        }
    }

    if ( ((spaceRow - tileRow == 1) && (spaceCol == tileCol)) || ((spaceRow - tileRow == -1) && (spaceCol == tileCol)) 
		|| ((spaceCol - tileCol == 1) && (spaceRow == tileRow)) || ((spaceCol - tileCol == -1) && (spaceRow == tileRow)) ) {
		board[spaceRow][spaceCol] = tile;
		board[tileRow][tileCol] = -1;
	}

}",1
jkim828,1695871764,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int tilerow, tilecol;
    int emptyrow, emptycol;

    FindTile(board, -1, &emptyrow, &emptycol);
    FindTile(board, tile, &tilerow, &tilecol);

    if ((tilecol + 1 == emptycol) || (tilecol - 1 == emptycol)) {
        if (emptyrow == tilerow) {
            board[tilerow][tilecol] = -1;
            board[emptyrow][emptycol] = tile;
        }
    }

    if ((tilerow + 1 == emptyrow) || (tilerow - 1 == emptyrow)) {
        if (emptycol == tilecol) {
            board[tilerow][tilecol] = -1;
            board[emptyrow][emptycol] = tile;
        }
    }
}",1
jkim837,1695952659,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int emptyR, emptyC;
	int tileR, tileC;
	FindTile(board, -1, &emptyR, &emptyC);
	FindTile(board, tile, &tileR, &tileC);

	if ((tileR == emptyR && (tileC == emptyC - 1 || tileC == emptyC + 1)) ||
		(tileC == emptyC && (tileR == emptyR - 1 || tileR == emptyR + 1)))
	{
		board[emptyR][emptyC] = tile;
		board[tileR][tileC] = -1;
	}
}",1
jkim933,1696243946,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowPos, colPos;
    FindTile(board, tile, &rowPos, &colPos);
    int nRowPos, nColPos;
    FindTile(board, -1, &nRowPos, &nColPos);
    
    while (rowPos == nRowPos) {
        if (colPos - nColPos == 1) {
            board[nRowPos][nColPos] = tile;
            board[rowPos][colPos] = -1;
        }
        else if (nColPos - colPos == 1) {
            board[nRowPos][nColPos] = tile;
            board[rowPos][colPos] = -1;
        }
    }
    
    while (colPos == nColPos) {
        if (rowPos - nRowPos == 1) {
            board[nRowPos][nColPos] = tile;
            board[rowPos][colPos] = -1;
        }
        else if (nRowPos - rowPos == 1) {
            board[nRowPos][nColPos] = tile;
            board[rowPos][colPos] = -1;
        }
    }
}",0
jkim960,1695855661,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int empRow, empCol, tileRow, tileCol;
	tileRow = -10000;
	tileCol = -10000;
	FindTile(board, -1, &empRow, &empCol);
	FindTile(board, tile, &tileRow, &tileCol);
	

	if ((abs(empRow - tileRow) == 1 && empCol == tileCol) || (abs(empCol - tileCol) == 1 && empRow == tileRow)) {
	    board[empRow][empCol] = tile;
	    board[tileRow][tileCol] = -1;
	}
}",1
jlah077,1696204586,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int tileRow, tileCol, spaceRow, spaceCol;
    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &spaceRow, &spaceCol);
    if (tileRow == spaceRow - 1 || tileRow == spaceRow + 1 || tileCol == spaceCol - 1 || tileCol == spaceCol + 1)
    {
        int* spacept = *(board + spaceRow) + spaceCol;
        int* tilept = *(board + tileRow) + tileCol;
        *spacept = tile;
        *tilept = -1;      
    }
    else
    {
        return;
    }
}",0
jlah077,1696206754,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int tileRow, tileCol, spaceRow, spaceCol;
    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &spaceRow, &spaceCol);
    if (tile < 1 || tile > 15)
    {
        return;
    }
    else if ((tileRow == spaceRow) && (tileCol == spaceCol - 1) || (tileRow == spaceRow) && (tileCol == spaceCol + 1) ||
             (tileCol == spaceCol) && (tileRow == spaceCol - 1) || (tileCol == spaceCol) && (tileRow == spaceCol + 1))
    {
        int *spacept = *(board + spaceRow) + spaceCol;
        int *tilept = *(board + tileRow) + tileCol;
        *spacept = tile;
        *tilept = -1;
        return;
    }
    else
    {
        return;
    }
}",0
jlah077,1696206931,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int tileRow, tileCol, spaceRow, spaceCol;
    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &spaceRow, &spaceCol);
    if (tile < 1 || tile > 15)
    {
        return;
    }
    else if (tileRow == spaceRow && tileCol == spaceCol - 1 || tileRow == spaceRow && tileCol == spaceCol + 1 ||
             tileCol == spaceCol && tileRow == spaceCol - 1 || tileCol == spaceCol && tileRow == spaceCol + 1)
    {
        int *spacept = *(board + spaceRow) + spaceCol;
        int *tilept = *(board + tileRow) + tileCol;
        *spacept = tile;
        *tilept = -1;
        return;
    }
    else
    {
        return;
    }
}",0
jlah077,1696207068,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int tileRow, tileCol, spaceRow, spaceCol;
    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &spaceRow, &spaceCol);
    if (tile < 1 || tile > 15)
    {
        return;
    }
    else if ((tileRow == spaceRow && tileCol == spaceCol - 1) || (tileRow == spaceRow && tileCol == spaceCol + 1) ||
             (tileCol == spaceCol && tileRow == spaceCol - 1) || (tileCol == spaceCol && tileRow == spaceCol + 1))
    {
        int *spacept = *(board + spaceRow) + spaceCol;
        int *tilept = *(board + tileRow) + tileCol;
        *spacept = tile;
        *tilept = -1;
        return;
    }
    else
    {
        return;
    }
}",0
jlah077,1696207291,5,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int tileRow, tileCol, spaceRow, spaceCol;
    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &spaceRow, &spaceCol);
    if (tile < 1 || tile > 15)
    {
        return;
    }
    else if ((tileRow == spaceRow && tileCol == spaceCol - 1) || (tileRow == spaceRow && tileCol == spaceCol + 1) ||
             (tileCol == spaceCol && tileRow == spaceRow - 1) || (tileCol == spaceCol && tileRow == spaceRow + 1))
    {
        int *spacept = *(board + spaceRow) + spaceCol;
        int *tilept = *(board + tileRow) + tileCol;
        *spacept = tile;
        *tilept = -1;
        return;
    }
    else
    {
        return;
    }
}",1
jlal056,1695812594,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{

int x,i,j,k,l;

	FindTile(board,-1,&i,&j);
	FindTile(board,tile,&k,&l);

	if ((i==k-1)&&(j==l)) {
		x = board[k][l];
		board[k][l] = board[k-1][l];
		board[k-1][l] = x;
	}

	if ((i==k)&&(j==l-1)) {
		x = board[k][l];
		board[k][l] = board[k][l-1];
		board[k][l-1] = x;
	}

	if ((i==k)&&(j==l+1)) {
		x = board[k][l];
		board[k][l] = board[k][l+1];
		board[k][l+1] = x;
	}

	if ((i==k+1)&&(j==l)) {
		x = board[k][l];
		board[k][l] = board[k+1][l];
		board[k+1][l] = x;
	}

}",1
jli463,1695802459,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;
	int i, j;
	int rowNum, colNum;
	int check;
	check = 0;
	FindTile(board, -1, &row, &col);
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == tile) {
				rowNum = i;
				colNum = j;
				
			}
		}
	}

	if ( (row - rowNum == 1 || rowNum - row == -1) && (col == colNum)) {
		check = 1;
	}
	if ( (col - colNum == 1 || colNum - col == -1) && (row == rowNum))  {
		check = 1;
	}

	if (check == 1) {
		board[row][col] = tile;
		board[rowNum][colNum] = -1;
	}
}",0
jli463,1695802518,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;
	int i, j;
	int rowNum, colNum;
	int check;
	check = 0;
	FindTile(board, -1, &row, &col);
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == tile) {
				rowNum = i;
				colNum = j;
				
			}
		}
	}

	if ( (row - rowNum == 1 || row - rowNum == -1) && (col == colNum)) {
		check = 1;
	}
	if ( (col - colNum == 1 || col - colNum == -1) && (row == rowNum))  {
		check = 1;
	}

	if (check == 1) {
		board[row][col] = tile;
		board[rowNum][colNum] = -1;
	}
}",1
jli876,1695609397,1,"void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos)
{
	for (int i = 0; i < NUM_ROWS; i++) for (int j = 0; j < NUM_COLS; j++) board[i][j] == tile ? *rowPos = i, *colPos = j : 0;
}

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int emp_row, emp_col;
	FindTile(board, -1, &emp_row, &emp_col);

	int req_row, req_col;
	FindTile(board, tile, &req_row, &req_col);

	if ((req_row - emp_row == -1 || req_row - emp_row == 1) ^ (req_col - emp_col == -1 || req_col - emp_col == 1)) {
		board[req_row][req_col] = -1;
		board[emp_row][emp_col] = tile;
	}
}",0
jli876,1695609406,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int emp_row, emp_col;
	FindTile(board, -1, &emp_row, &emp_col);

	int req_row, req_col;
	FindTile(board, tile, &req_row, &req_col);

	if ((req_row - emp_row == -1 || req_row - emp_row == 1) ^ (req_col - emp_col == -1 || req_col - emp_col == 1)) {
		board[req_row][req_col] = -1;
		board[emp_row][emp_col] = tile;
	}
}",0
jli876,1695688236,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{	
	int emp_row, emp_col;
	FindTile(board, -1, &emp_row, &emp_col);

	int req_row, req_col;
	FindTile(board, tile, &req_row, &req_col);

	if (((req_row - emp_row == -1 || req_row - emp_row == 1) ^ (req_col - emp_col == -1 || req_col - emp_col == 1)) 
	&& (req_row - emp_row != -3 && req_row - emp_row != 3 && req_col - emp_col != -3 && req_col - emp_col != 3)) {
		board[req_row][req_col] = -1;
		board[emp_row][emp_col] = tile;
	}
}",1
jli917,1696229027,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptysquare_row, emptysquare_col;
    FindTile(board, -1, &emptysquare_row, &emptysquare_col);  
    int tile_row, tile_col;
    FindTile(board, tile, &tile_row, &tile_col);  

    // Check if the tile is adjacent to the empty square
    if ((tile_row == emptysquare_row && (tile_col == emptysquare_col - 1 || tile_col == emptysquare_col + 1)) ||
        (tile_col == emptysquare_col && (tile_row == emptysquare_row - 1 || tile_row == emptysquare_row + 1))) {
        // Swap the tile with the empty square
        board[emptysquare_row][emptysquare_col] = tile;
        board[tile_row][tile_col] = -1;
    }
}",1
jlia486,1695974109,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol;
    int tileRow, tileCol;

    // Find the positions of the empty square and the specified tile
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);

    // Check if the specified tile is adjacent to the empty square
    if ((tileRow == emptyRow && abs(tileCol - emptyCol) == 1) ||
        (tileCol == emptyCol && abs(tileRow - emptyRow) == 1)) {
        // Swap the specified tile and the empty square
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
    // If the tile isn't adjacent, do nothing.
}
",1
jlia948,1696243474,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int selectedTile) 
{
    int emptyTileRow, emptyTileCol;
    int selectedTileRow, selectedTileCol;

    FindTile(board, selectedTile, &selectedTileRow, &selectedTileCol);
    FindTile(board, -1, &emptyTileRow, &emptyTileCol);

    int rowDiff, colDiff;

    if (emptyTileRow >= selectedTileRow)
        rowDiff = emptyTileRow - selectedTileRow;
    else
        rowDiff = selectedTileRow - emptyTileRow;

    if (emptyTileCol >= selectedTileCol)
        colDiff = emptyTileCol - selectedTileCol;
    else
        colDiff = selectedTileCol - emptyTileCol;

    if ((rowDiff == 1 && colDiff == 0) || (rowDiff == 0 && colDiff == 1)) 
    {
        board[emptyTileRow][emptyTileCol] = selectedTile;
        board[selectedTileRow][selectedTileCol] = -1;
    }
}",1
jliu295,1696040947,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
int rowDiff;
int colDiff;
{
	FindTile(board, -1, &row, &col);
	FindTile(board, tile, &tileRow, &tileCol);
	if(tileRow > 0 && tileCol > 0){
		rowDiff = tileRow - row;
		colDiff = tileCol - col;
		if(rowDiff = 1 && colDiff = 0 || rowDiff = 0 %% colDiff = 1 || rowDiff = -1 && colDiff = 0 || rowDiff = 0 && colDiff = -1){
				int bankVariable;
				bankVariable = board[row][col];
				board[row][col] = board[tileRow][tileCol];
				board[tileRow][tileCol] = bankVariable;
		}
	
	}
}",0
jliu295,1696041530,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
int tileRow;
int tileCol;
int row;
int col;
{
	FindTile(board[NUM_ROWS][NUM_COLS], -1, &row, &col);
	FindTile(board[NUM_ROWS][NUM_COLS], tile, &tileRow, &tileCol);
	if(tileRow > 0 && tileCol > 0){
		int rowDiff = tileRow - row;
		int colDiff = tileCol - col;
		if(rowDiff = 1 && colDiff = 0 || rowDiff = 0 && colDiff = 1 || rowDiff = -1 && colDiff = 0 || rowDiff = 0 && colDiff = -1){
				int bankVariable;
				bankVariable = board[row][col];
				board[row][col] = board[tileRow][tileCol];
				board[tileRow][tileCol] = bankVariable;
		}
	
	}
}",0
jliu295,1696041995,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tileRow, tileCol, emptyCol, emptyRow;
	FindTile(board, -1, &emptyRow, &emptyCol);
	FindTile(board, tile, &tileRow, &tileCol);
	if(tileRow > 0 && tileCol > 0){
		int rowDiff = tileRow - emptyRow;
		int colDiff = tileCol - emptyCol;
		if(rowDiff == 1 && colDiff == 0 || rowDiff == 0 && colDiff == 1 || rowDiff == -1 && colDiff == 0 || rowDiff == 0 && colDiff == -1){
				int bankVariable;
				bankVariable = board[emptyRow][emptyCol];
				board[emptyRow][emptyCol] = board[tileRow][tileCol];
				board[tileRow][tileCol] = bankVariable;
		}
	
	}
}",0
jliu295,1696042100,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tileRow, tileCol, emptyCol, emptyRow;
	FindTile(board, -1, &emptyRow, &emptyCol);
	FindTile(board, tile, &tileRow, &tileCol);
	if(tileRow > 0 && tileCol > 0){
		int rowDiff = tileRow - emptyRow;
		int colDiff = tileCol - emptyCol;
		if((rowDiff == 1 && colDiff == 0) || (rowDiff == 0 && colDiff == 1) || (rowDiff == -1 && colDiff == 0) || (rowDiff == 0 && colDiff == -1)){
				int bankVariable;
				bankVariable = board[emptyRow][emptyCol];
				board[emptyRow][emptyCol] = board[tileRow][tileCol];
				board[tileRow][tileCol] = bankVariable;
		}
	
	}
}",0
jliu295,1696044496,5,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tileRow, tileCol, emptyCol, emptyRow;
	FindTile(board, -1, &emptyRow, &emptyCol);
	FindTile(board, tile, &tileRow, &tileCol);
	if(tileRow > 0 && tileCol > 0){
		int rowDiff = tileRow - emptyRow;
		int colDiff = tileCol - emptyCol;
		if((rowDiff == 1 && colDiff == 0) || (rowDiff == 0 && colDiff == 1) || (rowDiff == -1 && colDiff == 0) || (rowDiff == 0 && colDiff == -1)){
				int bankVariable;
				bankVariable = board[emptyRow][emptyCol];
				board[emptyRow][emptyCol] = board[tileRow][tileCol];
				board[tileRow][tileCol] = bankVariable;
		}
	
	}
	if(tileRow == 0 || tileCol == 0){
	    int rowDiff = tileRow - emptyRow;
		int colDiff = tileCol - emptyCol;
		if((rowDiff == 0 && colDiff == -1) ||(rowDiff == -1 && colDiff == 0)){
		    int bankVariable;
				bankVariable = board[emptyRow][emptyCol];
				board[emptyRow][emptyCol] = board[tileRow][tileCol];
				board[tileRow][tileCol] = bankVariable;    
		}
	}
}",0
jliu295,1696044737,6,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tileRow, tileCol, emptyCol, emptyRow;
	FindTile(board, -1, &emptyRow, &emptyCol);
	FindTile(board, tile, &tileRow, &tileCol);
	if(tileRow > 0 && tileCol > 0){
		int rowDiff = tileRow - emptyRow;
		int colDiff = tileCol - emptyCol;
		if((rowDiff == 1 && colDiff == 0) || (rowDiff == 0 && colDiff == 1) || (rowDiff == -1 && colDiff == 0) || (rowDiff == 0 && colDiff == -1)){
				int bankVariable;
				bankVariable = board[emptyRow][emptyCol];
				board[emptyRow][emptyCol] = board[tileRow][tileCol];
				board[tileRow][tileCol] = bankVariable;
		}
	
	}
	if(tileRow == 0 || tileCol == 0){
	    int rowDiff = tileRow - emptyRow;
		int colDiff = tileCol - emptyCol;
		if((rowDiff == 0 && colDiff == -1) ||(rowDiff == -1 && colDiff == 0)||(rowDiff == 0 && colDiff == 1)){
		    int bankVariable;
				bankVariable = board[emptyRow][emptyCol];
				board[emptyRow][emptyCol] = board[tileRow][tileCol];
				board[tileRow][tileCol] = bankVariable;    
		}
	}
}",1
jliu778,1695702431,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int input)
{
	int *rowPos,*colPos;
	for (int i = 0; i < 4; i++)
	{
		for (int j = 0; j < 4; j++)
		{
			if (board[i][j] == -1)
			{
				*rowPos=i;
				*colPos=j;
				break;
			}
		}
	}
	for (int i = 0; i < 4; i++)
	{
		for (int j = 0; j < 4; j++)
		{
			if (board[i][j] == input)
			{
				if (*rowPos+1<i<*rowPos-1 || *colPos+1<j<*rowPos-1)
				{
					break;
				}
				
				board[i][j]=-1;
				board[*rowPos][*colPos]=input;
				break;
			}
		}
	}
}",0
jliu778,1695703384,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int input)
{
	int *rowPos,*colPos;
	for (int i = 0; i < 4; i++)
	{
		for (int j = 0; j < 4; j++)
		{
			if (board[i][j] == -1)
			{
				*rowPos=i;
				*colPos=j;
				break;
			}
		}
	}
	for (int i = 0; i < 4; i++)
	{
		for (int j = 0; j < 4; j++)
		{
			if (board[i][j] == input)
			{
				if (*rowPos+1<i||i<*rowPos-1||*colPos+1<j || j<*colPos-1)
				{
					break;
				}
				board[i][j]=-1;
				board[*rowPos][*colPos]=input;
				break;
			}
		}
	}
}",0
jliu778,1695719569,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int input)
{
	int A,B;
	FindTile(board, -1, &A, &B);
	for (int i = 0; i < 4; i++)
	{
		for (int j = 0; j < 4; j++)
		{
			if (board[i][j] == input)
			{
				if (A+1<i||i<A-1||B+1<j || j<B-1)
				{
					break;
				}
				board[i][j]=-1;
				board[A][B]=input;
				break;
			}
		}
	}
}",1
jluo379,1695889375,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, newRow, newCol;

	// Find the current position of the tile to move
	FindTile(board, tile, &row, &col);

	// Find the position of the empty tile
	FindTile(board, -1, &newRow, &newCol);

	// Check if the tile can be moved to an adjacent empty space
	if ((row - 1 >= 0 && board[row - 1][col] == -1) ||
	    (row + 1 < NUM_ROWS && board[row + 1][col] == -1) ||
	    (col - 1 >= 0 && board[row][col - 1] == -1) ||
	    (col + 1 < NUM_COLS && board[row][col + 1] == -1))
	{
		// Perform the move
		board[row][col] = -1;
		board[newRow][newCol] = tile;
	}
	return;
}",1
jmak320,1696165967,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
int temp, emptyRow, emptyCol, tileRow, tileCol;
FindTile(board, -1, &emptyRow, &emptyCol);
FindTile(board, tile, &tileRow, &tileCol);
if (tileRow == emptyRow && (tileCol == emptyCol + 1 || tileCol == emptyCol - 1)) {
	board[emptyRow][emptyCol] = board[tileRow][tileCol];
	board[tileRow][tileCol] = -1;
}
else if (tileCol == emptyCol && (tileRow == emptyRow + 1 || tileRow == emptyRow - 1)) {
	board[emptyRow][emptyCol] = board[tileRow][tileCol];
	board[tileRow][tileCol] = -1;
}

}",0
jmak320,1696166046,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
int emptyRow, emptyCol, tileRow, tileCol;
FindTile(board, -1, &emptyRow, &emptyCol);
FindTile(board, tile, &tileRow, &tileCol);
if (tileRow == emptyRow && (tileCol == emptyCol + 1 || tileCol == emptyCol - 1)) {
	board[emptyRow][emptyCol] = board[tileRow][tileCol];
	board[tileRow][tileCol] = -1;
}
else if (tileCol == emptyCol && (tileRow == emptyRow + 1 || tileRow == emptyRow - 1)) {
	board[emptyRow][emptyCol] = board[tileRow][tileCol];
	board[tileRow][tileCol] = -1;
}

}",1
jmat941,1696242584,1,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4


void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol;
    FindTile(board, -1, &emptyRow, &emptyCol);

    int tileRow, tileCol;
    FindTile(board, tile, &tileRow, &tileCol); 

    if (abs(tileRow - emptyRow) + abs(tileCol - emptyCol) == 1) {
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}

",1
jmei608,1696168207,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
	int row, col;
	FindTile(board, tile, &row, &col);
	if (row == 0 && col == 0) {
		if (board[0][1] == -1) {
			board[0][1] = tile;
			board[0][0] = -1;
		}else if (board[1][0] == -1) {
			board[1][0] = tile;
			board[0][0] = -1;
		}
	} else if (row == 0 && col == 3) {
		if (board[0][2] == -1) {
			board[0][2] = tile;
			board[0][3] = -1;
		}else if (board[1][3] == -1) {
			board[1][3] = tile;
			board[0][3] = -1;
		}
	} else if (row == 3 && col == 0) {
		if (board[3][1] == -1) {
			board[3][1] = tile;
			board[3][0] = -1;
		}else if (board[2][0] == -1) {
			board[2][0] = tile;
			board[3][0] = -1;
		}
	} else if (row == 3 && col == 3) {
		if (board[3][2] == -1) {
			board[3][2] = tile;
			board[3][3] = -1;
		}else if (board[2][3] == -1) {
			board[2][3] = tile;
			board[3][3] = -1;
		}
	} else if (row == 0 && col > 0 && col < 3) {
		if (board[1][col] == -1) {
			board[1][col] = tile;
			board[0][col] = -1;
		}else if (board[0][col -1] == -1) {
			board[0][col - 1] = tile;
			board[0][col] = -1;
		}else if (board[0][col + 1] == -1) {
			board[0][col + 1] = tile;
			board[0][col] = -1;
		}
	} else if (row == 3 && col > 0 && col < 3) {
		if (board[2][col] == -1) {
			board[2][col] = tile;
			board[3][col] = -1;
		}else if (board[3][col - 1] == -1) {
			board[3][col - 1] = tile;
			board[3][col] = -1;
		}else if (board[3][col + 1] == -1) {
			board[3][col + 1] = tile;
			board[3][col] = -1;
		}
	} else if (row > 0 && row < 3 && col == 0) {
		if (board[row][1] == -1) {
			board[row][1] = tile;
			board[row][0] = -1;
		}else if (board[row - 1][0] == -1) {
			board[row - 1][0] = tile;
			board[row][0] = -1;
		}else if (board[row + 1][0] == -1) {
			board[row + 1][0] = tile;
			board[row][0] = -1;
		}
	} else if (row > 0 && row < 3 && col == 3) {
		if (board[row][2] == -1) {
			board[row][2] = tile;
			board[row][3] = -1;
		}
		else if (board[row - 1][3] == -1) {
			board[row - 1][3] = tile;
			board[row][3] = -1;
		}
		else if (board[row + 1][3] == -1) {
			board[row + 1][3] = tile;
			board[row][3] = -1;
		}
	} else {
		if (board[row][col + 1] == -1) {
			board[row][col + 1] = tile;
			board[row][col] = -1;
		} else if (board[row][col - 1] == -1) {
			board[row][col - 1] = tile;
			board[row][col] = -1;
		} else if (board[row + 1][col] == -1) {
			board[row + 1][col] = tile;
			board[row][col] = -1;
		} else if (board[row - 1][col] == -1) {
			board[row - 1][col] = tile;
			board[row][col] = -1;
		}
	}
	
}
",1
jmil737,1695721519,1,"#include <stdio.h>
#define _CRT_SECURE_NO_WARNINGS

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){

int temp;  
    for (int i = 0; i < 4; i++){
    
    
    for (int j = 0; j < 4; j++){
        
    if (board[i][j] == -1){
    
        int row = i;
        int col = j;
        int spacerow = i;
        int spacecol = j;
        
        if (board[row--][col] == tile){
        
        board[row--][col] = tile;
        board[spacerow][spacecol] = -1;
        
        }
        else if (board[row++][col] == tile){
    
        board[row++][col] = tile;
        board[spacerow][spacecol] = -1;
        
        }
        else if (board[row][col--] == tile){
        
        board[row][col--] = tile;
        board[spacerow][spacecol] = -1;
        
        }
        else if (board[row][col++] == tile){
        
        board[row][col++] = tile;
        board[spacerow][spacecol] = -1;
        
        }
        else {
            board[i][j] = board[i][j];
        }
    
    
    
    }
    
    
 }

 }
 

    
}
",0
jmil737,1695721534,2,"#include <stdio.h>
#define _CRT_SECURE_NO_WARNINGS

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){

    for (int i = 0; i < 4; i++){
    
    
    for (int j = 0; j < 4; j++){
        
    if (board[i][j] == -1){
    
        int row = i;
        int col = j;
        int spacerow = i;
        int spacecol = j;
        
        if (board[row--][col] == tile){
        
        board[row--][col] = tile;
        board[spacerow][spacecol] = -1;
        
        }
        else if (board[row++][col] == tile){
    
        board[row++][col] = tile;
        board[spacerow][spacecol] = -1;
        
        }
        else if (board[row][col--] == tile){
        
        board[row][col--] = tile;
        board[spacerow][spacecol] = -1;
        
        }
        else if (board[row][col++] == tile){
        
        board[row][col++] = tile;
        board[spacerow][spacecol] = -1;
        
        }
        else {
            board[i][j] = board[i][j];
        }
    
    
    
    }
    
    
 }

 }
 

    
}
",0
jmil737,1695759919,3,"#include <stdio.h>
#define _CRT_SECURE_NO_WARNINGS

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){

    for (int i = 0; i < 4; i++){
    
    
    for (int j = 0; j < 4; j++){
        
    if (board[i][j] == -1){
    
        int row = i;
        int col = j;
        int spacerow = i;
        int spacecol = j;
    
    
        if (board[row--][col] == tile){
        board[row + 1][col] = -1;
        board[spacerow][spacecol] = tile;
        
        }
        else if (board[row++][col] == tile){
        board[row - 1][col] = -1;
        board[spacerow][spacecol] = tile;
        
        }
        else if (board[row][col--] == tile){
        board[row][col + 1] = -1;
        board[spacerow][spacecol] = tile;
        
        }
        else if (board[row][col++] == tile){
        board[row][col - 1] = -1;
        board[spacerow][spacecol] = tile;
        
        }
        else {
            board[i][j] = board[i][j];
        }
      }
    }
    
    
 }

 }

",0
jmil737,1695760614,4,"#include <stdio.h>
#define _CRT_SECURE_NO_WARNINGS

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){

    for (int i = 0; i < 4; i++){
    
    
    for (int j = 0; j < 4; j++){
        
    if (board[i][j] == -1){
    
        int row = i;
        int col = j;
        int spacerow = i;
        int spacecol = j;
        
        if (board[row - 1][col] == tile){
        board[row - 1][col] = -1;
        board[spacerow][spacecol] = tile;
        break;
        
        }
        else if (board[row + 1][col] == tile){
        board[row + 1][col] = -1;
        board[spacerow][spacecol] = tile;
        break;
        
        }
        else if (board[row][col - 1] == tile){
        board[row][col - 1] = -1;
        board[spacerow][spacecol] = tile;
        break;
        
        }
        else if (board[row][col + 1] == tile){
        board[row][col + 1] = -1;
        board[spacerow][spacecol] = tile;
        break;
        
        }
        else {
            board[i][j] = board[i][j];
        }
      }
    }
    
    
 }

 }
",0
jmil737,1695793901,5,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){

int row, col, row1, col1;

FindTile(board, -1, &row, &col);
FindTile(board,  tile, &row1, &col1);


    if ((row1 == row || row1 == row + 1 || row1 == row -1 ) && (col1 == col ||  col1 == col + 1|| col1 == col - 1)){
     
        board[row1][col1] = -1;
        board[row][col] = tile;
        
        }
        
    
}",1
jmil737,1695809954,6,"#include <stdio.h>
#define _CRT_SECURE_NO_WARNINGS

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){

int a = 1;
int b = 1;
int c = 1;
int d = 1;
int row;
int col;

for (int i = 0; i < 4; i++){
    
    
    for (int j = 0; j < 4; j++){
        
    if (board[i][j] == -1){
    
        row = i;
        col = j;
       
    }
    
    }
}


        if ((a == 1) && (board[row - 1][col] == tile)){
        
        board[row - 1][col] = -1;
        board[row][col] = tile;
        
        }
        if ((b == 1) && (board[row + 1][col] == tile)){
    
        board[row + 1][col] = -1;
        board[row][col] = tile;
        
        
        }
        if ((c == 1) && (board[row][col - 1] == tile)){
        
        board[row][col - 1] = -1;
        board[row][col] = tile;
        
        }
        if ((d == 1) && (board[row][col + 1] == tile)){
        
        board[row][col + 1] = -1;
        board[row][col] = tile;
        
        }
        
}",0
jmil737,1695810067,7,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){

int rowSpace; 
int colSpace; 
int rowTile;
int colTile;

for (int i = 0; i < 4; i++){
    
    
    for (int j = 0; j < 4; j++){
        
    if (board[i][j] == -1){
    
        rowSpace = i;
        colSpace = j;
        
    }
    
    }
}


for (int i = 0; i < 4; i++){
    
    
    for (int j = 0; j < 4; j++){
        
    if (board[i][j] == -1){
    
        rowTile = i;
        colTile = j;
        
    }
    
    }
}   

    if ((rowTile == rowSpace || rowTile == rowSpace + 1 || rowTile == rowSpace - 1 ) && (colTile == colSpace || colTile == colSpace + 1|| colTile == colSpace - 1)){
     
        board[rowTile][colTile] = -1;
        board[rowSpace][colSpace] = tile;
        
        }
        
    
}",0
jmil737,1695810343,8,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){

int rowSpace; 
int colSpace; 
int rowTile;
int colTile;

for (int i = 0; i < 4; i++){
    
    
    for (int j = 0; j < 4; j++){
        
    if (board[i][j] == -1){
    
        rowSpace = i;
        colSpace = j;
        
    }
    
    }
}


for (int i = 0; i < 4; i++){
    
    
    for (int j = 0; j < 4; j++){
        
    if (board[i][j] == tile){
    
        rowTile = i;
        colTile = j;
        
    }
    
    }
}   

    if ((rowTile == rowSpace || rowTile == rowSpace + 1 || rowTile == rowSpace - 1 ) && (colTile == colSpace || colTile == colSpace + 1|| colTile == colSpace - 1)){
     
        board[rowTile][colTile] = -1;
        board[rowSpace][colSpace] = tile;
        
        }
        
    
}

",1
jmil737,1695818709,9,"#include <stdio.h>
#define _CRT_SECURE_NO_WARNINGS

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){

int a = 1;
int b = 1;
int c = 1;
int d = 1;
int row;
int col;
int tilerow;
int tilecol;

for (int i = 0; i < 4; i++){
    
    
    for (int j = 0; j < 4; j++){
        
    if (board[i][j] == -1){
    
        row = i;
        col = j;
       
    }
    
    }
}

for (int i = 0; i < 4; i++){
    
    
    for (int j = 0; j < 4; j++){
        
    if (board[i][j] == tile){
    
        tilerow = i;
        tilecol = j;
       
    }
    
    }
}

int x;
x = 1;

while (x == 1){
    
if ((tilecol == 3) && (col == 0)){
break;
}

if ((tilecol == 0) && (col == 3)){
break;
}


        if ((a == 1) && (board[row - 1][col] == tile)){
        
        board[row - 1][col] = -1;
        board[row][col] = tile;
        x++;
        
        }
        if ((b == 1) && (board[row + 1][col] == tile)){
    
        board[row + 1][col] = -1;
        board[row][col] = tile;
        x++;
        
        }
        if ((c == 1) && (board[row][col - 1] == tile)){
        
        board[row][col - 1] = -1;
        board[row][col] = tile;
        x++;
        
        }
        if ((d == 1) && (board[row][col + 1] == tile)){
        
        board[row][col + 1] = -1;
        board[row][col] = tile;
        x++;
        
        }
}  
}
",0
jmil737,1695818729,10,"#include <stdio.h>
#define _CRT_SECURE_NO_WARNINGS

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){

int a = 1;
int b = 1;
int c = 1;
int d = 1;
int row;
int col;
int tilecol;

for (int i = 0; i < 4; i++){
    
    
    for (int j = 0; j < 4; j++){
        
    if (board[i][j] == -1){
    
        row = i;
        col = j;
       
    }
    
    }
}

for (int i = 0; i < 4; i++){
    
    
    for (int j = 0; j < 4; j++){
        
    if (board[i][j] == tile){
    
        tilecol = j;
       
    }
    
    }
}

int x;
x = 1;

while (x == 1){
    
if ((tilecol == 3) && (col == 0)){
break;
}

if ((tilecol == 0) && (col == 3)){
break;
}


        if ((a == 1) && (board[row - 1][col] == tile)){
        
        board[row - 1][col] = -1;
        board[row][col] = tile;
        x++;
        
        }
        if ((b == 1) && (board[row + 1][col] == tile)){
    
        board[row + 1][col] = -1;
        board[row][col] = tile;
        x++;
        
        }
        if ((c == 1) && (board[row][col - 1] == tile)){
        
        board[row][col - 1] = -1;
        board[row][col] = tile;
        x++;
        
        }
        if ((d == 1) && (board[row][col + 1] == tile)){
        
        board[row][col + 1] = -1;
        board[row][col] = tile;
        x++;
        
        }
}  
}
",0
jmil737,1695818888,11,"#include <stdio.h>
#define _CRT_SECURE_NO_WARNINGS

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){

int a = 1;
int b = 1;
int c = 1;
int d = 1;
int row;
int col;
int tilecol;

for (int i = 0; i < 4; i++){
    
    
    for (int j = 0; j < 4; j++){
        
    if (board[i][j] == -1){
    
        row = i;
        col = j;
       
    }
    
    }
}

for (int i = 0; i < 4; i++){
    
    
    for (int j = 0; j < 4; j++){
        
    if (board[i][j] == tile){
    
        tilecol = j;
       
    }
    
    }
}

int x;
x = 1;

while (x == 1){
    
if ((tilecol == 3) && (col == 0)){
break;
}

if ((tilecol == 0) && (col == 3)){
break;
}


        if ((a == 1) && (board[row - 1][col] == tile)){
        
        board[row - 1][col] = -1;
        board[row][col] = tile;
        x++;
        
        }
        else{
            x++;
        }
        if ((b == 1) && (board[row + 1][col] == tile)){
    
        board[row + 1][col] = -1;
        board[row][col] = tile;
        x++;
        else{
            x++;
        }
        
        }
        if ((c == 1) && (board[row][col - 1] == tile)){
        
        board[row][col - 1] = -1;
        board[row][col] = tile;
        x++;
        else{
            x++;
        }
        
        }
        if ((d == 1) && (board[row][col + 1] == tile)){
        
        board[row][col + 1] = -1;
        board[row][col] = tile;
        x++;
        else{
            x++;
        }
        
        }
}  
}
",0
jmil737,1695818937,12,"#include <stdio.h>
#define _CRT_SECURE_NO_WARNINGS

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){

int a = 1;
int b = 1;
int c = 1;
int d = 1;
int row;
int col;
int tilecol;

for (int i = 0; i < 4; i++){
    
    
    for (int j = 0; j < 4; j++){
        
    if (board[i][j] == -1){
    
        row = i;
        col = j;
       
    }
    
    }
}

for (int i = 0; i < 4; i++){
    
    
    for (int j = 0; j < 4; j++){
        
    if (board[i][j] == tile){
    
        tilecol = j;
       
    }
    
    }
}

int x;
x = 1;

while (x == 1){
    
if ((tilecol == 3) && (col == 0)){
break;
}

if ((tilecol == 0) && (col == 3)){
break;
}


        if ((a == 1) && (board[row - 1][col] == tile)){
        
        board[row - 1][col] = -1;
        board[row][col] = tile;
        x++;
        
        }
        else{
            x++;
        }
        if ((b == 1) && (board[row + 1][col] == tile)){
    
        board[row + 1][col] = -1;
        board[row][col] = tile;
        x++;
        
        }
        else{
            x++;
        }
        
        }
        if ((c == 1) && (board[row][col - 1] == tile)){
        
        board[row][col - 1] = -1;
        board[row][col] = tile;
        x++;
        
        }
        else{
            x++;
        }
        
        }
        if ((d == 1) && (board[row][col + 1] == tile)){
        
        board[row][col + 1] = -1;
        board[row][col] = tile;
        x++;
        
        }
        else{
            x++;
        }
        
        }
}  
}
",0
jmil737,1695819013,13,"#include <stdio.h>
#define _CRT_SECURE_NO_WARNINGS

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){

int row;
int col;
int tilecol;

for (int i = 0; i < 4; i++){
    
    
    for (int j = 0; j < 4; j++){
        
    if (board[i][j] == -1){
    
        row = i;
        col = j;
       
    }
    
    }
}

for (int i = 0; i < 4; i++){
    
    
    for (int j = 0; j < 4; j++){
        
    if (board[i][j] == tile){
    
        tilecol = j;
       
    }
    
    }
}

int x;
x = 1;

while (x == 1){
    
if ((tilecol == 3) && (col == 0)){
break;
}

if ((tilecol == 0) && (col == 3)){
break;
}


        if (board[row - 1][col] == tile){
        
        board[row - 1][col] = -1;
        board[row][col] = tile;
        x++;
        
        }
        else{
            x++;
        }
        if (board[row + 1][col] == tile){
    
        board[row + 1][col] = -1;
        board[row][col] = tile;
        x++;
        
        }
        else{
            x++;
        }
        
        }
        if (board[row][col - 1] == tile){
        
        board[row][col - 1] = -1;
        board[row][col] = tile;
        x++;
        
        }
        else{
            x++;
        }
        
        }
        if (board[row][col + 1] == tile){
        
        board[row][col + 1] = -1;
        board[row][col] = tile;
        x++;
        
        }
        else{
            x++;
        }
        
        }
}  
}
",0
jmil737,1695819274,14,"#include <stdio.h>
#define _CRT_SECURE_NO_WARNINGS

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){

int row;
int col;
int tilecol;

for (int i = 0; i < 4; i++){
    
    
    for (int j = 0; j < 4; j++){
        
    if (board[i][j] == -1){
    
        row = i;
        col = j;
       
    }
    
    }
}

for (int i = 0; i < 4; i++){
    
    
    for (int j = 0; j < 4; j++){
        
    if (board[i][j] == tile){
    
        tilecol = j;
       
    }
    
    }
}

int x;
x = 1;

while (x == 1){
    
if ((tilecol == 3) && (col == 0)){
break;
}

if ((tilecol == 0) && (col == 3)){
break;
}


        if (board[row - 1][col] == tile){
        
        board[row - 1][col] = -1;
        board[row][col] = tile;
        x++;
        
        }
      
        if (board[row + 1][col] == tile){
    
        board[row + 1][col] = -1;
        board[row][col] = tile;
        x++;
        
        }
      
        
        
        if (board[row][col - 1] == tile){
        
        board[row][col - 1] = -1;
        board[row][col] = tile;
        x++;
        
        }
       
      
        if (board[row][col + 1] == tile){
        
        board[row][col + 1] = -1;
        board[row][col] = tile;
        x++;
        
        }
       
        x++;
        
        }

}
",1
jmul290,1695697542,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int colPos;
    int rowPos;
    int colPos_;
    int rowPos_;
    
    FindTile(board, tile, &rowPos, &colPos);
    FindTile(board, -1, &rowPos_, &colPos_);
    
    if (rowPos == 0 && colPos == 0){
        
        if (board[rowPos + 1][colPos] == -1){
            
         board[rowPos + 1][colPos] = tile;
         board[rowPos][colPos] = -1;
        }
        
        else if(board[rowPos][colPos + 1] == -1){
            
            board[rowPos][colPos + 1] = tile;
            board[rowPos][colPos] = -1;
            
        }
        return;
    }
        
        
    else if (rowPos == 0 && colPos != 0){
        
        if (board[rowPos + 1][colPos] == -1){
        
        board[rowPos + 1][colPos] = tile;
        board[rowPos][colPos] = -1;
        }
        
        else if (board[rowPos][colPos + 1] == -1){
            
            board[rowPos][colPos + 1] = tile;
            board[rowPos][colPos] = -1;
        }
            
        else if (board[rowPos][colPos - 1] == -1){
            
            board[rowPos][colPos - 1] = tile;
            board[rowPos][colPos] = -1;
        }
        return;
    }
        
        
    else if (colPos == 0 && rowPos != 0){
        
        if (board[rowPos + 1][colPos] == -1){

        board[rowPos + 1][colPos] = tile;
        board[rowPos][colPos] = -1;
        }
        
        else if (board[rowPos][colPos + 1] == -1){

            
            board[rowPos][colPos + 1] = tile;
            board[rowPos][colPos] = -1;
        }
            
        else if (board[rowPos - 1][colPos] == -1){

            board[rowPos - 1][colPos] = tile;
            board[rowPos][colPos] = -1;
            
        }
        else if (board[rowPos][colPos - 1] == -1){

            board[rowPos][colPos] = tile;
            
        }
        return;
    }
    else if(colPos_ == 0 && rowPos_ != 0){
        
        if(board[rowPos_ + 1][colPos_] == tile){
            
        board[rowPos_ + 1][colPos_] = -1;
        board[rowPos_][colPos_] = tile;
        }
        else if(board[rowPos_][colPos_ + 1] == tile){

            board[rowPos_][colPos_ + 1] = -1;
            board[rowPos_][colPos_] = tile;
            
        }
        else if (board[rowPos_ - 1][colPos_] == tile){
            
            board[rowPos_ - 1][colPos_] = -1;
            board[rowPos_][colPos_] = tile;
        }
        return;
    }
    
    
    
    else if(colPos != 0 && rowPos != 0){
        
        if (board[rowPos + 1][colPos] == -1){
        printf(""E"");
        board[rowPos + 1][colPos] = tile;
        board[rowPos][colPos] = -1;
        }
        
        else if (board[rowPos][colPos + 1] == -1){
         printf(""F"");   
            board[rowPos][colPos + 1] = tile;
            board[rowPos][colPos] = -1;
        }
            
        else if (board[rowPos - 1][colPos] == -1){
         printf(""G"");   
            board[rowPos - 1][colPos] = tile;
            board[rowPos][colPos] = -1;
        }
            
        else if (board[rowPos][colPos - 1] == -1){
         printf(""H"");   
            board[rowPos][colPos - 1] = tile;
            board[rowPos][colPos] = -1;
        }
        return;
            
    }
}",0
jmul290,1695697583,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int colPos;
    int rowPos;
    int colPos_;
    int rowPos_;
    
    FindTile(board, tile, &rowPos, &colPos);
    FindTile(board, -1, &rowPos_, &colPos_);
    
    if (rowPos == 0 && colPos == 0){
        
        if (board[rowPos + 1][colPos] == -1){
            
         board[rowPos + 1][colPos] = tile;
         board[rowPos][colPos] = -1;
        }
        
        else if(board[rowPos][colPos + 1] == -1){
            
            board[rowPos][colPos + 1] = tile;
            board[rowPos][colPos] = -1;
            
        }
        return;
    }
        
        
    else if (rowPos == 0 && colPos != 0){
        
        if (board[rowPos + 1][colPos] == -1){
        
        board[rowPos + 1][colPos] = tile;
        board[rowPos][colPos] = -1;
        }
        
        else if (board[rowPos][colPos + 1] == -1){
            
            board[rowPos][colPos + 1] = tile;
            board[rowPos][colPos] = -1;
        }
            
        else if (board[rowPos][colPos - 1] == -1){
            
            board[rowPos][colPos - 1] = tile;
            board[rowPos][colPos] = -1;
        }
        return;
    }
        
        
    else if (colPos == 0 && rowPos != 0){
        
        if (board[rowPos + 1][colPos] == -1){

        board[rowPos + 1][colPos] = tile;
        board[rowPos][colPos] = -1;
        }
        
        else if (board[rowPos][colPos + 1] == -1){

            
            board[rowPos][colPos + 1] = tile;
            board[rowPos][colPos] = -1;
        }
            
        else if (board[rowPos - 1][colPos] == -1){

            board[rowPos - 1][colPos] = tile;
            board[rowPos][colPos] = -1;
            
        }
        else if (board[rowPos][colPos - 1] == -1){

            board[rowPos][colPos] = tile;
            
        }
        return;
    }
    else if(colPos_ == 0 && rowPos_ != 0){
        
        if(board[rowPos_ + 1][colPos_] == tile){
            
        board[rowPos_ + 1][colPos_] = -1;
        board[rowPos_][colPos_] = tile;
        }
        else if(board[rowPos_][colPos_ + 1] == tile){

            board[rowPos_][colPos_ + 1] = -1;
            board[rowPos_][colPos_] = tile;
            
        }
        else if (board[rowPos_ - 1][colPos_] == tile){
            
            board[rowPos_ - 1][colPos_] = -1;
            board[rowPos_][colPos_] = tile;
        }
        return;
    }
    
    
    
    else if(colPos != 0 && rowPos != 0){
        
        if (board[rowPos + 1][colPos] == -1){

        board[rowPos + 1][colPos] = tile;
        board[rowPos][colPos] = -1;
        }
        
        else if (board[rowPos][colPos + 1] == -1){

            board[rowPos][colPos + 1] = tile;
            board[rowPos][colPos] = -1;
        }
            
        else if (board[rowPos - 1][colPos] == -1){
  
            board[rowPos - 1][colPos] = tile;
            board[rowPos][colPos] = -1;
        }
            
        else if (board[rowPos][colPos - 1] == -1){
 
            board[rowPos][colPos - 1] = tile;
            board[rowPos][colPos] = -1;
        }
        return;
            
    }
}",1
jpar523,1696235345,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int swapRow, swapCol, emptyRow, emptyCol;
    
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &swapRow, &swapCol);
    
    if ((emptyRow == swapRow && swapCol - emptyCol == -1) || (emptyRow == swapRow && swapCol - emptyCol == 1)|| (emptyCol == swapCol && swapRow - emptyRow == -1) || (emptyCol == swapCol && swapRow - emptyRow == 1)){
        board[emptyRow][emptyCol] = tile;
        board[swapRow][swapCol] = -1;
    }
    
        
}",1
jpar523,1696235935,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int swapRow, swapCol, emptyRow, emptyCol;
    
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &swapRow, &swapCol);
    
    if ((emptyRow == swapRow && swapCol - emptyCol == -1) || (emptyRow == swapRow && swapCol - emptyCol == 1)|| 
    (emptyCol == swapCol && swapRow - emptyRow == -1) || (emptyCol == swapCol && swapRow - emptyRow == 1)){
        board[emptyRow][emptyCol] = tile;
        board[swapRow][swapCol] = -1;
    }
    
        
}",1
jpar611,1696151741,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row, col, emptyRow, emptyCol;

    // Find the tile to be moved
    FindTile(board, tile, &row, &col);

    // Find the empty tile (-1)
    FindTile(board, -1, &emptyRow, &emptyCol);

    // Check if the tile to be moved is adjacent to the empty tile
    if ((row == emptyRow && (col == emptyCol + 1 || col == emptyCol - 1)) || 
        (col == emptyCol && (row == emptyRow + 1 || row == emptyRow - 1))) {
        
        // Swap the tiles
        board[emptyRow][emptyCol] = tile;
        board[row][col] = -1;
    }
}
",1
jpat915,1695869483,1,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    
    int emptyRow;
    int emptyCol;
    int tileRow;
    int tileCol;
    int temp;
    
    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol);
    
    if ((tileRow == emptyRow && tileCol == emptyCol - 1) || (tileRow == emptyRow && tileCol == emptyCol + 1)
        || (tileCol == emptyCol && tileRow == emptyRow - 1) || (tileCol == emptyCol && tileRow == emptyRow + 1)){
        
        temp = board[tileRow][tileCol];
        board[tileRow][tileCol] = board[emptyRow][emptyCol];
        board[emptyRow][emptyCol] = temp;
    }
}",1
jpau410,1695728877,1,"#include <stdio.h>
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowCurrent, colCurrent, rowGap, colGap;
    FindTile(board, tile, &rowCurrent, &colCurrent);
    FindTile(board, -1, &rowGap, &colGap);
    if ((rowCurrent - 1 == rowGap && colCurrent == colGap) || 
        (rowCurrent + 1 == rowGap && colCurrent == colGap) ||
        (colCurrent - 1 == colGap && rowCurrent == rowGap) || 
        (colCurrent + 1 == colGap && rowCurrent == rowGap)) {
        board[rowCurrent][colCurrent] = -1;
        board[rowGap][colGap] = tile;
        return;
    }
    
}",1
jpaz106,1696235133,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int i, j;
    int tileRow, tileCol;
    int spacerRow, spacerColumn;
    
    for (i = 0; i < NUM_ROWS; i++) {
        for (j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == tile) {
                tileRow = i;
                tileCol = j;
                return;
            }
            
            // Calling out FindTile
            FindTile(board, -1, spacerRow, spacerCol);
            
            if ((tileRow == spacerRow && (tileCol == spacerCol + 1 || tileCol == spacerCol - 1)) ||
                (tileCol == spacerCol && (tileRow == spacerRow + 1 || tileRow == spacerRow - 1))) {
                    int temp = board[tileRow][tileCol];
                    
                    board[tileRow][tileCol] = board[spacerRow][spacerCol];
                    board[spacerRow][spacerCol] = temp;
            }
        }
    }
}",0
jpaz106,1696237026,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int i, j;
    int tileRow = -1;
    int tileCol = -1;
    int spacerRow, spacerCol;
    
    // Calling out FindTile
    FindTile(board, -1, &spacerRow, &spacerCol);
    int *spacer = &board[spacerRow][spacerCol];
    
    for (i = 0; i < NUM_ROWS; i++) {
        for (j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == tile) {
                tileRow = i;
                tileCol = j;
                break;
            }
        }
    }
    
    if (tileRow == -1 ||  tileCol == -1) {
        return;
    }
            
    if ((tileRow == spacerRow && (tileCol == spacerCol + 1 || tileCol == spacerCol - 1)) ||
        (tileCol == spacerCol && (tileRow == spacerRow + 1 || tileRow == spacerRow - 1))) {
            int temp = board[tileRow][tileCol];
            
            board[tileRow][tileCol] = *spacer;
            *spacer = temp;
    }
}",1
jpud993,1696170203,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j;
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == tile) {
				board[i][j] = -1;
			}
			else if (board[i][j] == -1) {
				board[i][j] = tile;
			}
		}
	}
	return;
}
",0
jpud993,1696172702,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j;
	int rowPos = -1;
	int colPos = -1;
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == tile) {
				rowPos = i;
				colPos = j;
			}
			if (board[rowPos + 1][colPos] == -1 || board[rowPos - 1][colPos] == -1 || board[rowPos][colPos + 1] == -1 || board[rowPos][colPos - 1] == -1) {
					if (board[i][j] == tile) {
						board[i][j] = -1;
					}
					else if (board[i][j] == -1) {
						board[i][j] = tile;
					}
			}
		}
	}
	return;
}",0
jpud993,1696173388,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j;
	int rowTile = -1;
	int colTile = -1;
	int rowEmpty = -1;
	int colEmpty = -1;
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == tile) {
				rowTile = i;
				colTile = j;
			}
			else if (board[i][j] == -1) {
				rowEmpty = i;
				colEmpty = j;
			}
			if (board[rowTile + 1][colTile] == -1 || board[rowTile - 1][colTile] == -1 || board[rowTile][colTile + 1] == -1 || board[rowTile][colTile - 1] == -1) {
				board[rowTile][colTile] = -1;
				board[rowEmpty][colEmpty] = tile;
			}
		}
	}
	return;
}
",0
jpud993,1696188922,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j;
	int rowTile = -1;
	int colTile = -1;
	int rowEmpty = -1;
	int colEmpty = -1;
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == tile) {
				rowTile = i;
				colTile = j;
			}
			else if (board[i][j] == -1) {
				rowEmpty = i;
				colEmpty = j;
			}
		}
	}
			if (board[rowTile + 1][colTile] == -1 || board[rowTile - 1][colTile] == -1 || board[rowTile][colTile + 1] == -1 || board[rowTile][colTile - 1] == -1) {
				board[rowTile][colTile] = -1;
				board[rowEmpty][colEmpty] = tile;
			}
			return;
}
",0
jpud993,1696210243,5,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j;
	int rowTile = -1;
	int colTile = -1;
	int rowEmpty = -1;
	int colEmpty = -1;
	FindTile(board, tile, &rowTile, &colTile);
	FindTile(board, -1, &rowEmpty, &colEmpty);

	if (board[rowTile + 1][colTile] == -1 || board[rowTile - 1][colTile] == -1 || board[rowTile][colTile + 1] == -1 || board[rowTile][colTile - 1] == -1) {
		board[rowTile][colTile] = -1;
		board[rowEmpty][colEmpty] = tile;
	}
			return;
}
",0
jpud993,1696210269,6,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowTile = -1;
	int colTile = -1;
	int rowEmpty = -1;
	int colEmpty = -1;
	FindTile(board, tile, &rowTile, &colTile);
	FindTile(board, -1, &rowEmpty, &colEmpty);

	if (board[rowTile + 1][colTile] == -1 || board[rowTile - 1][colTile] == -1 || board[rowTile][colTile + 1] == -1 || board[rowTile][colTile - 1] == -1) {
		board[rowTile][colTile] = -1;
		board[rowEmpty][colEmpty] = tile;
	}
			return;
}
",0
jpud993,1696211893,7,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j;
	int rowTile = -1;
	int colTile = -1;
	int rowEmpty = -1;
	int colEmpty = -1;
	FindTile(board, tile, &rowTile, &colTile);
	FindTile(board, -1, &rowEmpty, &colEmpty);

	if (rowTile > 0) {
		if (board[rowTile + 1][colTile] == -1) {
			board[rowTile][colTile] = -1;
			board[rowEmpty][colEmpty] = tile;
		}
	}
	if (rowTile < 3) {
		if (board[rowTile - 1][colTile] == -1) {
			board[rowTile][colTile] = -1;
			board[rowEmpty][colEmpty] = tile;
		}
	}

	if (colTile > 0) {
		if (board[rowTile][colTile + 1] == -1) {
			board[rowTile][colTile] = -1;
			board[rowEmpty][colEmpty] = tile;
		}
	}
	if (colTile < 3) {
		if (board[rowTile][colTile - 1] == -1) {
			board[rowTile][colTile] = -1;
			board[rowEmpty][colEmpty] = tile;
		}
	}
}
",0
jpud993,1696211906,8,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowTile = -1;
	int colTile = -1;
	int rowEmpty = -1;
	int colEmpty = -1;
	FindTile(board, tile, &rowTile, &colTile);
	FindTile(board, -1, &rowEmpty, &colEmpty);

	if (rowTile > 0) {
		if (board[rowTile + 1][colTile] == -1) {
			board[rowTile][colTile] = -1;
			board[rowEmpty][colEmpty] = tile;
		}
	}
	if (rowTile < 3) {
		if (board[rowTile - 1][colTile] == -1) {
			board[rowTile][colTile] = -1;
			board[rowEmpty][colEmpty] = tile;
		}
	}

	if (colTile > 0) {
		if (board[rowTile][colTile + 1] == -1) {
			board[rowTile][colTile] = -1;
			board[rowEmpty][colEmpty] = tile;
		}
	}
	if (colTile < 3) {
		if (board[rowTile][colTile - 1] == -1) {
			board[rowTile][colTile] = -1;
			board[rowEmpty][colEmpty] = tile;
		}
	}
}
",0
jpud993,1696212148,9,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowTile = -1;
	int colTile = -1;
	int rowEmpty = -1;
	int colEmpty = -1;
	FindTile(board, tile, &rowTile, &colTile);
	FindTile(board, -1, &rowEmpty, &colEmpty);

 if ((rowTile == rowEmpty && (colTile == colEmpty + 1 || colTile == colEmpty - 1)) ||
        (colTile == colEmpty && (rowTile == rowEmpty + 1 || rowTile == rowEmpty - 1))) {
        board[rowEmpty][colEmpty] = tile;
        board[rowTile][colTile] = -1;
    }
}",1
jros811,1695855950,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowTile = -1;
	int colTile = -1;
	int rowPos = -1;
	int colPos = -1;
	FindTile(board, -1, &rowPos, &colPos);
	for (int i = 0; i < NUM_ROWS; i++) {
		for (int j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == tile) {
				rowTile = i;
				colTile = j;
			}
		}
	}
	if ((rowTile == rowPos && (colTile == colPos + 1 || colTile == colPos - 1)) || (colTile == colPos && (rowTile == rowPos + 1 || rowTile == rowPos - 1))) {
		board[rowTile][colTile] = -1;
		board[rowPos][colPos] = tile;
	}
}",1
jsan813,1696222198,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, rowTile, colTile;
	int checkRow, checkCol;

	FindTile(board, -1, &row, &col);
	FindTile(board, tile, &rowTile, &colTile);

	checkRow = rowTile - row;
	checkCol = colTile - col;
	if ((checkRow == 1 && checkCol == 0) || (checkRow == -1 && checkCol == 0) || (checkCol == 1 && checkRow == 0) || (checkCol == -1 && checkRow == 0)) {
		board[row][col] = tile;
		board[rowTile][colTile] = -1;
	}

}",1
jsch842,1696209319,1,"#include <stdio.h>
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyRow, emptyCol;
    int tileRow, tileCol;
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);
    board[emptyRow][emptyCol] = tile;
    board[tileRow, tileCol] = -1;
}",0
jsch842,1696209349,2,"#include <stdio.h>
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyRow, emptyCol;
    int tileRow, tileCol;
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);
    board[emptyRow][emptyCol] = tile;
    board[tileRow][tileCol] = -1;
}",0
jsch842,1696209760,3,"#include <stdio.h>
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyRow, emptyCol;
    int tileRow, tileCol;
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);
    
    {
        if (tileRow == emptyRow && (tileCol == emptyCol + 1 || tileCol == emptyCol - 1)) || (tileCol == emptyCol && (tileRow == emptyRow + 1 || tileRow == emptyRow - 1))
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
    else 
    return board;
}",0
jsch842,1696209945,4,"#include <stdio.h>
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyRow, emptyCol;
    int tileRow, tileCol;
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);
    
    {
        if (tileRow == emptyRow && (tileCol == emptyCol + 1 || tileCol == emptyCol - 1)) || (tileCol == emptyCol && (tileRow == emptyRow + 1 || tileRow == emptyRow - 1))
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}",0
jsch842,1696210015,5,"#include <stdio.h>
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyRow, emptyCol;
    int tileRow, tileCol;
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);
    
    {
        if ((tileRow == emptyRow && (tileCol == emptyCol + 1 || tileCol == emptyCol - 1)) || (tileCol == emptyCol && (tileRow == emptyRow + 1 || tileRow == emptyRow - 1)))
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}",0
jsch842,1696210180,6,"#include <stdio.h>
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyRow, emptyCol;
    int tileRow, tileCol;
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);
    
    {
        if ((tileRow == emptyRow && (tileCol == emptyCol + 1 || tileCol == emptyCol - 1)) || (tileCol == emptyCol && (tileRow == emptyRow + 1 || tileRow == emptyRow - 1)))
        {
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
        }
    }
}",1
jshe464,1696218778,1," void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
 {
	 int row, col, rowa, cola;
	 FindTile(board, -1, &row, &col);
	 FindTile(board, tile, &rowa, &cola);
	 if (rowa == row - 1 || rowa == row + 1)
	 {
		 if (cola == col - 1 || cola == col + 1)
		 {
			 board[row][col] = tile;
			 board[rowa][cola] = -1;
				 
		 }
	 }
 }",0
jshe464,1696219108,2," void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
 int row, col, rowa, cola;
 FindTile(board, -1, &row, &col);
 FindTile(board, tile, &rowa, &cola);
 if (cola == col) 
 {
	 if (rowa == row - 1 || rowa == row + 1)
	 { 
			 board[row][col] = tile;
			 board[rowa][cola] = -1;

	 }
 }
 if(rowa == row)
 {
	 if (cola == col - 1 || cola == col + 1)
	 {
		 board[row][col] = tile;
		 board[rowa][cola] = -1;

	 }
 }
}",1
jshi444,1695872219,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{

	// Intitialise

	int i = 0;
	int j = 0;
	int row_gap_pos = 0;
	int col_gap_pos = 0;
	int tile_move_row = 0;
	int tile_move_col = 0;
	int x = 0;
	int y = 0;

	// Finding the gap

	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == -1) {
				row_gap_pos = i;
				col_gap_pos = j;
			}
		}
	}

	// Finding the tile

	for (x = 0; x < NUM_ROWS; x++) {
		for (y = 0; y < NUM_COLS; y++) {
			if (board[x][y] == tile) {
				tile_move_row = x;
				tile_move_col = y;
			}
		}
	}

	// Switching mechanism which avoids the diagonals

	if (abs(tile_move_row - row_gap_pos) == 1 && tile_move_col == col_gap_pos)
	{
		board[row_gap_pos][col_gap_pos] = tile;
		board[tile_move_row][tile_move_col] = -1;
	}

	else if (abs(tile_move_col - col_gap_pos) == 1 && tile_move_row == row_gap_pos) 
	{
		board[row_gap_pos][col_gap_pos] = tile;
		board[tile_move_row][tile_move_col] = -1;
	}
}",1
jsim418,1695624210,1,"#include <stdlib.h>
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    int row, col;
    FindTile(board, -1, &row, &col);
    int locationEmptyRow = row;
    int locationEmptyCol = col;
    
    int row2, col2;
    FindTile(board, tile, &row2, &col2);
    int locationTileRow = row2;
    int locationTileCol = col2;

    if (((abs(locationEmptyRow - locationTileRow)) == 1 && (abs(locationEmptyCol - locationTileCol) == 0)) || ((abs(locationEmptyRow - locationTileRow)) == 0 && (abs(locationEmptyCol - locationTileCol) == 1))) {
        board[locationEmptyRow][locationEmptyCol] = tile;
        board[locationTileRow][locationTileCol] = -1;
        //printf(""Condition met.\n"");
    } else {
        //printf(""Condition not met.\n"");
    }
}
",1
jsim643,1695933587,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol;
    int tileRow, tileCol;
    
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);
    
    if ((tileRow == emptyRow && (tileCol == emptyCol + 1 || tileCol == emptyCol - 1)) ||
        (tileCol == emptyCol && (tileRow == emptyRow + 1 || tileRow == emptyRow - 1))) {
            
        int temp = board[tileRow][tileCol];
        board[tileRow][tileCol] = board[emptyRow][emptyCol];
        board[emptyRow][emptyCol] = temp;
    }
}",1
jsta466,1695711122,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int adjRow, adjCol;
    int spaceRow, spaceCol;

    FindTile(board, -1, &spaceRow, &spaceCol);
    FindTile(board, tile, &adjRow, &adjCol);

    if ((spaceRow == adjRow && (spaceCol == adjCol - 1 || spaceCol == adjCol + 1)) ||
        (spaceCol == adjCol && (spaceRow == adjRow - 1 || spaceRow == adjRow + 1))) {
        int temp = board[spaceRow][spaceCol];
        board[spaceRow][spaceCol] = board[adjRow][adjCol];
        board[adjRow][adjCol] = temp;
    }
}
",1
jsun284,1696215507,1,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    FindTile(board, tile, &row, &col);
    FindTile(board, -1, &emptyRow, &emptyCol);

    if ((row == emptyRow && abs(col - emptyCol) == 1) || (col == emptyCol && abs(row - emptyRow) == 1)) {
        board[emptyRow][emptyCol] = tile;
        board[row][col] = -1;
    }
}",0
jsun284,1696215594,2,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row, col, emptyRow, emptyCol;
    FindTile(board, tile, &row, &col);
    FindTile(board, -1, &emptyRow, &emptyCol);

    if ((row == emptyRow && abs(col - emptyCol) == 1) || (col == emptyCol && abs(row - emptyRow) == 1)) {
        board[emptyRow][emptyCol] = tile;
        board[row][col] = -1;
    }
}",1
jwed606,1695947023,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int empty_row, empty_col;
    int tile_row, tile_col;

    FindTile(board, -1, &empty_row, &empty_col);
    FindTile(board, tile, &tile_row, &tile_col);

    int dist_abs = abs(empty_row - tile_row) + abs(empty_col - tile_col);

    // Only make a move if tile to be moved is actually next to empty space
    if (dist_abs > 1)
        return;

    // Now copy crap across
    board[empty_row][empty_col] = tile;
    board[tile_row][tile_col] = -1;
}",1
jwil813,1695788925,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowT, colT, rowone, colone;

	FindTile(board, tile, &rowT, &colT);
	FindTile(board, -1, &rowone, &colone);

	if (rowone + 1 == rowT || rowone - 1 == rowT)
	{
		if (colone == colT) 
		{
			int store = board[rowT][colT];
			board[rowT][colT] = board[rowone][colone];
			board[rowone][colone] = store;
		}
	}
	else if (colone + 1 == colT || colone - 1 == colT)
	{ 
		if(rowone == rowT)
		{
			int stored;
			stored = board[rowT][colT];
			board[rowT][colT] = board[rowone][colone];
			board[rowone][colone] = stored;
		}
	}	

}",1
jwon248,1695710241,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j;
	int emptyRow, emptyCol;
	int topRow, topCol, botRow, botCol, leftRow, leftCol, rightRow, rightCol;
	for (i = 0; i < NUM_ROWS; i++)
	{
		for (j = 0; j < NUM_COLS; j++)
		{
			/*find the tile location*/
			if (board[i][j] == tile)
			{

				/*find whether -1 is adjacent*/
				topRow = i + 1;
				topCol = j;

				botRow = i - 1;
				botCol = j;

				leftRow = i;
				leftCol = j - 1;

				rightRow = i;
				rightCol = j + 1;

				if (topRow >= 0)
				{
					if (board[topRow][topCol] == -1)
					{
						emptyRow = topRow;
						emptyCol = topCol;
						/*swap the tiles*/
						board[i][j] = -1;
						board[emptyRow][emptyCol] = tile;
						return;
					}
				}

				if (botRow < NUM_ROWS)
				{
					if (board[botRow][botCol] == -1)
					{
						emptyRow = botRow;
						emptyCol = botCol;
						/*swap the tiles*/
						board[i][j] = -1;
						board[emptyRow][emptyCol] = tile;
						return;
					}
				}

				if (leftCol >= 0)
				{
					if (board[leftRow][leftCol] == -1)
					{
						emptyRow = leftRow;
						emptyCol = leftCol;
						/*swap the tiles*/
						board[i][j] = -1;
						board[emptyRow][emptyCol] = tile;
						return;
					}
				}

				if (rightCol < NUM_COLS)
				{
					if (board[rightRow][rightCol] == -1)
					{
						emptyRow = rightRow;
						emptyCol = rightCol;
						/*swap the tiles*/
						board[i][j] = -1;
						board[emptyRow][emptyCol] = tile;
						return;
					}
				}

				return;
			}
		}
	}

	return;
}",1
jwon253,1696057764,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tileRow, tileCol, emptyRow, emptyCol;

	// Find the positions of the tile and empty square
	FindTile(board, tile, &tileRow, &tileCol);
	FindTile(board, -1, &emptyRow, &emptyCol);

	// Check if the tile is to the left of the empty tile
	if (tileRow == emptyRow && tileCol == emptyCol - 1)
	{
		board[emptyRow][emptyCol] = tile;
		board[tileRow][tileCol] = -1;
		return;
	}

	// Check if the tile is to the right of the empty tile
	if (tileRow == emptyRow && tileCol == emptyCol + 1)
	{
		board[emptyRow][emptyCol] = tile;
		board[tileRow][tileCol] = -1;
		return;
	}

	// Check if the tile is above the empty tile
	if (tileCol == emptyCol && tileRow == emptyRow - 1)
	{
		board[emptyRow][emptyCol] = tile;
		board[tileRow][tileCol] = -1;
		return;
	}

	// Check if the tile is below the empty tile
	if (tileCol == emptyCol && tileRow == emptyRow + 1)
	{
		board[emptyRow][emptyCol] = tile;
		board[tileRow][tileCol] = -1;
		return;
	}
}",1
jwon323,1695804808,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row;
    int col;
    
    // find the tile (9)
    FindTile(board, tile, &row, &col);
    
    // check if the empty tile is adjacent to the tile you want to move
    // check row above
    if (row>0) {
        if  (board[row-1][col] == -1) {
            board[row-1][col] = board[row][col];
            board[row][col] = -1;
        }
    }
// check row below
    if (row<3) {
        if (board[row+1][col] == -1) { 
            board[row+1][col] = board[row][col];
            board[row][col] = -1;
        }
    }
        //check left column
    if (col>0) {
        if (board[row][col-1] == -1) {
            board[row][col-1] = board[row][col];
            board[row][col] = -1;
        }
    }
//check right column
    if (col<3) {
        if (board[row][col+1] == -1) {
            board[row][col+1] = board[row][col];
            board[row][col] = -1;
        }
    }
}",1
jyan420,1695691815,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int emptyRow, emptyCol = -2;
	int tileRow, tileCol = -2;
	FindTile(board, -1, &emptyRow, &emptyCol);
	FindTile(board, tile, &tileRow, &tileCol);
	// Is it on the same row?
	if (emptyRow == tileRow) {
		// Is it on an adjacent column?
		if ((emptyCol + 1 == tileCol) || (emptyCol - 1 == tileCol)) {
			// Swap
			board[emptyRow][emptyCol] = tile;
			board[tileRow][tileCol] = -1;
		}
	} // Is it on the same column?
	else if (emptyCol == tileCol) {
		// Is it on an adjacent row?
		if ((emptyRow + 1 == tileRow) || (emptyRow - 1 == tileRow)) {
			// Swap
			board[emptyRow][emptyCol] = tile;
			board[tileRow][tileCol] = -1;
		}
	}
}",1
jyua529,1695809455,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) 
{
    int row, col;
    int i, j; 
    int r, c;
    
     for(i = 0; i < NUM_ROWS; i++){
        for(j = 0; j < NUM_COLS; j++) {
            if(board[i][j] == tile) {
                r = i;
                c = j;

            }       
        
        }
        
    }
    FindTile(board, -1, &row, &col);

    if (r == row + 1 || r == row -1){
        board[row][col] = tile;
        board[r][c] = -1;
    }
    if (c == col + 1 || c == col -1) {
        board[row][col] = tile;
        board[r][c] = -1;
    }



}
",0
jyua529,1695863840,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) 
{
    int row, col;
    int i, j; 
    int r, c;
    
    FindTile(board, tile, &r, &c);

    FindTile(board, -1, &row, &col);

    if ((r == row && (c == col + 1 || c == col - 1)) || (c == col && (r == row + 1 || r == row - 1))){
        board[row][col] = tile;
        board[r][c] = -1;

    }

}
",0
jyua529,1695864183,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) 
{
    int row, col;
    int r, c;
    
    FindTile(board, tile, &r, &c);

    FindTile(board, -1, &row, &col);

    if ((r == row && (c == col + 1 || c == col - 1)) || (c == col && (r == row + 1 || r == row - 1))){
        board[row][col] = tile;
        board[r][c] = -1;

    }

}
",1
jzho786,1696232340,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileR, tileC, emptyR, emptyC;

    FindTile(board, tile, &tileR, &tileC);
    FindTile(board, -1, &emptyR, &emptyC);

    int rowDistance, colDistance;
    
    rowDistance = tileR - emptyR;
    colDistance = tileC - emptyC;
    
    if ((rowDistance + colDistance) * (rowDistance + colDistance) == 1){
    
        board[emptyR][emptyC] = tile;
        board[tileR][tileC] = -1;
    }
}",1
kabb319,1695958865,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowempty, colempty, col, row;
    FindTile(board, -1, &rowempty, &colempty);

    FindTile(board, tile, &row, &col);

    if (row == rowempty + 1 || row == rowempty - 1 || col == colempty + 1 || col == colempty - 1){
        board[rowempty][colempty] = tile;
        board[row][col] = -1;
    }

}",0
kabb319,1695960247,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowempty, colempty, col, row;
    FindTile(board, -1, &rowempty, &colempty);

    FindTile(board, tile, &row, &col);

    if ((row == rowempty + 1 && col == colempty)|| (row == rowempty - 1 && col == colempty) || (col == colempty + 1 && row == rowempty) || (col == colempty - 1 && row == rowempty)){
        board[rowempty][colempty] = tile;
        board[row][col] = -1;
    }

}",1
kahk161,1695697702,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;
	int up, down, left, right;
	int* current, * empty;
	for (row = 0; row < NUM_ROWS; row++) {
		for (col = 0; col < NUM_COLS; col++) {
			if (board[row][col] == tile) {
				up = row - 1;
				down = row + 1;
				left = col - 1;
				right = col + 1;
				current = &board[row][col];

				if (board[up][col] == -1 && up >= 0) {
					empty = &board[up][col];
					int temp = *current;
					*current = *empty;
					*empty = temp;
					return;
				}
				else if (board[down][col] == -1 && down <= 3) {
					empty = &board[down][col];
					int temp = *current;
					*current = *empty;
					*empty = temp;
					return;
				}
				else if (board[row][left] == -1 && left >= 0) {
					empty = &board[row][left];
					int temp = *current;
					*current = *empty;
					*empty = temp;
					return;
				}
				else if (board[row][right] == -1 && right <= 3) {
					empty = &board[row][right];
					int temp = *current;
					*current = *empty;
					*empty = temp;
					return;
				}
			}
		}
	}
}",1
kbar402,1696232516,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    
    int rowPos, colPos;
    int newRowPos, newColPos;
    
    FindTile(board, tile, &newRowPos, &newColPos);
    
    FindTile(board, -1, &rowPos, &colPos);

    if (((rowPos - 1) == newRowPos) & ((colPos == newColPos))) {
        board[newRowPos][newColPos] = -1;
        board[rowPos][colPos] = tile;
    } else if (((rowPos + 1) == newRowPos) & ((colPos == newColPos))) {
        board[newRowPos][newColPos] = -1;
        board[rowPos][colPos] = tile;
    } else if ((rowPos == newRowPos) & (((colPos - 1) == newColPos))) {
        board[newRowPos][newColPos] = -1;
        board[rowPos][colPos] = tile;
    } else if ((rowPos == newRowPos) & (((colPos + 1) == newColPos))) {
        board[newRowPos][newColPos] = -1;
        board[rowPos][colPos] = tile;
    }
    
}",1
kbha969,1695791737,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	{
    int row, col,rowt,colt,newt;
    FindTile(board, -1, &row, &col);
    FindTile(board,tile, &rowt, &colt);
    

    if ((rowt > 0) && (rowt == row + 1) && (col == colt)) {
        newt = board[row][col];
        board[row][col] = board[rowt][colt];
        board[rowt][colt] = newt;

    }
    else if ((rowt < NUM_ROWS) && (rowt == row - 1) && (col == colt)) {
        newt = board[row][col];
        board[row][col] = board[rowt][colt];
        board[rowt][colt] = newt;;
        
    }
    else if ((colt > 0) && (colt == col + 1) && (row == rowt)) {
        newt = board[row][col];
        board[row][col] = board[rowt][colt];
        board[rowt][colt] = newt;

    }
    else if ((colt < NUM_COLS) && (colt == col - 1) && (row == rowt)) {
        newt = board[row][col];
        board[row][col] = board[rowt][colt];
        board[rowt][colt] = newt;

    }
    else {
        return;
    }

    } 
}",1
kcao565,1696060339,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int emptyRow, emptyCol, tileRow, tileCol;

	FindTile(board, -1, &emptyRow, &emptyCol);
	FindTile(board, tile, &tileRow, &tileCol);

	if ((emptyRow - tileRow == 1 && emptyCol == tileCol) ||
		(emptyRow - tileRow == -1 && emptyCol == tileCol) ||
		(emptyCol - tileCol == 1 && emptyRow == tileRow) ||
		(emptyCol - tileCol == -1 && emptyRow == tileRow)) {
		board[emptyRow][emptyCol] = tile;
		board[tileRow][tileCol] = -1;
	}
}",1
kcao657,1696138341,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, newRow, newCol;

	FindTile(board, tile, &row, &col);
	FindTile(board, -1, &newRow, &newCol);

	if (row > 0) {
		if ((row - 1) == newRow && (col) == newCol) {
			board[newRow][newCol] = tile;
			board[row][col] = -1;
		}
	}

	if (row < (NUM_ROWS - 1)) {
		if ((row + 1) == newRow && (col) == newCol) {
			board[newRow][newCol] = tile;
			board[row][col] = -1;
		}
	}

	if (col > 0) {
		if ((col - 1) == newCol && (row) == newRow) {
			board[newRow][newCol] = tile;
			board[row][col] = -1;
		}
	}

	if (col < (NUM_COLS - 1)) {
		if ((col + 1) == newCol && (row) == newRow) {
			board[newRow][newCol] = tile;
			board[row][col] = -1;
		}
	}

	

	

}",1
kfep063,1696230018,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    //this if function looks for the -1 or empty space.
    int rowPosition = -1;
    int colPosition = -1;
    FindTile(board, -1, &rowPosition, &colPosition);
    if (rowPosition == -1 || colPosition == -1) {
        printf(""No empty tile in board. "") ;
        return;
    }
    
    //with the input tile, this if function finds if there is a tile on the board.
    int tileRowPos = -1;
    int tileColPos = -1;
    FindTile(board, tile, &tileRowPos, &tileColPos);
    if (tileRowPos == -1 || tileColPos == -1) {
        printf(""No tile in board. "") ;
        return;
    }
    
    //with the adjacence of the tile and the empty space. This contols and allows the movement of the tile.
    if ((tileRowPos == rowPosition && (tileColPos == colPosition + 1 || tileColPos == colPosition - 1)) ||
        (tileColPos == colPosition && (tileRowPos == rowPosition + 1 || tileRowPos == rowPosition - 1))) {
        board[rowPosition][colPosition] = tile;
        board[tileRowPos][tileColPos] = -1;
        printf(""Successful movement of tile."") ;
    } else {
        printf(""Tile movement failed."");
    }

}",0
kfep063,1696230227,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    //this if function looks for the -1 or empty space.
    int rowPosition = -1;
    int colPosition = -1;
    FindTile(board, -1, &rowPosition, &colPosition);
    if (rowPosition == -1 || colPosition == -1) {
        printf(""No empty tile in board. "") ;
        return;
    }
    
    //with the input tile, this if function finds if there is a tile on the board.
    int tileRowPos = -1;
    int tileColPos = -1;
    FindTile(board, tile, &tileRowPos, &tileColPos);
    if (tileRowPos == -1 || tileColPos == -1) {
        printf(""No tile in board. "") ;
        return;
    }
    
    //with the adjacence of the tile and the empty space. This contols and allows the movement of the tile.
    if ((tileRowPos == rowPosition && (tileColPos == colPosition + 1 || tileColPos == colPosition - 1)) ||
        (tileColPos == colPosition && (tileRowPos == rowPosition + 1 || tileRowPos == rowPosition - 1))) {
        board[rowPosition][colPosition] = tile;
        board[tileRowPos][tileColPos] = -1;
        //printf(""Successful movement of tile."") ;
    //} else {
        //printf(""Tile movement failed."");
    }

}",1
kfer833,1696215335,1,"#include <iostream>

const int NUM_ROWS = 4;
const int NUM_COLS = 4;


bool isValidMove(int row, int col) {
    return row >= 0 && row < NUM_ROWS && col >= 0 && col < NUM_COLS;
}


void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int& row, int& col) {
    for (int i = 0; i < NUM_ROWS; ++i) {
        for (int j = 0; j < NUM_COLS; ++j) {
            if (board[i][j] == tile) {
                row = i;
                col = j;
                return;
            }
        }
    }
}


void PrintBoard(int board[NUM_ROWS][NUM_COLS]) {
    for (int i = 0; i < NUM_ROWS; ++i) {
        for (int j = 0; j < NUM_COLS; ++j) {
            if (board[i][j] == -1) {
                std::cout << "" _ "";
            } else {
                std::cout << "" "" << board[i][j] << "" "";
            }
        }
        std::cout << std::endl;
    }
}



void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol;
    FindTile(board, -1, emptyRow, emptyCol);


    int tileRow, tileCol;
    FindTile(board, tile, tileRow, tileCol);


    if ((std::abs(emptyRow - tileRow) == 1 && emptyCol == tileCol) ||
        (std::abs(emptyCol - tileCol) == 1 && emptyRow == tileRow)) {
       
        std::swap(board[emptyRow][emptyCol], board[tileRow][tileCol]);
    }
}",0
kfer833,1696215550,2,"const int NUM_ROWS = 4;
const int NUM_COLS = 4;

void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int& row, int& col) {
    for (int i = 0; i < NUM_ROWS; ++i) {
        for (int j = 0; j < NUM_COLS; ++j) {
            if (board[i][j] == tile) {
                row = i;
                col = j;
                return;
            }
        }
    }
}

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol;
    FindTile(board, -1, emptyRow, emptyCol);

    int tileRow, tileCol;
    FindTile(board, tile, tileRow, tileCol);

    
    if ((std::abs(emptyRow - tileRow) == 1 && emptyCol == tileCol) ||
        (std::abs(emptyCol - tileCol) == 1 && emptyRow == tileRow)) {
        
        std::swap(board[emptyRow][emptyCol], board[tileRow][tileCol]);
    }
}

void PrintBoard(int board[NUM_ROWS][NUM_COLS]) {
    for (int i = 0; i < NUM_ROWS; ++i) {
        for (int j = 0; j < NUM_COLS; ++j) {
            if (board[i][j] == -1) {
                std::cout << "" _ "";
            } else {
                std::cout << "" "" << board[i][j] << "" "";
            }
        }
        std::cout << std::endl;
    }
}
",0
kfer833,1696216049,3,"void MakeMove(int gameBoard[NUM_ROWS][NUM_COLS], int selectedTile) {
    int selected_tile_row, selected_tile_col;
    int empty_tile_row, empty_tile_col;

    FindTile(GameBoard, selectedTile, &selected_tile_row, &selected_tile_col);
    FindTile(GameBoard, -1, &empty_tile_row, &empty_tile_col);

    if ((abs(selected_tile_row - empty_tile_row) == 1 && selected_tile_col == empty_tile_col) ||
        (abs(selected_tile_col - empty_tile_col) == 1 && selected_tile_row == empty_tile_row)) {
       
        GameBoard[empty_tile_row][empty_tile_col] = selectedTile;
        GameBoard[selected_tile_row][selected_tile_col] = -1;
    }
}
",0
kfer833,1696216162,4,"void MakeMove(int GameBoard[NUM_ROWS][NUM_COLS], int selectedTile) {
    int selected_tile_row, selected_tile_col;
    int empty_tile_row, empty_tile_col;

    FindTile(GameBoard, selectedTile, &selected_tile_row, &selected_tile_col);
    FindTile(GameBoard, -1, &empty_tile_row, &empty_tile_col);

    if ((abs(selected_tile_row - empty_tile_row) == 1 && selected_tile_col == empty_tile_col) ||
        (abs(selected_tile_col - empty_tile_col) == 1 && selected_tile_row == empty_tile_row)) {
       
        GameBoard[empty_tile_row][empty_tile_col] = selectedTile;
        GameBoard[selected_tile_row][selected_tile_col] = -1;
    }
}
",1
kgra470,1695692299,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row,col,empty_row,empty_col;
    FindTile(board, tile, &row, &col);
    FindTile(board,-1,&empty_row,&empty_col);
    if (row + 1 == empty_row || row - 1 == empty_row) {
        board[row] [col] = -1;
        board[empty_row] [empty_col] = tile;
    }
    else if(col+1==empty_col||col-1==empty_col){
        board[row][col] = -1;
        board[empty_row] [empty_col] = tile;
    }

}",0
kgra470,1695693710,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row,col,empty_row,empty_col,row_adj=0,col_adj=0;
    FindTile(board, tile, &row, &col);
    FindTile(board,-1,&empty_row,&empty_col);
    if (row + 1 == empty_row || row - 1 == empty_row) {
        row_adj=1;
    }
    if(col+1==empty_col||col-1==empty_col){
        col_adj=1;
    }
    if (col_adj==1 && row_adj ==0) {
        board[row][col] = -1;
        board[empty_row][empty_col] = tile;
    }
    else if (row_adj==1 && col_adj==0){
        board[row][col] = -1;
        board[empty_row][empty_col] = tile;
    }

}",0
kgra470,1695694360,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row,col,empty_row,empty_col,row_adj=0,col_adj=0;
    FindTile(board, tile, &row, &col);
    FindTile(board,-1,&empty_row,&empty_col);
    if (row + 1 == empty_row || row - 1 == empty_row) {
        row_adj=1;
    }
    if(col+1==empty_col||col-1==empty_col){
        col_adj=1;
    }
    if (col_adj==1 && row==empty_row) {
        board[row][col] = -1;
        board[empty_row][empty_col] = tile;
    }
    else if (row_adj==1 && col==empty_col){
        board[row][col] = -1;
        board[empty_row][empty_col] = tile;
    }

}",1
khew624,1696161213,1,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4


void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol;
    int tileRow, tileCol;
    int foundTile = 0;

    // Find the positions of the specified tile and the empty square
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == tile) {
                tileRow = i;
                tileCol = j;
                foundTile = 1;
            }
            if (board[i][j] == -1) {
                emptyRow = i;
                emptyCol = j;
            }
        }
    }

  
    if (foundTile) {
        if ((tileRow == emptyRow && (tileCol == emptyCol - 1 || tileCol == emptyCol + 1)) ||
            (tileCol == emptyCol && (tileRow == emptyRow - 1 || tileRow == emptyRow + 1))) {
            board[emptyRow][emptyCol] = tile;
            board[tileRow][tileCol] = -1;
        }
    }
}",1
khew624,1696161280,2,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4


void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol;
    int tileRow, tileCol;
    int foundTile = 0;

    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == tile) {
                tileRow = i;
                tileCol = j;
                foundTile = 1;
            }
            if (board[i][j] == -1) {
                emptyRow = i;
                emptyCol = j;
            }
        }
    }

  
    if (foundTile) {
        if ((tileRow == emptyRow && (tileCol == emptyCol - 1 || tileCol == emptyCol + 1)) ||
            (tileCol == emptyCol && (tileRow == emptyRow - 1 || tileRow == emptyRow + 1))) {
            board[emptyRow][emptyCol] = tile;
            board[tileRow][tileCol] = -1;
        }
    }
}",1
kjoe685,1695997020,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	//find positions
	int blankRowPos, blankColPos, targetRowPos, targetColPos;
	FindTile(board, -1, &blankRowPos, &blankColPos);
	FindTile(board, tile, &targetRowPos, &targetColPos);

	// check up
	if ((blankRowPos != 0)&&(
			(targetRowPos == blankRowPos - 1)&&(targetColPos == blankColPos)
		)) {

	}
	//check down
	else if ((blankRowPos != NUM_ROWS-1) && (
			(targetRowPos == blankRowPos + 1) && (targetColPos == blankColPos)
		)) {

	}
	//check left
	else if ((blankColPos != 0) && (
			(targetRowPos == blankRowPos) && (targetColPos == blankColPos - 1)
		)) {

	}
	//check right
	else if ((blankColPos != NUM_COLS-1) && (
			(targetRowPos == blankRowPos) && (targetColPos == blankColPos + 1)
		)) {

	}
	else {
		return;
	}

	//make move
	board[blankRowPos][blankColPos] = tile;
	board[targetRowPos][targetColPos] = -1;
}",1
kjun638,1696152970,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tile_row, tile_col; 
	int empty_row, empty_col; 

	/*Get the position of the tile that needs to be moved to the empty square*/
	FindTile(board, tile, &tile_row, &tile_col);
	FindTile(board, -1, &empty_row, &empty_col); 

	/*Check if the tile is adjacent so they can be swapped*/
	if (tile_row == empty_row) {
		if (tile_col == empty_col + 1|| tile_col == empty_col - 1) {
			board[tile_row][tile_col] = -1; 
			board[empty_row][empty_col] = tile;
		}
	}
	else if (tile_col == empty_col) {
		if (tile_row == empty_row + 1 || tile_row == empty_row - 1) {
			board[tile_row][tile_col] = -1; 
			board[empty_row][empty_col] = tile;
		}
	}

}",1
kkha484,1696242684,1,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int RowOG, ColOG, emptyRow, emptyCol;

    FindTile(board, tile, &RowOG, &ColOG);
    FindTile(board, -1, &emptyRow, &emptyCol);

    if ((RowOG == emptyRow && abs(ColOG - emptyCol) == 1) ||
        (ColOG == emptyCol && abs(RowOG - emptyRow) == 1)) {
        
        int NewBoard = board[emptyRow][emptyCol];
        board[emptyRow][emptyCol] = board[RowOG][ColOG];
        board[RowOG][ColOG] = NewBoard;
    }
}",1
kkim985,1695782272,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row1, col1;
	FindTile(board, -1, &row1, &col1);

	int row2, col2;
	FindTile(board, tile, &row2, &col2);

	if ((row1 == row2 && (col1 == col2 - 1 || col1 == col2 + 1)) || (col1 == col2 && (row1 == row2 - 1 || row1 == row2 + 1))) {
		board[row1][col1] = tile;
		board[row2][col2] = -1;
	}
}",1
klam376,1696037787,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tileRow,tileCol,rPos,cPos;
	FindTile(board,tile,&tileRow,&tileCol);
    FindTile(board,-1,&rPos,&cPos);
    if ((tileRow==rPos && ((tileCol==cPos-1) || (tileCol==cPos+1))) || (tileCol==cPos && ((tileRow==rPos-1) || (tileRow==rPos+1)))) {
        board[tileRow][tileCol] = -1;
        board[rPos][cPos]=tile;
    }
}",1
kluc619,1696226014,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{ 
    int row, col, temp,row1,col1; 
    temp = tile;
    FindTile(board, -1, &row1, &col1);
    for (row = 0; row < NUM_ROWS; row++) 
    { 
        for (col = 0; col < NUM_COLS; col++) 
        { 
            if ((board[row][col] == tile) & ((board[row+1][col] == -1) | (board[row][col+1] == -1)| (board[row+1][col+1] == -1) | (board[row-1][col-1] == -1) |(board[row-1][col-1] == -1) | (board[row-1][col] == -1) | (board[row-1][col+1] == -1) | (board[row+1][col-1] == -1))) 
            { 
             board[row][col] = -1;
             board[row1][col1] = tile;
            } 
        } 
    } 
}",0
kluc619,1696226042,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{ 
    int row, col ,row1,col1; 
    FindTile(board, -1, &row1, &col1);
    for (row = 0; row < NUM_ROWS; row++) 
    { 
        for (col = 0; col < NUM_COLS; col++) 
        { 
            if ((board[row][col] == tile) & ((board[row+1][col] == -1) | (board[row][col+1] == -1)| (board[row+1][col+1] == -1) | (board[row-1][col-1] == -1) |(board[row-1][col-1] == -1) | (board[row-1][col] == -1) | (board[row-1][col+1] == -1) | (board[row+1][col-1] == -1))) 
            { 
             board[row][col] = -1;
             board[row1][col1] = tile;
            } 
        } 
    } 
}",0
kluc619,1696226248,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{ 
    int row, col ,row1,col1; 
    FindTile(board, -1, &row1, &col1);
    for (row = 0; row < NUM_ROWS; row++) 
    { 
        for (col = 0; col < NUM_COLS; col++) 
        { 
            if ((board[row][col] == tile) & ((board[row+1][col] == -1) | (board[row][col+1] == -1)| (board[row+1][col+1] == -1) | (board[row][col-1] == -1) |(board[row-1][col-1] == -1) | (board[row-1][col] == -1) | (board[row-1][col+1] == -1) | (board[row+1][col-1] == -1))) 
            { 
             board[row][col] = -1;
             board[row1][col1] = tile;
            } 
        } 
    } 
}",0
kluc619,1696226460,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{ 
    int row, col ,row1,col1; 
    FindTile(board, -1, &row1, &col1);
    for (row = 0; row < NUM_ROWS; row++) 
    { 
        for (col = 0; col < NUM_COLS; col++) 
        { 
            if ((board[row][col] == tile) & ((board[row][col] == -1) | (board[row+1][col] == -1) | (board[row][col+1] == -1)| (board[row+1][col+1] == -1) | (board[row][col-1] == -1) |(board[row-1][col-1] == -1) | (board[row-1][col] == -1) | (board[row-1][col+1] == -1) | (board[row+1][col-1] == -1))) 
            { 
             board[row][col] = -1;
             board[row1][col1] = tile;
            } 
        } 
    } 
}",0
kluc619,1696230024,5,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{ 
    int row, col ,row1,col1; 
    FindTile(board, -1, &row1, &col1);
    FindTile(board, -1, &row, &col);
    
          if ((board[row][col] == tile) & ((board[row][col] == -1) | (board[row+1][col] == -1) | (board[row][col+1] == -1)| (board[row+1][col+1] == -1) | (board[row][col-1] == -1) |(board[row-1][col-1] == -1) | (board[row-1][col] == -1) | (board[row-1][col+1] == -1) | (board[row+1][col-1] == -1))) 
            { 
             board[row][col] = -1;
             board[row1][col1] = tile;
            } 
}",0
kluc619,1696230119,6,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{ 
    int row, col ,row1,col1; 
    FindTile(board, -1, &row1, &col1);
    FindTile(board, tile, &row, &col);
    
          if ((board[row][col] == -1) | (board[row+1][col] == -1) | (board[row][col+1] == -1)| (board[row+1][col+1] == -1) | (board[row][col-1] == -1) |(board[row-1][col-1] == -1) | (board[row-1][col] == -1) | (board[row-1][col+1] == -1) | (board[row+1][col-1] == -1)) 
            { 
             board[row][col] = -1;
             board[row1][col1] = tile;
            } 
}",0
kmag441,1696213760,1,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    int R1;
    int C1;
    FindTile(board, -1, &R1, &C1);
    int R2;
    int C2;
    FindTile(board, tile, &R2, &C2);
    
    if(R1 == R2 && (C1 == C2 - 1 || C1 == C2 + 1)){
        board[R1][C1] = tile;
        board[R2][C2] = -1;
    }
    
    if(C1 == C2 && (R1 == R2 - 1 || R1 == R2 + 1)){
        board[R1][C1] = tile;
        board[R2][C2] = -1;
    }
}",1
kmal768,1695790537,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowt, colt, row1, col1, temp; // initialise variables

	FindTile(board, tile, &rowt, &colt); // find position of tile you want to move 
	FindTile(board, -1, &row1, &col1); // find empty position

	if (abs(rowt - row1) == 1) { // if theres a difference in rows
		if (abs(colt - col1) == 0) { // no difference in columns (can't do diagonals_
			temp = board[rowt][colt];
			// switch tile and empty position
			board[rowt][colt] = board[row1][colt];
			board[row1][colt] = temp;
		}
	}

	else if (abs(rowt - row1) == 0) { // if no difference in rows
		if (abs(colt - col1) == 1) { // but difference in columns
			temp = board[rowt][colt];
			//switch tile and empty positon
			board[rowt][colt] = board[rowt][col1];
			board[rowt][col1] = temp;
		}
	}

}",1
kmck133,1695630068,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
	int emptyTileRow, emptyTileCol, tileRow, tileCol;
	FindTile(board, -1, &emptyTileRow, &emptyTileCol);
	FindTile(board, tile, &tileRow, &tileCol);

	if (((tileRow - emptyTileRow == 1) || (tileRow - emptyTileRow == -1)) && (tileCol - emptyTileCol == 0)) {
		board[emptyTileRow][emptyTileCol] = tile;
		board[tileRow][tileCol] = -1;
	}
	else if (((tileCol - emptyTileCol == 1) || (tileCol - emptyTileCol == -1)) && (tileRow - emptyTileRow == 0)) {
		board[emptyTileRow][emptyTileCol] = tile;
		board[tileRow][tileCol] = -1;
	}
}",1
kmcv530,1695852314,1,"#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
int emptyRow, emptyCol, tileRow, tileCol;

    //find positions of both tiles
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);

    //check if tile is next to empty tile
    if ((emptyRow - tileRow == 1 && emptyCol == tileCol) ||
        (emptyRow - tileRow == -1 && emptyCol == tileCol) ||
        (emptyCol - tileCol == 1 && emptyRow == tileRow) ||
        (emptyCol - tileCol == -1 && emptyRow == tileRow)) {
        
        //swap tile and empty square
        int empty = board[emptyRow][emptyCol];
        board[emptyRow][emptyCol] = board[tileRow][tileCol];
        board[tileRow][tileCol] = empty;
		}
}",1
kng361,1696230799,1,"// Lab9ex8
// Author: Kai Ng
#include <stdio.h>

#define NUM_ROWS 3
#define NUM_COLS 3

void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos) {
    for (int row = 0; row < NUM_ROWS; row++) {
        for (int col = 0; col < NUM_COLS; col++) {
            if (board[row][col] == tile) {
                *rowPos = row;
                *colPos = col;
                return; 
            }
        }
    }
    *rowPos = -1;
    *colPos = -1;
}
",0
kng361,1696230845,2,"// Lab9ex8
// Author: Kai Ng
#include <stdio.h>

#define NUM_ROWS 3
#define NUM_COLS 3

void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos) {
    for (int row = 0; row < NUM_ROWS; row++) {
        for (int col = 0; col < NUM_COLS; col++) {
            if (board[row][col] == tile) {
                *rowPos = row;
                *colPos = col;
                return; 
            }
        }
    }
    *rowPos = -1;
    *colPos = -1;
}

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRow, tileCol;
    int emptyRow, emptyCol;

    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol);

    
    if ((abs(tileRow - emptyRow) == 1 && tileCol == emptyCol) ||
        (abs(tileCol - emptyCol) == 1 && tileRow == emptyRow)) {
        
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}",0
kpat303,1695609368,1,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRow, tileCol, emptyRow, emptyCol;

    // Find the positions of the specified tile and the empty square
    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol);

    // Check if the tile and empty square are adjacent (horizontally or vertically)
    if ((tileRow == emptyRow && (tileCol == emptyCol - 1 || tileCol == emptyCol + 1)) ||
        (tileCol == emptyCol && (tileRow == emptyRow - 1 || tileRow == emptyRow + 1))) {
        // Swap the tile and the empty square
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}",1
kpau893,1695719515,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int blank_row, blank_col;
	int tile_row, tile_col;

	FindTile(board, -1, &blank_row, &blank_col);
	FindTile(board, tile, &tile_row, &tile_col);

	if ((blank_row == tile_row && (blank_col == tile_col + 1 || blank_col == tile_col - 1)) 
	    || (blank_col == tile_col && (blank_row == tile_row + 1 || blank_row == tile_row - 1)))
	{
		board[blank_row][blank_col] = tile;
		board[tile_row][tile_col] = -1;

	}


}",1
kpay633,1695865499,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)  
{
	int chosenR, chosenC;
	int emptyR, emptyC;
	int temp;
	FindTile(board, tile, &chosenR, &chosenC);
	FindTile(board, -1, &emptyR, &emptyC);
	
	if (emptyR > 0) {   
		if (board[emptyR - 1][emptyC] == board[chosenR][chosenC]) {
			temp = board[chosenR][chosenC];
			board[chosenR][chosenC] = -1;
			board[emptyR][emptyC] = temp;
		}
	}
	
	if (emptyR < NUM_ROWS - 1) {
		if (board[emptyR + 1][emptyC] == board[chosenR][chosenC]) {
			temp = board[chosenR][chosenC];
			board[chosenR][chosenC] = -1;
			board[emptyR][emptyC] = temp;
		}
	}
	
	if (emptyC > 0) {
		if (board[emptyR][emptyC - 1] == board[chosenR][chosenC]) {
			temp = board[chosenR][chosenC];
			board[chosenR][chosenC] = -1;
			board[emptyR][emptyC] = temp;
		}
	}

	if (emptyC < NUM_COLS - 1) { 
		if (board[emptyR][emptyC + 1] == board[chosenR][chosenC]) {
			temp = board[chosenR][chosenC];
			board[chosenR][chosenC] = -1;
			board[emptyR][emptyC] = temp;
		}
	}
}",1
kpir468,1696240669,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {

    int emptyRow, emptyCol, tileRow, tileCol;

    int i, j;

 

    for (i = 0; i < NUM_ROWS; i++) {

        for (j = 0; j < NUM_COLS; j++) {

            if (board[i][j] == -1) {

                emptyRow = i;

                emptyCol = j;

            }

            if (board[i][j] == tile) {

                tileRow = i;

                tileCol = j;

            }

        }

    }

   

    if ((tileRow == emptyRow && (tileCol == emptyCol - 1 || tileCol == emptyCol + 1)) ||

        (tileCol == emptyCol && (tileRow == emptyRow - 1 || tileRow == emptyRow + 1))) {

        // Swap 

        int temp = board[emptyRow][emptyCol];

        board[emptyRow][emptyCol] = board[tileRow][tileCol];

        board[tileRow][tileCol] = temp;

    }

}",1
kpla566,1696215137,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
  int BlankRow, BlankCol;
  int TileRow, TileCol;
  int swap = 0;
  FindTile(board, -1, &BlankRow, &BlankCol);
  FindTile(board, tile, &TileRow, &TileCol);
  if (BlankRow == TileRow) {
    if (BlankCol == TileCol + 1 || BlankCol == TileCol - 1) {
      // swap them
      swap = 1;
    }
  }
  if (BlankCol == TileCol) {
    if (BlankRow == TileRow + 1 || BlankRow == TileRow - 1) {
      swap = 1;
    }
  }
  if (swap == 1) {
    board[TileRow][TileCol] = -1;
    board[BlankRow][BlankCol] = tile;
    
  }
}
",1
kqua446,1696179247,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;

	FindTile(board, tile, &row, &col);

	if (row != NUM_ROWS - 1 && board[row + 1][col] == -1) {
		board[row + 1][col] = tile;
		board[row][col] = -1;
	} else if (row != 0 && board[row - 1][col] == -1) {
		board[row - 1][col] = tile;
		board[row][col] = -1;
	} else if (col != NUM_COLS - 1 && board[row][col + 1] == -1) {
		board[row][col + 1] = tile;
		board[row][col] = -1;
	} else if (col != 0 && board[row][col - 1] == -1) {
		board[row][col - 1] = tile;
		board[row][col] = -1;
	}

}",1
kraj720,1696209261,1,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) 
{
    int row, col, rowEmpty, colEmpty;
    
    
    FindTile(board, tile, &row, &col);
    FindTile(board, -1, &rowEmpty, &colEmpty);
    
    
    int adjacent = (row - rowEmpty) + (col - colEmpty);
    
    if (adjacent == 1) 
    {
       board[rowEmpty][colEmpty] = tile;
       board[row][col] = -1;
    }
}
",0
kraj720,1696209640,2,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) 
{
    int rowNormal, colNormal, rowEmpty, colEmpty;
    
    FindTile(board, tile, &rowNormal, &colNormal);
    FindTile(board, -1, &rowEmpty, &colEmpty);
    
    int adjacent = abs(rowNormal - rowEmpty) + abs(colNormal - colEmpty);
    
    if (adjacent == 1) 
    {
       board[rowEmpty][colEmpty] = tile;
       board[rowNormal][colNormal] = -1;
    }
}
",1
kraw552,1695782574,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, emptyrow, emptycol;

	FindTile(board, tile, &row, &col);
	FindTile(board, -1, &emptyrow, &emptycol);
	if ((row > 0 && board[row - 1][col] == -1) || row < NUM_ROWS - 1 && board[row + 1][col] == -1)
	{
		board[row][col] = -1;
		board[emptyrow][emptycol] = tile;
	}

	if ((col > 0 && board[row][col - 1] == -1) || col < NUM_COLS - 1 && board[row][col + 1] == -1)
	{
		board[row][col] = -1;
		board[emptyrow][emptycol] = tile;
	}

}",0
kraw552,1695783278,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, emptyrow, emptycol;

	FindTile(board, tile, &row, &col);
	FindTile(board, -1, &emptyrow, &emptycol);
	if (((row > 0) && (board[row - 1][col] == -1)) || ((row < NUM_ROWS - 1) && (board[row + 1][col] == -1)))
	{
		board[row][col] = -1;
		board[emptyrow][emptycol] = tile;
	}

	if (((col > 0) && (board[row][col - 1] == -1)) || ((col < NUM_COLS - 1) && (board[row][col + 1] == -1)))
	{
		board[row][col] = -1;
		board[emptyrow][emptycol] = tile;
	}

}",1
krec980,1695792393,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row;
	int col;
	FindTile(board, tile, &row, &col);

	if (row > 0) {
		if (board[row - 1][col] == -1) {
			board[row - 1][col] = board[row][col];
			board[row][col] = -1;
		}
	}

	if (col > 0) {
		if (board[row][col - 1] == -1) {
			board[row][col - 1] = board[row][col];
			board[row][col] = -1;
		}
	}

	if (row < 3) {
		if (board[row + 1][col] == -1) {
			board[row + 1][col] = board[row][col];
			board[row][col] = -1;
		}
	}

	if (col < 3) {
		if (board[row][col + 1] == -1) {
			board[row][col + 1] = board[row][col];
			board[row][col] = -1;
		}
	}
}",1
ksai757,1695690128,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tileRow, tileCol;
	int emptyRow, emptyCol;

	// Find the positions of the specified tile and the empty square
	FindTile((int*)board, tile, &tileRow, &tileCol);
	FindTile((int*)board, -1, &emptyRow, &emptyCol);

	// Check if the specified tile is adjacent to the empty square
	if ((tileRow == emptyRow && (tileCol == emptyCol - 1 || tileCol == emptyCol + 1)) ||
		(tileCol == emptyCol && (tileRow == emptyRow - 1 || tileRow == emptyRow + 1))) {
		// Swap the specified tile with the empty square
		int temp = board[tileRow][tileCol];
		board[tileRow][tileCol] = board[emptyRow][emptyCol];
		board[emptyRow][emptyCol] = temp;
	}
}",0
ksai757,1696125034,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
	int emptyRow, emptyCol;
	int tileRow, tileCol;

	// Find the positions of the specified tile and the empty square
	FindTile(board, -1, &emptyRow, &emptyCol);
	FindTile(board, tile, &tileRow, &tileCol);

	// Check if the specified tile is adjacent to the empty square
	if ((tileRow == emptyRow && (tileCol == emptyCol - 1 || tileCol == emptyCol + 1)) ||
		(tileCol == emptyCol && (tileRow == emptyRow - 1 || tileRow == emptyRow + 1))) {
		// Swap the specified tile with the empty square
		int temp = board[tileRow][tileCol];
		board[tileRow][tileCol] = board[emptyRow][emptyCol];
		board[emptyRow][emptyCol] = temp;
	}
}",1
ksik996,1695628026,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowl, coll;
    int rowt, colt;

    FindTile(board, -1, &rowl, &coll);
    FindTile(board, tile, &rowt, &colt);
    if((rowt - rowl == 1 || rowt - rowl == -1) ^ (colt - coll == -1 || colt - coll == 1)){
            board[rowt][colt] = -1;
            board[rowl][coll] = tile;
    }


}",0
ksik996,1695628628,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowl, coll;
    int rowt, colt;

    FindTile(board, -1, &rowl, &coll);
    FindTile(board, tile, &rowt, &colt);
    if((rowt - rowl <= 1 || rowt - rowl <= -1) && (colt - coll <= -1 || colt - coll <= 1)){
        if((rowt - rowl == 1 || rowt - rowl == -1) ^ (colt - coll == -1 || colt - coll == 1)){
            board[rowt][colt] = -1;
            board[rowl][coll] = tile;
    }
    }


}",0
ksik996,1695628924,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowl, coll;
    int rowt, colt;

    FindTile(board, -1, &rowl, &coll);
    FindTile(board, tile, &rowt, &colt);
    if((rowt - rowl == 1 || rowt - rowl == -1 || rowt - rowl == 0) && (colt - coll == -1 || colt - coll == 1 || colt - coll == 0)){
        if((rowt - rowl == 1 || rowt - rowl == -1) ^ (colt - coll == -1 || colt - coll == 1)){
            board[rowt][colt] = -1;
            board[rowl][coll] = tile;
    }
    }


}",1
kwan244,1695960000,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int Num_Move)
{
	int row, col, emptRow, emptCol, temp;

	FindTile(board, Num_Move, &row, &col);
	FindTile(board, -1, &emptRow, &emptCol);

	//Move left
	if (col > 0)
	{
		if (emptCol == col - 1 && emptRow == row)
		{
		temp = board[row][col];
		board[row][col] = board[emptRow][emptCol];
		board[emptRow][emptCol] = temp;
		}
	}

	//Move right
	if (col < 3)
	{
		if (emptCol == col + 1 && emptRow == row)
		{
			temp = board[row][col];
			board[row][col] = board[emptRow][emptCol];
			board[emptRow][emptCol] = temp;
		}
	}

	//Move up
	if (row > 0)
	{
		if (emptRow == row - 1 && emptCol == col)
		{
			temp = board[row][col];
			board[row][col] = board[emptRow][emptCol];
			board[emptRow][emptCol] = temp;
		}
	}

	//Move down
	if (row < 3)
	{
		if (emptRow == row + 1 && emptCol == col)
		{
			temp = board[row][col];
			board[row][col] = board[emptRow][emptCol];
			board[emptRow][emptCol] = temp;
		}
	}

}",1
kwan797,1695694640,1,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{    
    int rowPos;
    int colPos;
    int rowEmpty;
    int colEmpty;
    
    for(int i=0; i<NUM_ROWS; i++){
        for(int j=0; j<NUM_COLS; j++){
            if(board[i][j]==tile){
                rowPos = i;
                colPos = j;
            }
            
            if(board[i][j]==-1){
                rowEmpty = i;
                colEmpty = j;
            }
            
            if((rowPos == rowEmpty && (colPos == colEmpty-1 || colPos == colEmpty+1))|| (colPos == colEmpty && (rowPos == rowEmpty-1 || rowPos == rowEmpty+1))){
                board[rowEmpty][colEmpty] = tile;
                board[rowPos][colPos] = -1;
            }
            
        }
    }
    
}",0
kwan797,1695697209,2,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowPos;
    int colPos;
    int rowEmpty;
    int colEmpty;

    FindTile(board, tile, &rowPos, &colPos);
    FindTile(board, -1, &rowEmpty, &colEmpty);


    if ((rowPos == rowEmpty && (colPos == colEmpty - 1 || colPos == colEmpty + 1)) || (colPos == colEmpty && (rowPos == rowEmpty - 1 || rowPos == rowEmpty + 1))) {
        board[rowEmpty][colEmpty] = tile;
        board[rowPos][colPos] = -1;
    }

}",1
kyoo839,1695961414,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowspace, colspace;
    FindTile(board, -1, &rowspace, &colspace);

    int rowtile, coltile;
    FindTile(board, tile, &rowtile, &coltile);

    int temp = board[rowtile][coltile];

    if ((board[rowspace][colspace] == board[0][0])) {
        if ((board[rowtile][coltile] == board[1][0]) || (board[rowtile][coltile] == board[0][1])) {
            board[rowtile][coltile] = board[rowspace][colspace];
            board[rowspace][colspace] = temp;
        }
    }
    if ((board[rowspace][colspace] == board[0][3])) {
        if ((board[rowtile][coltile] == board[0][2]) || (board[rowtile][coltile] == board[1][3])) {
            board[rowtile][coltile] = board[rowspace][colspace];
            board[rowspace][colspace] = temp;
        }
    }
    if ((board[rowspace][colspace] == board[3][0])) {
        if ((board[rowtile][coltile] == board[2][0]) || (board[rowtile][coltile] == board[3][1])) {
            board[rowtile][coltile] = board[rowspace][colspace];
            board[rowspace][colspace] = temp;
        }
    }
    if ((board[rowspace][colspace] == board[3][3])) {
        if ((board[rowtile][coltile] == board[3][2]) || (board[rowtile][coltile] == board[2][3])) {
            board[rowtile][coltile] = board[rowspace][colspace];
            board[rowspace][colspace] = temp;
        }
    }
    if ((board[rowspace][colspace] == board[1][0]) || (board[rowspace][colspace] == board[2][0])) {
        if ((board[rowtile][coltile] == board[rowspace + 1][colspace]) || (board[rowtile][coltile] == board[rowspace - 1][colspace]) || (board[rowtile][coltile] == board[rowspace][colspace + 1])) {
            board[rowtile][coltile] = board[rowspace][colspace];
            board[rowspace][colspace] = temp;
        }
    }
    if ((board[rowspace][colspace] == board[1][3]) || (board[rowspace][colspace] == board[2][3])) {
        if ((board[rowtile][coltile] == board[rowspace + 1][colspace]) || (board[rowtile][coltile] == board[rowspace - 1][colspace]) || (board[rowtile][coltile] == board[rowspace][colspace - 1])) {
            board[rowtile][coltile] = board[rowspace][colspace];
            board[rowspace][colspace] = temp;
        }
    }
    if ((board[rowspace][colspace] == board[0][1]) || (board[rowspace][colspace] == board[0][2])) {
        if ((board[rowtile][coltile] == board[rowspace + 1][colspace]) || (board[rowtile][coltile] == board[rowspace][colspace - 1]) || (board[rowtile][coltile] == board[rowspace][colspace + 1])) {
            board[rowtile][coltile] = board[rowspace][colspace];
            board[rowspace][colspace] = temp;
        }
    }
     if ((board[rowspace][colspace] == board[3][1]) || (board[rowspace][colspace] == board[3][2])) {
        if ((board[rowtile][coltile] == board[rowspace - 1][colspace]) || (board[rowtile][coltile] == board[rowspace][colspace - 1]) || (board[rowtile][coltile] == board[rowspace][colspace + 1])) {
            board[rowtile][coltile] = board[rowspace][colspace];
            board[rowspace][colspace] = temp;
        }
    }
    if ((board[rowspace][colspace] == board[1][1]) || (board[rowspace][colspace] == board[1][2]) || (board[rowspace][colspace] == board[2][1] || (board[rowspace][colspace] == board[2][2]))) {
        if ((board[rowtile][coltile] == board[rowspace - 1][colspace]) || (board[rowtile][coltile] == board[rowspace + 1][colspace]) || (board[rowtile][coltile] == board[rowspace][colspace + 1]) || (board[rowtile][coltile] == board[rowspace][colspace - 1])) {
            board[rowtile][coltile] = board[rowspace][colspace];
            board[rowspace][colspace] = temp;
        }
    }
}",1
kzha391,1696234697,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) 
{
    int emptyRow, emptyCol, tileRow, tileCol;
    
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);
    
    if ((tileRow == emptyRow && (tileCol == emptyCol - 1 || tileCol == emptyCol + 1)) ||
        (tileCol == emptyCol && (tileRow == emptyRow - 1 || tileRow == emptyRow + 1))) {
        
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
} ",1
kzhu796,1695716806,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;
	FindTile(board, tile, &row, &col); //finding tile to be moved
	
	// create conditions that assess whether the move is valid or not:
	//checking above:
	if (row > 0 && board[row-1][col]==-1) {
		board[row - 1][col] = tile;
		board[row][col] = -1;
		return;
	}

	//checking below:
	if (row < NUM_ROWS-1 && board[row + 1][col] == -1) {
		board[row + 1][col] = tile;
		board[row][col] = -1;
		return;
	}

	//checking left:
	if (col > 0 && board[row][col-1]==-1) {
		board[row][col-1] = tile;
		board[row][col] = -1;
		return;
	}

	//checking right:
	if (col < NUM_COLS-1 && board[row][col+1]==-1) {
		board[row][col+1] = tile;
		board[row][col] = -1;
		return;
	}
}",1
laba812,1696163184,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowPos1 , rowPos2;
    int colPos1 , colPos2;
    
 FindTile( board, tile, &rowPos1, &colPos1);
 FindTile( board, -1 , &rowPos2, &colPos2);
 
    if (!((rowPos1==rowPos2) && (colPos1-1 == colPos2 || colPos2+1 == colPos2) || (colPos1==colPos2) && (rowPos1+1==rowPos2 || rowPos1-1==rowPos2))){
    return;
    }

board[rowPos1][colPos1] = -1;
board[rowPos2][colPos2] = tile;
}",0
laba812,1696163639,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowPos1 , rowPos2;
    int colPos1 , colPos2;
    
 FindTile( board, tile, &rowPos1, &colPos1);
 FindTile( board, -1 , &rowPos2, &colPos2);
 
    if (!((rowPos1==rowPos2) && (colPos1-1 == colPos2 || colPos2+1 == colPos2)) || ((colPos1==colPos2) && (rowPos1+1==rowPos2 || rowPos1-1==rowPos2))){
    return;
    }

board[rowPos1][colPos1] = -1;
board[rowPos2][colPos2] = tile;
}",0
laba812,1696164011,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowPos1 , rowPos2;
    int colPos1 , colPos2;
    
 FindTile( board, tile, &rowPos1, &colPos1);
 FindTile( board, -1 , &rowPos2, &colPos2);
 
    if (!((rowPos1==rowPos2) && (colPos2-1 == colPos1 || colPos2+1 == colPos1) || (colPos1==colPos2) && (rowPos2+1==rowPos1 || rowPos2-1==rowPos1))){
    return;
    }

board[rowPos1][colPos1] = -1;
board[rowPos2][colPos2] = tile;
}",0
laba812,1696164146,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowPos1 , rowPos2;
    int colPos1 , colPos2;
    
 FindTile( board, tile, &rowPos1, &colPos1);
 FindTile( board, -1 , &rowPos2, &colPos2);
 
    if (!( ((rowPos1==rowPos2) && (colPos2-1 == colPos1 || colPos2+1 == colPos1)) || ((colPos1==colPos2) && (rowPos2+1==rowPos1 || rowPos2-1==rowPos1)) )){
    return;
    }

board[rowPos1][colPos1] = -1;
board[rowPos2][colPos2] = tile;
}",1
lazz729,1695959121,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col, emptyRow, emptyCol;
    int swappable = 0;
    FindTile(board, tile, &row, &col);
    FindTile(board, -1, &emptyRow, &emptyCol);
    printf(""%d %d %d %d\n"", row, col, emptyRow, emptyCol);
    if (row == emptyRow) {
        if (col == emptyCol + 1 || col == emptyCol - 1) {
            swappable = 1;
        }
    } else if (col == emptyCol) {
        if (row == (emptyRow + 1) || row == (emptyRow - 1))  {
            swappable = 1;
        }
    }
    printf(""%d \n"",swappable);
    if (swappable == 1) {
        board[emptyRow][emptyCol] = board[row][col];
        board[row][col] = -1;
    }
}",0
lazz729,1695959210,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col, emptyRow, emptyCol;
    int swappable = 0;
    FindTile(board, tile, &row, &col);
    FindTile(board, -1, &emptyRow, &emptyCol);
    if (row == emptyRow) {
        if (col == emptyCol + 1 || col == emptyCol - 1) {
            swappable = 1;
        }
    } else if (col == emptyCol) {
        if (row == (emptyRow + 1) || row == (emptyRow - 1))  {
            swappable = 1;
        }
    }
    if (swappable == 1) {
        board[emptyRow][emptyCol] = board[row][col];
        board[row][col] = -1;
    }
}",1
lbla772,1696242483,1,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    
    int tilePos = FindTile(board, tile);
    
    if (tilePos == -1) {
       
        return;
    }

    int emptyPos = FindTile(board, -1);

    if (emptyPos == -1) {
        
        return;
    }

    int tileRow = tilePos / NUM_COLS;
    int tileCol = tilePos % NUM_COLS;
    int emptyRow = emptyPos / NUM_COLS;
    int emptyCol = emptyPos % NUM_COLS;

    if ((abs(tileRow - emptyRow) == 1 && tileCol == emptyCol) ||
        (abs(tileCol - emptyCol) == 1 && tileRow == emptyRow)) {

        Swap(board, tilePos, emptyPos);
    }
}",0
lbla772,1696243579,2,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col;
    FindTile(board, tile, &row, &col );
   
    if (row != 0){
        
        if( board[row - 1][col] == -1)
        {
            board[row - 1][col] = board[row][col];
            board[row][col]= -1;
            
        }
        
    }

    if (col != 0)
    {
        
        if (board[row][ncol - 1] == -1)  
        {
            board[row][col - 1]= board[row][col];
            board[row][col]= -1;
        }
        
    }

    if (row != (NUM_ROWS-1))
    {
        
        if( board[row + 1][col] == -1)
        {
            board[row + 1][col] = board[row][col];
            board[row][col]= -1;
        }
        
    }

    if (col != (NUM_COLS-1))
    {
        
        if( board[row][col + 1] == -1)
        {
            board[row][col +1] = board[row][col];
            board[row][col]= -1;
        }
        
    }
    
}",0
lbla772,1696244169,3,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col;
    FindTile(board, tile, &row, &col );
   
    if (row != 0){
        
        if( board[row - 1][col] == -1)
        {
            board[row - 1][col] = board[row][col];
            board[row][col]= -1;
            
        }
        
    }

    if (col != 0)
    {
        
        if (board[row][col - 1] == -1)  
        {
            board[row][col - 1]= board[row][col];
            board[row][col]= -1;
        }
        
    }

    if (row != (NUM_ROWS-1))
    {
        
        if( board[row + 1][col] == -1)
        {
            board[row + 1][col] = board[row][col];
            board[row][col]= -1;
        }
        
    }

    if (col != (NUM_COLS-1))
    {
        
        if( board[row][col + 1] == -1)
        {
            board[row][col +1] = board[row][col];
            board[row][col]= -1;
        }
        
    }
    
}",1
lbou433,1695702707,1,"void MakeMove(int board[4][4], int tile)
{
	int row, col;
	FindTile(board, tile, &row, &col);
	
	if (row - 1 >= 0) {
		if (board[row - 1][col] == -1) {
			board[row][col] = -1;
			board[row - 1][col] = tile;
		}

	}
	if (row + 1 <= 3) {
		if (board[row + 1][col] == -1) {
			board[row][col] = -1;
			board[row + 1][col] = tile;
		}
	}
	if (col - 1 >= 0) {
		if (board[row][col-1] == -1) {
			board[row][col] = -1;
			board[row][col-1] = tile;
		}
	}
	if (col + 1 <= 3) {
		if (board[row][col+1] == -1) {
			board[row][col] = -1;
			board[row][col+1] = tile;
		}
	}
}",1
lbyr117,1696216744,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row;
    int col;
    FindTile(board, tile, &row, &col);
    int tilerow = row;
    int tilecol = col;
    FindTile(board, -1, &row, &col);
    int emptyrow = row;
    int emptycol = col;
    if((((tilerow+1==emptyrow)||(tilerow-1==emptyrow))&&(emptycol==tilecol))||(((tilecol+1==emptycol)||(tilecol-1==emptycol))&&(emptyrow==tilerow)))
    {
        board[tilerow][tilecol]=-1;
        board[emptyrow][emptycol]=tile;
    }
}",1
lcam453,1696225332,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int rowPos, colPos;
    FindTile(board, tile, &rowPos, &colPos);
    if (rowPos > 0 && board[rowPos - 1][colPos] == -1) {
        board[rowPos - 1][colPos] = tile;
        board[rowPos][colPos] = -1;
    } else if (rowPos < NUM_ROWS - 1 && board[rowPos + 1][colPos] == -1) {
        board[rowPos + 1][colPos] = tile;
        board[rowPos][colPos] = -1;
    } else if (colPos > 0 && board[rowPos][colPos - 1] == -1) {
        board[rowPos][colPos - 1] = tile;
        board[rowPos][colPos] = -1;
    } else if (colPos < NUM_COLS - 1 && board[rowPos][colPos + 1] == -1) {
        board[rowPos][colPos + 1] = tile;
        board[rowPos][colPos] = -1;
    }
}",1
lcan243,1695854374,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int rowed;
    int coled;
    int row;
    int col;
	FindTile(board, tile, &rowed, &coled);
	FindTile(board, -1, &row, &col);
	if (row == rowed + 1 || row == rowed - 1 || col == col + 1 || col == col - 1) {
		board[row][col] = board[rowed][coled];
		board[rowed][coled] = -1;
	}
	

}",0
lcan243,1695854701,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int rowed;
    int coled;
    int row;
    int col;
	FindTile(board, tile, &rowed, &coled);
	FindTile(board, -1, &row, &col);
	if (row == rowed + 1 || row == rowed - 1 || col == coled + 1 || col == coled - 1) {
		board[row][col] = board[rowed][coled];
		board[rowed][coled] = -1;
	}
	

}
",0
lcan243,1695854963,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int rowed;
    int coled;
    int row;
    int col;
	FindTile(board, tile, &rowed, &coled);
	FindTile(board, -1, &row, &col);
	if (((row == rowed + 1) && (col == coled))|| ((row == rowed - 1) && (col == coled))|| ((col == coled + 1) && (row == rowed)) || ((col == coled - 1) && (row == rowed))) {
		board[row][col] = board[rowed][coled];
		board[rowed][coled] = -1;
	}
	

}",1
lche668,1696157744,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int r, c;
    FindTile(board, -1, &r, &c);
    int r2, c2;
	FindTile(board, tile, &r2, &c2);
	if ((c == c2 && (r == r2 - 1 || r == r2 + 1)) || (r == r2 && (c == c2 - 1 || c == c + 1))) {
	    board[r][c] = tile;
	    board[r2][c2] = -1;
	} else {
	    return;
	}
}",0
lche668,1696157887,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int r, c;
    FindTile(board, -1, &r, &c);
    int r2, c2;
	FindTile(board, tile, &r2, &c2);
	if ((c == c2 && (r == r2 - 1 || r == r2 + 1)) || (r == r2 && (c == c2 - 1 || c == c2 + 1))) {
	    board[r][c] = tile;
	    board[r2][c2] = -1;
	} else {
	    return;
	}
}",1
lchu848,1696236467,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile);
{
    int er, ec, mr, mc;
    
    FindTile(board, -1, &er, &ec);
    FindTile(board, -1, &mr, &mc);
    
    if ((mr == er) && (mc == ec - 1) || (mc == ec + 1)) || ((mc == ec) && (er == mr - 1) || (er == mr + 1)) {
        board[er][ec] = tile;
        board[mr][mc] = -1;
    }
    
}",0
lchu848,1696236735,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile);
{
    int er, ec, mr, mc;
   
    //finds empty block place
    FindTile(board, -1, &er, &ec);
   
    //finds tile position
    FindTile(board, tile, &mr, &mc);
   
    //checks if tile is next to empty block
     if ((abs(mr - er) == 1 && mc == ec) || (abs(tc - ec) == 1 && tr == er)) {
        board[er][ec] = tile;
        board[mr][mc] = -1;
    }
    
}",0
lchu848,1696236811,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int er, ec, mr, mc;
   
    //finds empty block place
    FindTile(board, -1, &er, &ec);
   
    //finds tile position
    FindTile(board, tile, &mr, &mc);
   
    //checks if tile is next to empty block
     if ((abs(mr - er) == 1 && mc == ec) || (abs(tc - ec) == 1 && tr == er)) {
        board[er][ec] = tile;
        board[mr][mc] = -1;
    }
    
}",0
lchu848,1696236858,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int er, ec, mr, mc;
   
    //finds empty block place
    FindTile(board, -1, &er, &ec);
   
    //finds tile position
    FindTile(board, tile, &mr, &mc);
   
    //checks if tile is next to empty block
     if ((abs(mr - er) == 1 && mc == ec) || (abs(mc - ec) == 1 && mr == er)) {
        board[er][ec] = tile;
        board[mr][mc] = -1;
    }
    
}",1
ldam917,1696226256,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row;
    int col;
    FindTile(board,tile,row,col);
    int neg1row;
    int neg1col;
    FindTile(board,-1,neg1row,neg1col);
    if ((row+1==neg1row)||(row-1==neg1row)||(col+1==neg1col)||(col-1==neg1col))
    {
        board[neg1row][neg1col]=tile;
        board[row][col]=-1;
    }
}",0
ldam917,1696227058,2,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int *row;
    int *col;
    FindTile(board,tile,row,col);
    int *neg1row;
    int *neg1col;
    FindTile(board,-1,neg1row,neg1col);
    if ((row++==neg1row&&col==neg1col)||(row--==neg1row&&col==neg1col)
    ||(row==neg1row&&col++==neg1col)||(row==neg1row&&col--==neg1col))
    {
        int neg1row;
        int neg1col;
        int row;
        int col;
        board[neg1row][neg1col]=tile;
        board[row][col]=-1;
    }
}
",0
ldam917,1696239607,3,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int neg1row;
    int neg1col;
    int row;
    int col;
    FindTile(board,tile,&row,&col);
    FindTile(board,-1,&neg1row,&neg1col);
    if ((row+1==neg1row)||(row-1==neg1row)
    ||(col+1==neg1col)||(col-1==neg1col))
    {
        board[neg1row][neg1col]=tile;
        board[row][col]=-1;
    }
}
",0
ldam917,1696240062,4,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int neg1row;
    int neg1col;
    int row;
    int col;
    FindTile(board,tile,&row,&col);
    FindTile(board,-1,&neg1row,&neg1col);
    if ((row+1==neg1row&&col==neg1col)||(row-1==neg1row&&col==neg1col)||(row==neg1row&&col+1==neg1col)||(row==neg1row&&col-1==neg1col))
    {
        board[neg1row][neg1col]=tile;
        board[row][col]=-1;
    }
}",1
ldea753,1695852089,1,"void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos)
{
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == tile) {
                *rowPos = i;
                *colPos = j;
            }
        }
    }
}",0
ldea753,1695876390,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rows, cols, rowEmp, colEmp;
    FindTile(board, tile, &rows, &cols);
    FindTile(board, -1, &rowEmp, &colEmp);

    if ((rows == rowEmp + 1) && (cols == colEmp) && rowEmp != 3) {
        board[rows][cols] = -1;
        board[rowEmp][colEmp] = tile;
    }

    if ((rows == rowEmp - 1) && (cols == colEmp) && rowEmp != 0) {
        board[rows][cols] = -1;
        board[rowEmp][colEmp] = tile;
    }

    if ((cols == colEmp + 1) && (rows == rowEmp) && colEmp != 3) {
        board[rows][cols] = -1;
        board[rowEmp][colEmp] = tile;
    }

    if ((cols == colEmp - 1) && (rows == rowEmp) && colEmp != 0) {
        board[rows][cols] = -1;
        board[rowEmp][colEmp] = tile;
    }
}",1
ldou101,1695954001,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int ra,rb,ca,cb;
FindTile(board, -1, &ra, &ca);
FindTile(board, tile, &rb, &cb);

if ((ra==rb && ca==cb+1)||(ra==rb && ca==cb-1)||(ra==rb+1 && ca==cb)||(ra==rb-1 && ca==cb))
{
    board[ra][ca] = tile;
        board[rb][cb] = -1;
}
}",1
ldou101,1695956210,2,"void PelletRoute(int warehouse[10][10]) {
    int r1 = -1, r2 = -1, c1 = -1, c2 = -1;

    for (int r = 0; r < 10; r++) {
        for (int c = 0; c < 10; c++) {
            if (warehouse[r][c] == 1) {
                r1 = r;
                c1 = c;
            }
            if (warehouse[r][c] == 2) {
                r2 = r;
                c2 = c;
            }
        }
    }

    for (int r = 0; r < 10; r++) {
        for (int c = 0; c < 10; c++) {
            if ((r==r1&&c==c1)||(r==r2&&c==c2)){
            c=c+1;}
            if (r==r1&&((c>c1&&c<=c2)||(c<c1&&c>=c2))){
                warehouse[r][c] = 3;}
            if (c==c2&&((r>r2&&r<=r1)||(r<r2&&r>=r1))){
                warehouse[r][c] = 3;}
        }
    }
}",0
lfan827,1696228608,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int i, j, m, k;
    for ( i = 0; i < NUM_ROWS; i++){
        for ( j = 0;j < NUM_COLS; j++){
            if (board[i][j] == tile){
                for (m = i-1; m < i+2; m =m + 2){
                    for (k = j-1; k < j+2; k = k + 2){

                        if (board[m][j] == -1 ){
                            if (i == 0 && m == -1){
                                return;
                            }
                            else if (i == 3 && m == 4){
                                return;
                            }
                            else {
                                board[i][j] = -1;
                                board[m][j] = tile;
                                return;
                            }
                        }
                        if (board[i][k] == -1){
                            if (j == 0 && k == -1){
                                return;
                            }
                            else if (j == 3 && k == 4){
                                return;
                            }
                            else {
                                board[i][j] = -1;
                                board[i][k] = tile;
                                return;
                            }
                        }

                    } 
                }
            }
        }
    }
}",1
lgan833,1696217944,1,"#include <stdio.h>
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j;
	int* rowPos;
	int* colPos;
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == -1) {
				*rowPos = i;
				*colPos = j;
			}
		}
	}
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[*rowPos + 1][*colPos] == tile) {
				board[*rowPos][*colPos] = tile;
				board[*rowPos + 1][*colPos] = -1;
			}
			if (board[*rowPos - 1][*colPos] == tile) {
				board[*rowPos][*colPos] = tile;
				board[*rowPos - 1][*colPos] = -1;
			}
			if (board[*rowPos][*colPos + 1] == tile) {
				board[*rowPos][*colPos] = tile;
				board[*rowPos][*colPos + 1] = -1;
			}
			if (board[*rowPos][*colPos - 1] == tile) {
				board[*rowPos][*colPos] = tile;
				board[*rowPos][*colPos - 1] = -1;
			}
			if (board[i][j] > -1) {
				printf(""%d"", board[i][j]);
			}
			if (board[i][j] == -1) {
				printf(""_"");
			}
		}
	}
}",0
lgan833,1696218183,2,"#include <stdio.h>
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j;
	int rowPos;
	int colPos;
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == -1) {
				rowPos = i;
				colPos = j;
			}
		}
	}
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[rowPos + 1][colPos] == tile) {
				board[rowPos][colPos] = tile;
				board[rowPos + 1][colPos] = -1;
			}
			if (board[rowPos - 1][colPos] == tile) {
				board[rowPos][colPos] = tile;
				board[rowPos - 1][colPos] = -1;
			}
			if (board[rowPos][colPos + 1] == tile) {
				board[rowPos][colPos] = tile;
				board[rowPos][colPos + 1] = -1;
			}
			if (board[rowPos][colPos - 1] == tile) {
				board[rowPos][colPos] = tile;
				board[rowPos][colPos - 1] = -1;
			}
			if (board[i][j] > -1) {
				printf(""%d"", board[i][j]);
			}
			if (board[i][j] == -1) {
				printf(""_"");
			}
		}
	}
}",0
lgan833,1696224337,3,"#include <stdio.h>
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j;
	int rowPos;
	int colPos;
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == -1) {
				rowPos = i;
				colPos = j;
				break;
			}
		}
	}
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (rowPos + 1 < NUM_ROWS && board[rowPos + 1][colPos] == tile) {
				board[rowPos][colPos] = tile;
				board[rowPos + 1][colPos] = -1;
			}
			if (rowPos > 0 && board[rowPos - 1][colPos] == tile) {
				board[rowPos][colPos] = tile;
				board[rowPos - 1][colPos] = -1;
			}

			if (colPos + 1 < NUM_COLS && board[rowPos][colPos + 1] == tile) {
				board[rowPos][colPos] = tile;
				board[rowPos][colPos + 1] = -1;
			}
			if (colPos > 0 && board[rowPos][colPos - 1] == tile) {
				board[rowPos][colPos] = tile;
				board[rowPos][colPos - 1] = -1;
			}
		}
	}
}",1
lhal844,1695940023,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;
	int rowspace, colspace;

	FindTile(*board, tile, &row, &col);
	FindTile(*board, -1, &rowspace, &colspace);

	if (row == rowspace && (((col - colspace) == 1) || ((col - colspace) == -1)))
	{
		board[rowspace][colspace] = board[row][col];
		board[row][col] = -1;
	}
	if (col == colspace && (((row - rowspace) == 1) || ((row - rowspace) == -1)))
	{
		board[rowspace][colspace] = board[row][col];
		board[row][col] = -1;
	}

}",0
lhal844,1695940266,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;
	int rowspace, colspace;

	FindTile(board, tile, &row, &col);
	FindTile(board, -1, &rowspace, &colspace);

	if (row == rowspace && (((col - colspace) == 1) || ((col - colspace) == -1)))
	{
		board[rowspace][colspace] = board[row][col];
		board[row][col] = -1;
	}
	if (col == colspace && (((row - rowspace) == 1) || ((row - rowspace) == -1)))
	{
		board[rowspace][colspace] = board[row][col];
		board[row][col] = -1;
	}

}",1
lhua313,1696157459,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{

int emptyRow, emptyCol, tileRow, tileCol;

FindTile(board, -1, &emptyRow, &emptyCol);
FindTile(board, tile, &tileRow, &tileCol);

if ((emptyRow - tileRow) == 1 && emptyCol == tileCol) || ) ((emptyCol - tileCol) == 1 && emptyRow == tileRow)) 
    {
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}
",0
lhua313,1696157490,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{

int emptyRow, emptyCol, tileRow, tileCol;

FindTile(board, -1, &emptyRow, &emptyCol);
FindTile(board, tile, &tileRow, &tileCol);

if ((emptyRow - tileRow) == 1 && emptyCol == tileCol) || ((emptyCol - tileCol) == 1 && emptyRow == tileRow) 
    {
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}
",0
lhua313,1696157518,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol, tileRow, tileCol;

    // Find the positions of the empty square and the specified tile.
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);

    // Check if the specified tile is adjacent to the empty square.
    if ((abs(emptyRow - tileRow) == 1 && emptyCol == tileCol) ||
        (abs(emptyCol - tileCol) == 1 && emptyRow == tileRow)) {
        // Swap the empty square and the specified tile.
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}",1
lhua313,1696157569,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) 
{
    int emptyRow, emptyCol, tileRow, tileCol;

    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);

    if ((emptyRow - tileRow) == 1 && emptyCol == tileCol) || ((emptyCol - tileCol) == 1 && emptyRow == tileRow)) 
    {
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}",0
lhua313,1696157641,5,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) 
{
    int emptyRow, emptyCol, tileRow, tileCol;

    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);

    if ((abs(emptyRow - tileRow) == 1 && emptyCol == tileCol) || (abs(emptyCol - tileCol) == 1 && emptyRow == tileRow)) 
    {
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}",1
ljer106,1696118616,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row1, col1, row, col, temp, temp1;
    
    FindTile(board, -1, &row, &col);
    FindTile(board, tile, &row1, &col1);
     
    if (row == row1 + 1 || row == row - 1 || row == row1) {
        if (col == col1 + 1 || col == col1 - 1 || col == col1) {
            temp = board[row][col];
            temp1 = board[row1][col1];
            board[row1][col1] = temp;
            board[row][col] = temp1; 
            
        }
    }
            
}",0
ljer106,1696119364,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row1, col1, row, col, temp, temp1;
    
    FindTile(board, -1, &row, &col);
    FindTile(board, tile, &row1, &col1);
     
    if (row == row1 + 1 || row == row1 - 1 || row == row1) {
        if (col == col1 + 1 || col == col1 - 1 || col == col1) {
            temp = board[row][col];
            temp1 = board[row1][col1];
            board[row1][col1] = temp;
            board[row][col] = temp1; 
            
        }
    }
}",1
ljon623,1696045918,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int emptyRow;
	int emptyCol;
	FindTile(board, -1, &emptyRow, &emptyCol);
	
	
	int tileRow;
	int tileCol;
	FindTile(board, tile, &tileRow, &tileCol);
	
	// Checking the tiles are adjacent
	if (tileRow + 1 == emptyRow && tileCol == emptyCol){
		
		board[emptyRow][emptyCol] = tile;
		board[tileRow][tileCol] = -1;
	}
	else if (tileRow + 1 == emptyRow && tileCol == emptyCol){
	
		board[emptyRow][emptyCol] = tile;
		board[tileRow][tileCol] = -1;
	}
	else if (tileRow == emptyRow && tileCol - 1 == emptyCol){
	
		board[emptyRow][emptyCol] = tile;
		board[tileRow][tileCol] = -1;
	}
	else if (tileRow - 1 == emptyRow && tileCol + 1 == emptyCol){
	
		board[emptyRow][emptyCol] = tile;
		board[tileRow][tileCol] = -1;
	}
}",0
ljon623,1696046215,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int emptyRow;
	int emptyCol;
	FindTile(board, -1, &emptyRow, &emptyCol);
	
	
	int tileRow;
	int tileCol;
	FindTile(board, tile, &tileRow, &tileCol);
	
	// Checking the tiles are adjacent
	if (tileRow + 1 == emptyRow && tileCol == emptyCol){
		board[emptyRow][emptyCol] = tile;
		board[tileRow][tileCol] = -1;
	}
	else if (tileRow - 1 == emptyRow && tileCol == emptyCol){
	
		board[emptyRow][emptyCol] = tile;
		board[tileRow][tileCol] = -1;
	}
	else if (tileRow == emptyRow && tileCol - 1 == emptyCol){
	
		board[emptyRow][emptyCol] = tile;
		board[tileRow][tileCol] = -1;
	}
	else if (tileRow - 1 == emptyRow && tileCol + 1 == emptyCol){
	
		board[emptyRow][emptyCol] = tile;
		board[tileRow][tileCol] = -1;
	}
}
",0
ljon623,1696046264,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int emptyRow;
	int emptyCol;
	FindTile(board, -1, &emptyRow, &emptyCol);
	
	
	int tileRow;
	int tileCol;
	FindTile(board, tile, &tileRow, &tileCol);
	
	// Checking the tiles are adjacent
	if (tileRow + 1 == emptyRow && tileCol == emptyCol){
		board[emptyRow][emptyCol] = tile;
		board[tileRow][tileCol] = -1;
	}
	else if (tileRow - 1 == emptyRow && tileCol == emptyCol){
	
		board[emptyRow][emptyCol] = tile;
		board[tileRow][tileCol] = -1;
	}
	else if (tileRow == emptyRow && tileCol - 1 == emptyCol){
	
		board[emptyRow][emptyCol] = tile;
		board[tileRow][tileCol] = -1;
	}
	else if (tileRow == emptyRow && tileCol + 1 == emptyCol){
	
		board[emptyRow][emptyCol] = tile;
		board[tileRow][tileCol] = -1;
	}
}
",1
ljun123,1696227921,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int erow;
    int ecol;
    int trow;
    int tcol;

    FindTile(board, -1, &erow, &ecol);
    FindTile(board, tile, &trow, &tcol);

    if ((tcol == ecol && (trow == erow - 1 || trow == erow + 1)) ||
        (trow == erow && (tcol == ecol - 1 || tcol == ecol + 1))) {
        
        board[erow][ecol] = board[trow][tcol];
        board[trow][tcol] = -1; 
    }",0
ljun123,1696227966,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int erow;
    int ecol;
    int trow;
    int tcol;

    FindTile(board, -1, &erow, &ecol);
    FindTile(board, tile, &trow, &tcol);

    if ((tcol == ecol && (trow == erow - 1 || trow == erow + 1)) ||
        (trow == erow && (tcol == ecol - 1 || tcol == ecol + 1))) {
        
        board[erow][ecol] = board[trow][tcol];
        board[trow][tcol] = -1; 
    }
}",1
lkel942,1695862229,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int trow, tcol;
	int brow, bcol;
	FindTile(board, tile, &trow, &tcol);
	FindTile(board, -1, &brow, &bcol);
	// find if adjacent to -1

	int adjacent;

	if ((trow == brow) && ((tcol == (bcol + 1)) || ((tcol == (bcol - 1))))) {
		adjacent = 1;
	} 
	else if ((tcol == bcol) && ((trow == (brow + 1)) || ((trow == (brow - 1))))) {
		adjacent = 1;
	}
	else {
		adjacent = 0;
	}
	
	if (adjacent = 1) {
		board[trow][tcol] = -1;
		board[brow][bcol] = tile;
	}
}",0
lkel942,1695862252,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int trow, tcol;
	int brow, bcol;
	FindTile(board, tile, &trow, &tcol);
	FindTile(board, -1, &brow, &bcol);
	// find if adjacent to -1

	int adjacent;

	if ((trow == brow) && ((tcol == (bcol + 1)) || ((tcol == (bcol - 1))))) {
		adjacent = 1;
	} 
	else if ((tcol == bcol) && ((trow == (brow + 1)) || ((trow == (brow - 1))))) {
		adjacent = 1;
	}
	else {
		adjacent = 0;
	}
	
	if (adjacent == 1) {
		board[trow][tcol] = -1;
		board[brow][bcol] = tile;
	}
}",1
llat663,1696224259,1,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {

	int empty_row, empty_col;
	int tile_row, tile_col;

	FindTile(board, -1, &empty_row, &empty_col);
	FindTile(board, tile, &tile_row, &tile_col);

	int row_diff = empty_row - tile_row;
	int col_diff = empty_col - tile_col;

	if ((row_diff == 1 && col_diff == 0) || (row_diff == 0 && col_diff == 1) || (row_diff == -1 && col_diff == 0) || (row_diff == 0 && col_diff == -1)) {

		int temp = board[empty_row][empty_col];
		board[empty_row][empty_col] = board[tile_row][tile_col];
		board[tile_row][tile_col] = temp;

	}
}",1
llei074,1696123736,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int new_row, new_col, row, col;

	FindTile(board, tile, &new_row, &new_col);

	FindTile(board, -1, &row, &col);

	if ((row + 1 == new_row) && (col == new_col)) {

		board[new_row][new_col] = -1;
		board[row][col] = tile;
	}
	else if ((row == new_row) && (col + 1 == new_col)) {

		board[new_row][new_col] = -1;
		board[row][col] = tile;
	}
	else if ((row - 1 == new_row) && (col == new_col)) {

		board[new_row][new_col] = -1;
		board[row][col] = tile;
	}
	else if ((row == new_row) && (col - 1 == new_col)) {

		board[new_row][new_col] = -1;
		board[row][col] = tile;
	}

}",1
lli393,1695786240,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	
	int i;
	int j;
	int row, rownum;
	int col, colnum;
	FindTile(board, -1, &row, &col);
	FindTile(board, tile, &rownum, &colnum);
	if (rownum == row){
		if (colnum == col || colnum == col + 1 || colnum == col - 1){
			board[row][col] = tile;
			board[rownum][colnum] = -1;
		}
	}else if (colnum == col){
		if (rownum == row + 1 || rownum == row - 1){
			board[row][col] = tile;
			board[rownum][colnum] = -1;
		}
	}

}",0
lli393,1695792075,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, rownum;
	int col, colnum;
	FindTile(board, -1, &row, &col);
	FindTile(board, tile, &rownum, &colnum);
	if (rownum == row){
		if (colnum == col || colnum == col + 1 || colnum == col - 1){
			board[row][col] = tile;
			board[rownum][colnum] = -1;
		}
	}else if (colnum == col){
		if (rownum == row + 1 || rownum == row - 1){
			board[row][col] = tile;
			board[rownum][colnum] = -1;
		}
	}
}",1
llia622,1696220043,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowPOS;
    int colPos;
    if (rowPOS > 0 && board[rowPOS - 1][colPos] == tile) {
        board[rowPOS][colPos] = tile;
        board[rowPOS - 1][colPos] = -1;
    }
    else if (colPos > 0 && board[rowPOS][colPos - 1] == tile) {
        board[rowPOS][colPos] = tile;
        board[rowPOS][colPos - 1] = -1;
    }
    else if (rowPOS < 3 && board[rowPOS + 1][colPos] == tile) {
        board[rowPOS][colPos] = tile;
        board[rowPOS + 1][colPos] = -1;
    }
    else if (colPos < 3 && board[rowPOS][colPos + 1] == tile) {
        board[rowPOS][colPos] = tile;
        board[rowPOS][colPos + 1] = -1;
    }
    else {
        board[rowPOS][colPos] = -1;
    }
}
",0
llia622,1696224592,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int i, j;
    for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
		    if (board[i][j] == -1 && i > 0 && board[i - 1][j] == tile) {
		        board[i][j] = tile;
                board[i - 1][j] = -1;
		    }
		    else if (board[i][j] == -1 && i > 0 && board[i][j - 1] == tile) {
		        board[i][j] = tile;
		        board[i][j - 1] = -1;
		    }
		    else if (board[i][j] == -1 && i < 3 && board[i + 1][j] == tile) {
		        board[i][j] = tile;
		        board[i + 1][j] = -1;
		    }
		    else if (board[i][j] == -1 && i < 3 && board[i][j + 1] == tile) {
		        board[i][j] = tile;
		        board[i][j + 1] = -1;
		    }
		}
    }
}",0
llia622,1696224746,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int i, j;
    for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
		    if (board[i][j] == -1 && i > 0 && board[i - 1][j] == tile) {
		        board[i][j] = tile;
                board[i - 1][j] = -1;
		    }
		    else if (board[i][j] == -1 && j > 0 && board[i][j - 1] == tile) {
		        board[i][j] = tile;
		        board[i][j - 1] = -1;
		    }
		    else if (board[i][j] == -1 && i < 3 && board[i + 1][j] == tile) {
		        board[i][j] = tile;
		        board[i + 1][j] = -1;
		    }
		    else if (board[i][j] == -1 && j < 3 && board[i][j + 1] == tile) {
		        board[i][j] = tile;
		        board[i][j + 1] = -1;
		    }
		}
    }
}",0
llia622,1696229622,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    
    for (int i = 0; i < NUM_ROWS; i++) {
		for (int j = 0; j < NUM_COLS; j++) {
		    if (board[i][j] == -1) {
		        if ((i > 0) && (board[i - 1][j] == tile)) {
		            board[i][j] = tile;
                    board[i - 1][j] = -1;
                    break;
		        } else if ((i < 3) && (board[i + 1][j] == tile)) {
		            board[i][j] = tile;
		            board[i + 1][j] = -1;
		            break;
		        } else if ((j > 0) && (board[i][j - 1] == tile)) {
		            board[i][j] = tile;
		            board[i][j - 1] = -1;
		            break;
		        } else if ((j < 3) && (board[i][j + 1] == tile)) {
		            board[i][j] = tile;
		            board[i][j + 1] = -1;
		            break;
		        } else {
		            board[i][j] = -1;
		            
		        }
		    }
		}
    }
}",0
llia622,1696242126,5,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int ROW, COL, ROWtile, COLtile;
    for (int i = 0; i < NUM_ROWS; i++) {
		for (int j = 0; j < NUM_COLS; j++) {
		    if (board[i][j] == tile) {
		        COLtile = j;
		        ROWtile = i;
		    }
		}
    }
    for (int i = 0; i < NUM_ROWS; i++) {
		for (int j = 0; j < NUM_COLS; j++) {
		    if (board[i][j] == -1) {
		        COL = j;
		        ROW = i;
		    }
		}
    }
    if ((ROW == ROWtile && (COL == COLtile + 1 || COL == COLtile - 1))
    || (COL == COLtile && (ROW ==ROWtile + 1 || ROW == ROWtile - 1))) {
        board[ROW][COL] = tile;
        board[ROWtile][COLtile] = -1;
    }
}",1
llig859,1696229651,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row, col, row1, col1;

    FindTile(board, -1, &row, &col);  
    FindTile(board, tile, &row1, &col1);  


    if ((abs(row - row1) == 1 && col == col1) || (row == row1 && abs(col - col1) == 1)) {
        int tempval = board[row][col];
        board[row][col] = board[row1][col1];
        board[row1][col1] = tempval;
    }
}
",1
lliu182,1696077825,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
	int row, col;
	FindTile(board, -1, &row, &col);
	int x, y;

	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			if (board[i][j] == tile) {
				x = i;
				y = j;

			}
		}
	}
	if (x == row && y == col + 1|| x == row && y == col-1|| x == row + 1 && y == col|| x == row -1 && y == col) {
		int temp = board[row][col];
		board[row][col] = board[x][y];
		board[x][y] = temp;
	}
}",0
lliu182,1696078015,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
	int row, col;
	FindTile(board, -1, &row, &col);
	int x, y;

	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			if (board[i][j] == tile) {
				x = i;
				y = j;

			}
		}
	}
	if ((x == row && y == col + 1) || (x == row && y == col - 1) || (x == row + 1 && y == col) || (x == row - 1 && y == col)) {
		int temp = board[row][col];
		board[row][col] = board[x][y];
		board[x][y] = temp;
	}
}",1
llu744,1696236278,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int targetrow;
    int targetcolumb;
    int emptyrow;
    int emptycolumb;
    
    FindTile(board, tile, &targetrow, &targetcolumb);
    FindTile(board, -1, &emptyrow, &emptycolumb);
    
    if (targetrow == emptyrow + 1 && targetcolumb == emptycolumb || targetrow == emptyrow - 1 && targetcolumb == emptycolumb || targetrow == emptyrow && targetcolumb == emptycolumb + 1 || targetrow == emptyrow && targetcolumb == emptycolumb - 1){
        int temp = board[targetrow][targetcolumb];
        board[targetrow][targetcolumb] = board[emptyrow][emptycolumb];
        board[emptyrow][emptycolumb] = temp;
    }
}",0
llu744,1696236484,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int targetrow;
    int targetcolumb;
    int emptyrow;
    int emptycolumb;
    
    FindTile(board, tile, &targetrow, &targetcolumb);
    FindTile(board, -1, &emptyrow, &emptycolumb);
    
    if (targetrow == emptyrow + 1 '&&' targetcolumb == emptycolumb '||' targetrow == emptyrow - 1 '&&' targetcolumb == emptycolumb '||' targetrow == emptyrow '&&' targetcolumb == emptycolumb + 1 '||' targetrow == emptyrow '&&' targetcolumb == emptycolumb - 1){
        int temp = board[targetrow][targetcolumb];
        board[targetrow][targetcolumb] = board[emptyrow][emptycolumb];
        board[emptyrow][emptycolumb] = temp;
    }
}",0
llu744,1696236672,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int targetrow;
    int targetcolumb;
    int emptyrow;
    int emptycolumb;
    
    FindTile(board, tile, &targetrow, &targetcolumb);
    FindTile(board, -1, &emptyrow, &emptycolumb);
    
    if ((targetrow == emptyrow + 1 && targetcolumb == emptycolumb) ||
    (targetrow == emptyrow - 1 && targetcolumb == emptycolumb) ||
    (targetrow == emptyrow && targetcolumb == emptycolumb + 1) ||
    (targetrow == emptyrow && targetcolumb == emptycolumb - 1)) {
        int temp = board[targetrow][targetcolumb];
        board[targetrow][targetcolumb] = board[emptyrow][emptycolumb];
        board[emptyrow][emptycolumb] = temp;
    }
}",1
lmen032,1696243515,1,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int *dash = 0;
    int *target = 0;

    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == -1) {
                dash = &board[i][j];
            } else if (board[i][j] == tile) {
                target = &board[i][j];
            }
        }
    }
}",0
lmen032,1696243650,2,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int *dash = 0;
    int *target = 0;
    int temp;

    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == -1) {
                dash = &board[i][j];
            } else if (board[i][j] == tile) {
                target = &board[i][j];
            }
        }
    }
    temp = *dash;
    *dash = *target;
    *target = temp;
}",0
lmen032,1696243797,3,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int *dash = 0;
    int *target = 0;
    int temp;

    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == -1) {
                dash = &board[i][j];
            } else if (board[i][j] == tile) {
                target = &board[i][j];
            }
        }
    }
   if (dash != 0 && target != 0) {
        temp = *dash;
        *dash = *target;
        *target = temp;
   }
}",0
lmor438,1695718357,1,"#include <stdio.h>

//AUTHOR:Lukem

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
 
 
 int emptyRow;
 int emptyCol;
 
 int tileRow;
 int tileCol;
 
 FindTile(board,-1,&emptyRow,&emptyCol);
 FindTile(board,tile,&tileRow,&tileCol);
 
 if(   (tileRow==emptyRow+1 && tileCol==emptyCol) || (tileRow==emptyRow-1 && tileCol==emptyCol) || (tileCol==emptyCol+1 && tileRow==emptyRow)
 || (tileCol==emptyCol-1 && tileRow==emptyRow)){
     //make move
     
     board[emptyRow][emptyCol]=tile;
     board[tileRow][tileCol]=-1;
    
 }

}",1
lpry623,1695617549,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int erow, ecol, trow, tcol;
    FindTile(board, -1, &erow, &ecol);
    FindTile(board, tile, &trow, &tcol);

    if ((trow == erow && (tcol == ecol - 1 || tcol == ecol + 1)) || (tcol == ecol && (trow == erow - 1 || trow == erow + 1))) {
        board[erow][ecol] = tile;
        board[trow][tcol] = -1;
    }


}",1
lrei069,1695866471,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    // Define position variables.
    int empty_tile_row, empty_tile_col, row, col;
    
    // Find the position of the empty tile.
   FindTile(board, -1, &empty_tile_row, &empty_tile_col);
   
   // Find the position of the tile that you want to move.
   FindTile(board, tile, &row, &col);
   
   // Check if you can move the tile down.
   if (row < NUM_ROWS && row == empty_tile_row - 1 && col == empty_tile_col) {
        board[empty_tile_row][empty_tile_col] = board[row][col];
        board[row][col] = -1; 
   }
   
   // Check if you can move the tile up.
   if (row > 0 && row == empty_tile_row + 1 && col == empty_tile_col) {
        board[empty_tile_row][empty_tile_col] = board[row][col];
        board[row][col] = -1;
   }
   
    // Check if you can move the tile right.
   if (col < NUM_COLS && col == empty_tile_col - 1 && row == empty_tile_row) {
        board[empty_tile_row][empty_tile_col] = board[row][col];
        board[row][col] = -1;
   }
   
    // Check if you can move the tile left.
   if (col > 0 && col == empty_tile_col + 1 && row == empty_tile_row) {
        board[empty_tile_row][empty_tile_col] = board[row][col];
        board[row][col] = -1;
   }
}",1
lros711,1695790261,1,"#include <stdio.h>
#include <stdlib.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row_t;
	int col_t;
	int row;
	int col;
	int r;
	int c;
	FindTile(board, -1, &row, &col);
	FindTile(board, tile, &row_t, &col_t);

	r = abs(row - row_t);
	c = abs(col - col_t);

	if (r == 1 && c == 0 || r == 0 && c == 1) 
	{
		board[row][col] = tile;
		board[row_t][col_t] = -1;
	}
}",0
lros711,1695790336,2,"#include <stdio.h>
#include <stdlib.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row_t;
	int col_t;
	int row;
	int col;
	int r;
	int c;
	FindTile(board, -1, &row, &col);
	FindTile(board, tile, &row_t, &col_t);

	r = abs(row - row_t);
	c = abs(col - col_t);

	if ((r == 1 && c == 0) || (r == 0 && c == 1)) 
	{
		board[row][col] = tile;
		board[row_t][col_t] = -1;
	}
}",1
lrya284,1696205838,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    for (int i = 0; i<NUM_ROWS; i++) {
        for (int j = 0; j<NUM_COLS; j++) {
    
            if (board[i][j] == -1) && (board[i+1][j] == tile) || (board[i][j+1] == tile) || (board[i-1][j] == tile) || (board[i][j-1] == tile) {
                board[i][j] = tile;
                if (board[i+1][j] == tile) {
                    (board[i+1][j] == -1);
                {
                else if (board[i][j+1] == tile) {
                    (board[i][j+1] == -1);
                {
                else if (board[i-1][j] == tile) {
                    (board[i-1][j] == -1);
                {
                else if (board[i][j-1] == tile) {
                    (board[i][j-1] == -1);
                }
            }
                
        }
    }
}",0
lrya284,1696205968,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    for (int i = 0; i<NUM_ROWS; i++) {
        for (int j = 0; j<NUM_COLS; j++) {
    
            if ((board[i][j] == -1) && (board[i+1][j] == tile) || (board[i][j+1] == tile) || (board[i-1][j] == tile) || (board[i][j-1] == tile)) {
                board[i][j] = tile;
                if (board[i+1][j] == tile) {
                    (board[i+1][j] == -1);
                {
                else if (board[i][j+1] == tile) {
                    (board[i][j+1] == -1);
                {
                else if (board[i-1][j] == tile) {
                    (board[i-1][j] == -1);
                {
                else if (board[i][j-1] == tile) {
                    (board[i][j-1] == -1);
                }
            }
                
        }
    }
}",0
lrya284,1696206149,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    for (int i = 0; i<NUM_ROWS; i++) {
        for (int j = 0; j<NUM_COLS; j++) {
    
            if ((board[i][j] == -1) && (board[i+1][j] == tile) || (board[i][j+1] == tile) || (board[i-1][j] == tile) || (board[i][j-1] == tile)) {
                board[i][j] = tile;
                
                if (board[i+1][j] == tile) {
                    (board[i+1][j] == -1);
                }
                else if (board[i][j+1] == tile) {
                    (board[i][j+1] == -1);
                }
                else if (board[i-1][j] == tile) {
                    (board[i-1][j] == -1);
                }
                else if (board[i][j-1] == tile) {
                    (board[i][j-1] == -1);
                }
                
            }
        }
    }
}",0
lrya284,1696206232,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    for (int i = 0; i<NUM_ROWS; i++) {
        for (int j = 0; j<NUM_COLS; j++) {
    
            if ((board[i][j] == -1) && ((board[i+1][j] == tile) || (board[i][j+1] == tile) || (board[i-1][j] == tile) || (board[i][j-1] == tile))) {
                board[i][j] = tile;
                
                if (board[i+1][j] == tile) {
                    (board[i+1][j] = -1);
                }
                else if (board[i][j+1] == tile) {
                    (board[i][j+1] = -1);
                }
                else if (board[i-1][j] == tile) {
                    (board[i-1][j] = -1);
                }
                else if (board[i][j-1] == tile) {
                    (board[i][j-1] = -1);
                }
                
            }
        }
    }
}",0
lrya284,1696207388,5,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
int i, j, x, y;

FindTile(board, tile, &x, &y);
FindTile(board, -1, &i, &j);

    if ((x == i && (y == j+1 || y == j-1)) || (y == j && (x == i+1 || x = i-1))) {
       FindTile(board, -1, &i, &j);
       board[x][y] = -1;
       board[i][j] = tile;
    }
}",0
lrya284,1696207403,6,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
int i, j, x, y;

FindTile(board, tile, &x, &y);
FindTile(board, -1, &i, &j);

    if ((x == i && (y == j+1 || y == j-1)) || (y == j && (x == i+1 || x == i-1))) {
       FindTile(board, -1, &i, &j);
       board[x][y] = -1;
       board[i][j] = tile;
    }
}",1
lsal082,1696228104,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol, tileRow, tileCol;
    
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);
    
    if (abs(emptyRow - tileRow) + abs(emptyCol - tileCol) == 1){
        
        int temp = board[emptyRow][emptyCol];
        board[emptyRow][emptyCol] = board[tileRow][tileCol];
        board[tileRow][tileCol] = temp;
    }
}",1
lsen376,1695952312,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int x, y, rowPos, colPos, xEmpty, yEmpty, xTile, yTile, swap;

	//call findtile to find the empty space
	FindTile(board, -1, &xEmpty, &yEmpty);

	//call findtile to find the tile we want to move
	FindTile(board, tile, &xTile, &yTile);

	//check if the tile is next to the empty space e.g. either side, above or below it
	if ((xTile - xEmpty == 1 && yTile - yEmpty == 0) || (xTile - xEmpty == -1 && yTile - yEmpty == 0) || (yTile - yEmpty == 1 && xTile - xEmpty == 0) || (yTile - yEmpty == -1 && xTile - xEmpty == 0)) {

		// if it is in a legal spot save the value of the tile and the empty space to an array
		swap = board[xEmpty][yEmpty];
		board[xEmpty][yEmpty] = board[xTile][yTile];
		board[xTile][yTile] = swap;
	}
}",0
lsen376,1695952346,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int xEmpty, yEmpty, xTile, yTile, swap;

	//call findtile to find the empty space
	FindTile(board, -1, &xEmpty, &yEmpty);

	//call findtile to find the tile we want to move
	FindTile(board, tile, &xTile, &yTile);

	//check if the tile is next to the empty space e.g. either side, above or below it
	if ((xTile - xEmpty == 1 && yTile - yEmpty == 0) || (xTile - xEmpty == -1 && yTile - yEmpty == 0) || (yTile - yEmpty == 1 && xTile - xEmpty == 0) || (yTile - yEmpty == -1 && xTile - xEmpty == 0)) {

		// if it is in a legal spot save the value of the tile and the empty space to an array
		swap = board[xEmpty][yEmpty];
		board[xEmpty][yEmpty] = board[xTile][yTile];
		board[xTile][yTile] = swap;
	}
}",1
lsha172,1696241218,1,"/* ENGGEN131 (2022) - Lab 9 (25th - 30th September, 2023)
   EXERCISE SEVEN and EIGHT - Sliding Tile Puzzle
*/
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowEmpty, colEmpty;
    int rowTile, colTile;
    
    FindTile(board, -1 &rowEmpty, &colEmpty);
    
    if (((rowTile == rowEmpty) && ((colTile == colEmpty + 1) || colTile == colEmpty - 1 ))) || 
        ((colTile == colEmpty) && ((rowTile == rowEmpty + 1) || (rowTile == rowEmpty - 1)))) {
        
        board[rowEmpty][colEmpty] = tile;
        board[rowTile][colTile] = -1;
    }
}",0
lsha172,1696242202,2,"/* ENGGEN131 (2022) - Lab 9 (25th - 30th September, 2023)
   EXERCISE SEVEN and EIGHT - Sliding Tile Puzzle
*/
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowEmpty, colEmpty;
    int rowTile, colTile;
    
    FindTile(board, -1, &rowEmpty, &colEmpty);
    
    FindTile(board, tile, &rowTile, &colTile)
    
    if (((rowTile == rowEmpty) && ((colTile == colEmpty + 1) || (colTile == colEmpty - 1))) ||
        ((colTile == colEmpty) && ((rowTile == rowEmpty + 1) || (rowTile == rowEmpty - 1)))) {
        
        board[rowEmpty][colEmpty] = tile;
        board[rowTile][colTile] = -1;
    }
}",0
lsha172,1696242940,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyRow, emptyCol;
    int tileRow, tileCol;
    
    FindTile(board, -1, &emptyRow, &emptyCol);
    
    FindTile(board, tile, &tileRow, &tileCol);
    
    if (((tileRow == emptyRow) && ((tileCol == emptyCol + 1) || (tileCol == emptyCol - 1))) || 
        ((tileCol == emptyCol) && ((tileRow == emptyRow + 1) || (tileRow == emptyRow - 1)))) {
           
           board[emptyRow][emptyCol] = tile;
           board[tileRow][tileCol] = -1;
       }
}",1
lspu128,1695847882,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    
    int Row_tile, Col_tile, Empty_row, Empty_col;
    FindTile(board, -1, &Empty_row, &Empty_col);
    FindTile(board, tile, &Row_tile, &Col_tile);
    
    if (((Empty_row - Row_tile == 1 || Row_tile - Empty_row == 1) && Empty_col == Col_tile) ||
    ((Empty_col - Col_tile == 1 || Col_tile - Empty_col == 1) == 1 && Empty_row == Row_tile)){
        
        int x = board[Empty_row][Empty_col];
        board[Empty_row][Empty_col] = board[Row_tile][Col_tile];
        board[Row_tile][Col_tile] = x;
    }
    
}",1
lsu376,1695800710,1,"#include <stdio.h>
#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
	int empty_Row = -1;
	int empty_Col = -1;

	for (int i = 0; i < NUM_ROWS; i++) {
		for (int j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == -1) {
				empty_Row = i;
				empty_Col = j;
			}
		}
	}

if (empty_Row > 0 && board[empty_Row - 1][empty_Col] == tile) {
	board[empty_Row][empty_Col] = tile;
	board[empty_Row - 1][empty_Col] = -1;
	}
else if (empty_Row < NUM_ROWS - 1 && board[empty_Row + 1][empty_Col] == tile) {
	board[empty_Row][empty_Col] = tile;
	board[empty_Row + 1][empty_Col] = -1;
	}
else if (empty_Col > 0 && board[empty_Row][empty_Col - 1] == tile) {
	board[empty_Row][empty_Col + 1] == tile;
	board[empty_Row][empty_Col - 1] == -1;
	}
else if (empty_Col < NUM_COLS - 1 && board[empty_Row][empty_Col + 1] == tile) {
	board[empty_Row][empty_Col] = tile;
	board[empty_Row][empty_Col + 1] = -1;
	}
}",0
lsu376,1695801733,2,"#include <stdio.h>
#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
	int empty_Row = -1;
	int empty_Col = -1;

	for (int i = 0; i < NUM_ROWS; i++) {
		for (int j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == -1) {
				empty_Row = i;
				empty_Col = j;
			}
		}
	}

if (empty_Row > 0 && board[empty_Row - 1][empty_Col] == tile) {
	board[empty_Row][empty_Col] = tile;
	board[empty_Row - 1][empty_Col] = -1;
	}
else if (empty_Row < NUM_ROWS - 1 && board[empty_Row + 1][empty_Col] == tile) {
	board[empty_Row][empty_Col] = tile;
	board[empty_Row + 1][empty_Col] = -1;
	}
else if (empty_Col > 0 && board[empty_Row][empty_Col - 1] == tile) {
	board[empty_Row][empty_Col] = tile;
	board[empty_Row][empty_Col - 1] = -1;
	}
else if (empty_Col < NUM_COLS - 1 && board[empty_Row][empty_Col + 1] == tile) {
	board[empty_Row][empty_Col] = tile;
	board[empty_Row][empty_Col + 1] = -1;
	}
}",1
lsua311,1696244018,1,"
Certainly! Here's the MakeMove function without comments:

c
Copy code
#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos) {
    for (int i = 0; i < NUM_ROWS; ++i) {
        for (int j = 0; j < NUM_COLS; ++j) {
            if (board[i][j] == tile) {
                *rowPos = i;
                *colPos = j;
                return;
            }
        }
    }

    *rowPos = -1;
    *colPos = -1;
}

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol, tileRow, tileCol;

    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);

    if ((tileRow == emptyRow && (tileCol == emptyCol - 1 || tileCol == emptyCol + 1)) ||
        (tileCol == emptyCol && (tileRow == emptyRow - 1 || tileRow == emptyRow + 1))) {

        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}

void PrintBoard(int board[NUM_ROWS][NUM_COLS]) {
    for (int i = 0; i < NUM_ROWS; ++i) {
        for (int j = 0; j < NUM_COLS; ++j) {
            if (board[i][j] == -1) {
                printf("" _ "");
            } else {
                printf(""%2d "", board[i][j]);
            }
        }
        printf(""\n"");
    }
}",0
lsua311,1696244048,2,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos) {
    for (int i = 0; i < NUM_ROWS; ++i) {
        for (int j = 0; j < NUM_COLS; ++j) {
            if (board[i][j] == tile) {
                *rowPos = i;
                *colPos = j;
                return;
            }
        }
    }

    *rowPos = -1;
    *colPos = -1;
}

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol, tileRow, tileCol;

    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);

    if ((tileRow == emptyRow && (tileCol == emptyCol - 1 || tileCol == emptyCol + 1)) ||
        (tileCol == emptyCol && (tileRow == emptyRow - 1 || tileRow == emptyRow + 1))) {

        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}

void PrintBoard(int board[NUM_ROWS][NUM_COLS]) {
    for (int i = 0; i < NUM_ROWS; ++i) {
        for (int j = 0; j < NUM_COLS; ++j) {
            if (board[i][j] == -1) {
                printf("" _ "");
            } else {
                printf(""%2d "", board[i][j]);
            }
        }
        printf(""\n"");
    }
}",0
ltan813,1696240543,1,"
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol, tileRow, tileCol;

    int empty = 0;
    int foundTile = 0;
    
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == -1) {
                emptyRow = i;
                emptyCol = j;
                empty = 1;
            }
            if (board[i][j] == tile) {
                tileRow = i;
                tileCol = j;
                foundTile = 1;
            }
        }
    }
}",0
ltan813,1696243023,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol, tileRow, tileCol;

    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);

    if (emptyRow != -1 && tileRow != -1) {
        if ((emptyRow == tileRow && abs(emptyCol - tileCol) == 1) ||
            (emptyCol == tileCol && abs(emptyRow - tileRow) == 1)) {
            int temp = board[emptyRow][emptyCol];
            board[emptyRow][emptyCol] = board[tileRow][tileCol];
            board[tileRow][tileCol] = temp;
        }
    }
}",1
lvan346,1696074848,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, origVal;

	FindTile(board, tile, &row, &col);

	// bottom
	if (board[row + 1][col] == -1) {
		origVal = board[row][col];
		board[row][col] = -1;
		board[row + 1][col] = origVal;
	}
	// top
	if (board[row - 1][col] == -1) {
		origVal = board[row][col];
		board[row][col] = -1;
		board[row - 1][col] = origVal;
	}
	
	// right
	if ((board[row][col + 1] == -1) && (col != 3)) {
		origVal = board[row][col];
		board[row][col] = -1;
		board[row][col + 1] = origVal;
	}

	
	//left
	if ((board[row][col - 1] == -1) && (col != 0)) {
		origVal = board[row][col];
		board[row][col] = -1;
		board[row][col - 1] = origVal;
	}

}",1
lvin900,1696156782,1,"#include<stdio.h>
#include<stdlib.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row_tile;
	int col_tile;

	FindTile(board, tile, &row_tile, &col_tile);

	int empty = -1;
	int row_empty;
	int col_empty;

	FindTile(board, empty, &row_empty, &col_empty);

	if ((abs(row_tile - row_empty) == 1) && (abs(col_tile - col_empty) == 0) || (abs(row_tile - row_empty) == 0) && (abs(col_tile - col_empty) == 1)) {

		board[row_empty][col_empty] = board[row_tile][col_tile];
		board[row_tile][col_tile] = -1;
		
	}
}",0
lvin900,1696156861,2,"#include<stdio.h>
#include<stdlib.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row_tile;
	int col_tile;

	FindTile(board, tile, &row_tile, &col_tile);

	int empty = -1;
	int row_empty;
	int col_empty;

	FindTile(board, empty, &row_empty, &col_empty);

	if (((abs(row_tile - row_empty) == 1) && (abs(col_tile - col_empty) == 0)) || ((abs(row_tile - row_empty) == 0) && (abs(col_tile - col_empty) == 1))) {

		board[row_empty][col_empty] = board[row_tile][col_tile];
		board[row_tile][col_tile] = -1;
		
	}
}",1
lwer802,1696243226,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRow, tileCol, emptyRow, emptyCol;

    // Find the position of the tile to be moved
    FindTile(board, tile, &tileRow, &tileCol);
    
    // Find the position of the empty square
    FindTile(board, -1, &emptyRow, &emptyCol);

    // Check if the tile is adjacent to the empty square
    if ((tileRow == emptyRow && abs(tileCol - emptyCol) == 1) ||  // Same row, adjacent columns
        (tileCol == emptyCol && abs(tileRow - emptyRow) == 1)) {  // Same column, adjacent rows
        // Swap the tile and the empty square
        board[emptyRow][emptyCol] = board[tileRow][tileCol];
        board[tileRow][tileCol] = -1;
    }
    // If they're not adjacent, do nothing (i.e., don't move the tile)
}
",1
lwon290,1696207182,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int emptyRow, emptyCol, tileRow, tileCol;

	FindTile(board, -1, &emptyRow, &emptyCol);
	FindTile(board, tile, &tileRow, &tileCol);

	if ((tileRow == emptyRow && (emptyCol - tileCol == -1 || emptyCol - tileCol == 1)) || (tileCol == emptyCol && (emptyRow - tileRow == -1 || emptyRow - tileRow == 1))) {
		board[emptyRow][emptyCol] = tile;
		board[tileRow][tileCol] = -1;
	}
}",1
lyou975,1696058139,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	
	int row;
	int col;
	int emptyrow;
	int emptycol;

	FindTile(board, tile, &row, &col);
	FindTile(board, -1, &emptyrow, &emptycol);

	if ((row == emptyrow && ((col == emptycol -1) || (col == emptycol + 1))) || (col == emptycol && ((row == emptyrow - 1) || (row = emptyrow + 1)))) {

		board[emptyrow][emptycol] = tile;
		board[row][col] = -1;
	}


	

	

}",0
lyou975,1696059514,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	
	int row;
	int col;
	int emptyrow;
	int emptycol;

	FindTile(board, tile, &row, &col);
	FindTile(board, -1, &emptyrow, &emptycol);

	if ((row == emptyrow && col == emptycol -1 || row == emptyrow && col == emptycol + 1 || col == emptycol && row == emptyrow -1 || col == emptycol && row == emptyrow + 1)) {

		board[emptyrow][emptycol] = tile;
		board[row][col] = -1;
	}

}",0
lyou975,1696059731,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	
	int row;
	int col;
	int emptyrow;
	int emptycol;

	FindTile(board, tile, &row, &col);
	FindTile(board, -1, &emptyrow, &emptycol);

	if ((row == emptyrow && col == emptycol -1 )|| (row == emptyrow && col == emptycol + 1 )|| (col == emptycol && row == emptyrow -1 )|| (col == emptycol && row == emptyrow + 1)) {

		board[emptyrow][emptycol] = tile;
		board[row][col] = -1;
	}

}",1
mabb997,1695705113,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, rowi, coli;
	FindTile(board, -1, &row, &col);
	FindTile(board, tile, &rowi, &coli);

	if (rowi == row + 1 && coli == col) {
		board[row][col] = tile;
		board[rowi][coli] = -1;
	}
		
	if (rowi == row - 1 && coli == col) {
		board[row][col] = tile;
		board[rowi][coli] = -1;
	}
		
	if (coli == col + 1 && rowi == row && (coli != 0)) {
		board[row][col] = tile;
		board[rowi][coli] = -1;
	}

	if (coli == col - 1 && rowi == row && (col != 0)) {
		board[row][col] = tile;
		board[rowi][coli] = -1;
	}
	
}",1
mahu925,1695759365,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    int row, col, emptyY, emptyX, tileX, tileY;
    FindTile(board, -1, &row, &col);
    emptyY= row;
    emptyX = col;
    FindTile(board, tile, &row, &col);
    tileY= row;
    tileX = col;
    
        

    
    if ((tile == board[emptyY][emptyX+1]&& emptyX!=3) || tile == board[emptyY+1][emptyX] || tile == board[emptyY-1][emptyX]|| (tile == board[emptyY][emptyX-1]&& emptyX!= 0)){
        board[tileY][tileX] = -1;
        board[emptyY][emptyX] = tile;
        
    }
}",1
mala824,1696221193,1,"void MakeMove(int board[ROWS][COLS], int tile) {
    int row, col;
    if(FindTile(board, tile, &row, &col)) {
        if ((row > 0 && board[row - 1][col] == -1) || 
            (row < ROWS - 1 && board[row + 1][col] == -1) || 
            (col > 0 && board[row][col - 1] == -1) || 
            (col < COLS - 1 && board[row][col + 1] == -1)) {
            board[row][col] = -1;
            board[row][col] = tile;
        }
    }
}
",0
mala824,1696221403,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row, col;
    if(FindTile(board, tile, &row, &col)) {
        if ((row > 0 && board[row - 1][col] == -1) || 
            (row < ROWS - 1 && board[row + 1][col] == -1) || 
            (col > 0 && board[row][col - 1] == -1) || 
            (col < COLS - 1 && board[row][col + 1] == -1)) {
            board[row][col] = -1;
            board[row][col] = tile;
        }
    }
}
",0
mala824,1696221470,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row, col;
    FindTile(board, tile, &row, &col);

    if ((row > 0 && board[row - 1][col] == -1) || 
        (row < NUM_ROWS - 1 && board[row + 1][col] == -1) || 
        (col > 0 && board[row][col - 1] == -1) || 
        (col < NUM_COLS - 1 && board[row][col + 1] == -1)) {
        board[row][col] = -1;
        board[row][col] = tile;
    }
}",0
mala824,1696221595,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row, col;
    FindTile(board, tile, &row, &col);

    if ((row > 0 && board[row - 1][col] == -1) || 
        (row < NUM_ROWS - 1 && board[row + 1][col] == -1) || 
        (col > 0 && board[row][col - 1] == -1) || 
        (col < NUM_COLS - 1 && board[row][col + 1] == -1)) {
        board[row][col] = -1;
        board[row][col] = tile; 
    }
}
",0
mala824,1696221793,5,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row, col;
    FindTile(board, tile, &row, &col);

    if ((row > 0 && board[row - 1][col] == -1) || 
        (row < NUM_ROWS - 1 && board[row + 1][col] == -1) || 
        (col > 0 && board[row][col - 1] == -1) || 
        (col < NUM_COLS - 1 && board[row][col + 1] == -1)) {
        board[row][col] = tile;    
        board[row][col] = -1;
    }
}
",0
mala824,1696222403,6,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row, col;
    int vari;
    if(FindTile(board, tile, &row, &col)) {
        if ((row > 0 && board[row - 1][col] == -1) || 
            (row < ROWS - 1 && board[row + 1][col] == -1) || 
            (col > 0 && board[row][col - 1] == -1) || 
            (col < COLS - 1 && board[row][col + 1] == -1)) {
            vari = board[row][col];     
            board[row][col] = -1;
            board[row][col] = vari;
        }
    }
}",0
mala824,1696229406,7,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row, col;
    FindTile(board, tile, &row, &col);

    if ((row > 0 && board[row - 1][col] == -1) || 
        (row < NUM_ROWS - 1 && board[row + 1][col] == -1) || 
        (col > 0 && board[row][col - 1] == -1) || 
        (col < NUM_COLS - 1 && board[row][col + 1] == -1)) {
        int temp = board[row][col];
        board[row][col] = -1;
        board[row][col] = temp;
    }
}",0
mala824,1696229502,8,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row, col;
    FindTile(board, tile, &row, &col);

    if ((row > 0 && board[row - 1][col] == -1) || 
        (row < NUM_ROWS - 1 && board[row + 1][col] == -1) || 
        (col > 0 && board[row][col - 1] == -1) || 
        (col < NUM_COLS - 1 && board[row][col + 1] == -1)) {
        int temp = board[row][col];
        board[row][col] = board[row][col + 1];
        board[row][col + 1] = temp;
    }
}",0
mbah279,1696020265,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int rowPos, colPos;
    FindTile(board, tile, &rowPos, &colPos);

    if (rowPos == -1 || colPos == -1) {
        printf(""Tile %d is an error.\n"", tile);
        return; 
    }


    if ((rowPos > 0 && board[rowPos - 1][colPos] == -1) || 
        (rowPos < NUM_ROWS - 1 && board[rowPos + 1][colPos] == -1) || 
        (colPos > 0 && board[rowPos][colPos - 1] == -1) || // Left
        (colPos < NUM_COLS - 1 && board[rowPos][colPos + 1] == -1)) { 

        board[rowPos][colPos] = -1;
        board[rowPos][colPos] = tile;
    } else {
        printf(""Tile %d cannot be moved as so.\n"", tile);
    }
}",0
mbah279,1696021696,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	for (int row = 0; row < NUM_ROWS; row++) {
		for (int col = 0; col < NUM_COLS; col++) {
			if (board[row][col] == -1) {
				if (board[row + 1][col] == tile && row + 1 < NUM_ROWS) {
					board[row][col] = tile;
					board[row + 1][col] = -1;
					return;
				}
				else if (board[row - 1][col] == tile && row - 1 > -1) {
					board[row][col] = tile;
					board[row - 1][col] = -1;
					return;
				}
				if (board[row][col + 1] == tile && col + 1 < NUM_COLS) {
					board[row][col] = tile;
					board[row][col + 1] = -1;
					return;
				}
				else if (board[row][col - 1] == tile && col - 1 > -1) {
					board[row][col] = tile;
					board[row][col - 1] = -1;
					return;
				}
			}
		}
	}
}",1
mbal759,1695865214,1,"#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int i;
    int j;
    for (i = 0; i < 4; i++)
    {
        for (j = 0; j < 4; j++)
        {
            //check to the right of the tile
            if (board[i+1][j] == -1)
            {
                board[i+1][j] = tile;
                board[i][j] = -1;
                return;
            }
            //check to the left of the tile
            else if (board[i-1][j] == -1)
            {
                board[i-1][j] = tile;
                board[i][j] = -1;
                return;
            }
            //check below the tile
            else if (board[i][j+1] == -1)
            {
                board[i][j+1] = tile;
                board[i][j] = -1;
                return;
            }
            // check above the tile
            else if (board[i][j-1] == -1)
            {
                board[i][j-1] = tile;
                board[i][j] = -1;
                return;
            }
            else
            {
                return;
            }
        }
    }
}",0
mbal759,1696151450,2,"#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col;
    FindTile(board, tile, &row, &col);
    
    int t, top, bottom, left, right;
    if (row > 0)
    {
        t = board[row-1][col];
        if (t == -1)
        {
            board[row][col] = t;
            board[row-1][col] = tile;
        }
    }
    if (row < NUM_ROWS-1)
    {
        t = board[row+1][col];
        if (t == -1)
        {
            board[row][col] = t;
            board[row+1][col] = tile;
        }
    }
    if (col > 0)
    {
        t = board[row][col-1];
        if (t == -1)
        {
            board[row][col] = t;
            board[row][col-1] = tile;
        }
    }
    if (col < NUM_COLS-1)
    {
        t = board[row][col+1];
        if (t == -1)
        {
            board[row][col] = t;
            board[row][col+1] = tile;
        }
    }
}",0
mbal759,1696151581,3,"#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col;
    FindTile(board, tile, &row, &col);
    int t;
    if (row > 0)
    {
        t = board[row-1][col];
        if (t == -1)
        {
            board[row][col] = t;
            board[row-1][col] = tile;
        }
    }
    if (row < NUM_ROWS-1)
    {
        t = board[row+1][col];
        if (t == -1)
        {
            board[row][col] = t;
            board[row+1][col] = tile;
        }
    }
    if (col > 0)
    {
        t = board[row][col-1];
        if (t == -1)
        {
            board[row][col] = t;
            board[row][col-1] = tile;
        }
    }
    if (col < NUM_COLS-1)
    {
        t = board[row][col+1];
        if (t == -1)
        {
            board[row][col] = t;
            board[row][col+1] = tile;
        }
    }
}",1
mboy221,1695623315,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row, column;
    FindTile(board,tile,&row,&column);
    if (board[row+1][column] == -1) {
        board[row+1][column] = board[row][column];
        board[row][column] = -1;
    } else if (board[row-1][column] == -1) {
        board[row-1][column] = board[row][column];
        board[row][column] = -1;
    } else if (board[row][column+1] == -1) {
        board[row][column+1] = board[row][column];
        board[row][column] = -1;
    } else if (board[row][column-1] == -1) {
        board[row][column-1] = board[row][column];
        board[row][column] = -1;
    }
}",0
mboy221,1695687469,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row, column;
    int fair = 0;
    int neg1, neg2;
    FindTile(board,-1,&neg1,&neg2);
    FindTile(board,tile,&row,&column);
    if ((board[neg1][neg2-1]==tile)&&(row==neg1-1)) {
        fair = 1;
    }
    if ((board[neg1][neg2+1]==tile)&&(row==neg1+1)) {
        fair = 1;
    }
    if ((board[row+1][column] == -1)&&(fair==0)) {
        board[row+1][column] = board[row][column];
        board[row][column] = -1;
    } else if ((board[row-1][column] == -1)&&(fair==0)) {
        board[row-1][column] = board[row][column];
        board[row][column] = -1;
    } else if ((board[row][column+1] == -1)&&(fair==0)) {
        board[row][column+1] = board[row][column];
        board[row][column] = -1;
    } else if ((board[row][column-1] == -1)&&(fair==0)) {
        board[row][column-1] = board[row][column];
        board[row][column] = -1;
    }
}",1
mbut885,1695889884,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, blank_row, blank_col;
	FindTile(board, tile, &row, &col);
	FindTile(board, -1, &blank_row, &blank_col);

	if ((row == blank_row) && (((col - blank_col) == 1) || ((col - blank_col) == -1))) {
		board[blank_row][blank_col] = tile;
		board[row][col] = -1;
	} else if ((col == blank_col) && (((row - blank_row) == 1) || ((row - blank_row) == -1))) {
		board[blank_row][blank_col] = tile;
		board[row][col] = -1;
	}

	return;
}",1
mcam799,1696243399,1,"void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int* rowPos, int* colPos)
{
	//Created pointer. Use pointer to find number? 
	int i; //rows
	int j; //columns


	for (i = 0; i <= (NUM_ROWS - 1); i++) {
		for (j = 0; j <= (NUM_COLS - 1); j++) {
			if (board[i][j] == tile) {
				*rowPos = i;  //identifying position into variables??
				*rowCol = j;
			}
		}
	}


	//Use pointer to convert address to number?

}

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j, barROW, barCOL, placeholder;
	int *tileaddress;
	int *numberaddress;
	int array[4]; //emptyarray
	int count = 0;

	//Locate where -1 is
	for (i = 0; i <= (NUM_ROWS - 1); i++) {
		for (j = 0; j <= (NUM_COLS - 1); j++) {
			if (board[i][j] == -1) {
				barROW = i;
				barCOL = j;
			}
		}
	}

	//Get address of tile to swap
	tileaddress = &tile;

	//Identify which values are valid for movement
	for (i = -1; i <= 1; i + 2) {
		for (j = -1; i = <= 1; i + 2) {
			if (((barROW + i) >= 0) && ((barCOL + j) >= 0)) { //if within boundaries
				array[count] = board[barROW][barCOLS]; //store in array
				count = count + 1; //counts how many values in array
			}
		}
	}

	//Only if valid, then move
	for (i = 0; i < count; i++) {
		if (array[i] == tile) {
			numberaddress = &array[i];
			placeholder = *numberaddress;
			*numberaddress = *tileaddress;
			*tileaddress = placeholder;

		}
	}
	

}",0
mcam799,1696243500,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j, barROW, barCOL, placeholder;
	int *tileaddress;
	int *numberaddress;
	int array[4]; //emptyarray
	int count = 0;

	//Locate where -1 is
	for (i = 0; i <= (NUM_ROWS - 1); i++) {
		for (j = 0; j <= (NUM_COLS - 1); j++) {
			if (board[i][j] == -1) {
				barROW = i;
				barCOL = j;
			}
		}
	}

	//Get address of tile to swap
	tileaddress = &tile;

	//Identify which values are valid for movement
	for (i = -1; i <= 1; i + 2) {
		for (j = -1; i = <= 1; i + 2) {
			if (((barROW + i) >= 0) && ((barCOL + j) >= 0)) { //if within boundaries
				array[count] = board[barROW][barCOLS]; //store in array
				count = count + 1; //counts how many values in array
			}
		}
	}

	//Only if valid, then move
	for (i = 0; i < count; i++) {
		if (array[i] == tile) {
			numberaddress = &array[i];
			placeholder = *numberaddress;
			*numberaddress = *tileaddress;
			*tileaddress = placeholder;

		}
	}
	

}",0
mcam799,1696243733,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j, barROW, barCOL, placeholder;
	int *tileaddress;
	int *numberaddress;
	int array[4]; //emptyarray
	int count = 0;

	//Locate where -1 is
	for (i = 0; i <= (NUM_ROWS - 1); i++) {
		for (j = 0; j <= (NUM_COLS - 1); j++) {
			if (board[i][j] == -1) {
				barROW = i;
				barCOL = j;
			}
		}
	}

	//Get address of tile to swap
	tileaddress = &tile;

	//Identify which values are valid for movement
	for (i = -1; i <= 1; i = i + 2) {
		for (j = -1; i <= 1; i = i + 2) {
			if (((barROW + i) >= 0) && ((barCOL + j) >= 0)) { //if within boundaries
				array[count] = board[barROW][barCOL]; //store in array
				count = count + 1; //counts how many values in array
			}
	
		}
	}

	//Only if valid, then move
	for (i = 0; i < count; i++) {
		if (array[i] == tile) {
			numberaddress = &array[i];
			placeholder = *numberaddress;
			*numberaddress = *tileaddress;
			*tileaddress = placeholder;

		}
	}
	

}",0
mcam799,1696243991,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j, barROW, barCOL, placeholder;
	int *tileaddress;
	int *numberaddress;
	int array[4]; //emptyarray
	int count = 0;

	//Locate where -1 is
	for (i = 0; i <= (NUM_ROWS - 1); i++) {
		for (j = 0; j <= (NUM_COLS - 1); j++) {
			if (board[i][j] == -1) {
				barROW = i;
				barCOL = j;
			}
		}
	}

	
	

	//Identify which values are valid for movement
	for (i = -1; i <= 1; i = i + 2) {
		for (j = -1; i <= 1; i = i + 2) {
			if (((barROW + i) >= 0) && ((barCOL + j) >= 0)) { //if within boundaries
				array[count] = board[barROW][barCOL]; //store in array
				count = count + 1; //counts how many values in array
			}
	
		}
	}

	//Only if valid, then move
	for (i = 0; i < count; i++) {
		if (array[i] == tile) {
			numberaddress = &array[i];
			placeholder = array[i];
			tileaddress = &tile;
			*numberaddress = *tileaddress;
			*tileaddress = placeholder;

		}
	}
	

}",0
mcha833,1696129027,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    int i,j,row,col;
    FindTile(board, -1, &row, &col);
    for(i = 0; i<NUM_ROWS; i++){
        for(j = 0; j<NUM_COLS; j++){
            if(board[i][j] == tile){
                if((i-row==1)&&(j-col==0)){
                    board[row][col] = tile;
                    board[i][j] = -1;
                }
                else if((i-row==-1)&&(j-col==0)){
                    board[row][col] = tile;
                    board[i][j] = -1;
                }
                else if((i-row==0)&&(j-col==1)){
                    board[row][col] = tile;
                    board[i][j] = -1;
                }
                else if((i-row==0)&&(j-col==-1)){
                    board[row][col] = tile;
                    board[i][j] = -1;
                }
            }
        }
    }
}",1
mcha876,1696235277,1,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol;
    int tileRow, tileCol;

    FindTile(board, -1, emptyRow, emptyCol);
    FindTile(board, tile, tileRow, tileCol);

    int rowDifference = emptyRow - tileRow;
    int colDifference = emptyCol - tileCol;

    if ((rowDifference == 1 && colDifference == 0) || (rowDifference == -1 && colDifference == 0) ||
        (rowDifference == 0 && colDifference == 1) || (rowDifference == 0 && colDifference == -1)) {
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
    return;
}
",0
mcha876,1696235310,2,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol;
    int tileRow, tileCol;

    FindTile(board, -1, emptyRow, emptyCol);
    FindTile(board, tile, tileRow, tileCol);

    int rowDifference = emptyRow - tileRow;
    int colDifference = emptyCol - tileCol;

    if ((rowDifference == 1 && colDifference == 0) || (rowDifference == -1 && colDifference == 0) ||
        (rowDifference == 0 && colDifference == 1) || (rowDifference == 0 && colDifference == -1)) {
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}
",0
mcha876,1696235732,3,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol;
    int tileRow, tileCol;

    FindTile(board, -1, emptyRow, emptyCol);
    FindTile(board, tile, tileRow, tileCol);

    int rowDifference = emptyRow - tileRow;
    int colDifference = emptyCol - tileCol;

    if ((rowDifference == 1 && colDifference == 0) || (rowDifference == -1 && colDifference == 0) ||
        (rowDifference == 0 && colDifference == 1) || (rowDifference == 0 && colDifference == -1)) {
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}
",0
mcha876,1696239726,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol;
    int tileRow, tileCol;

    FindTile(board, -1, emptyRow, emptyCol);
    FindTile(board, tile, tileRow, tileCol);

    if ((emptyRow == tileRow && (emptyCol == tileCol - 1 || emptyCol == tileCol + 1)) ||
       (emptyCol == tileCol  && (emptyRow == tileRow - 1 || emptyRow == tielRow + 1))) {
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}
",0
mcha876,1696239830,5,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol;
    int tileRow, tileCol;

    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);

    if ((emptyRow == tileRow && (emptyCol == tileCol - 1 || emptyCol == tileCol + 1)) ||
       (emptyCol == tileCol  && (emptyRow == tileRow - 1 || emptyRow == tileRow + 1))) {
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}
",1
mche403,1696230249,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol, tileRow, tileCol;
    
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);

    if ((abs(emptyRow - tileRow) == 1 && emptyCol == tileCol) ||
        (abs(emptyCol - tileCol) == 1 && emptyRow == tileRow)) {
       
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }

}",1
mdav506,1695672623,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS],int tile)
{
    int emptyRow;
    int emptyCol;
    int posRow;
    int posCol;
    int swaptiles;

    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &posRow, &posCol);

    if (emptyRow == posRow && emptyCol == posCol + 1) {
        swaptiles = board[emptyRow][emptyCol];
        board[emptyRow][emptyCol] = board[posRow][posCol];
        board[posRow][posCol] = swaptiles;
    } else if (emptyRow == posRow && emptyCol == posCol - 1) {
        swaptiles = board[emptyRow][emptyCol];
        board[emptyRow][emptyCol] = board[posRow][posCol];
        board[posRow][posCol] = swaptiles;
    } else if (emptyRow == posRow + 1 && emptyCol == posCol) {
        swaptiles = board[emptyRow][emptyCol];
        board[emptyRow][emptyCol] = board[posRow][posCol];
        board[posRow][posCol] = swaptiles;
    } else if (emptyRow == posRow - 1 && emptyCol == posCol) {
        swaptiles = board[emptyRow][emptyCol];
        board[emptyRow][emptyCol] = board[posRow][posCol];
        board[posRow][posCol] = swaptiles;
    }
}",1
mdea492,1696128028,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row1, col1;
FindTile(board, tile, &row1, &col1);


int row2, col2;
FindTile(board, -1, &row2, &col2);


if( board[row1-1][col1]==board[row2][col2])
{ 
	board[row2][col2]=tile;
	board[row1-1][col1]=-1;
}

if( board[row1+1][col1]==board[row2][col2])
{ 
	board[row2][col2]=tile;
	board[row1+1][col1]=-1;
}

if( board[row1][col1-1]==board[row2][col2])
{ 
	board[row2][col2]=tile;
	board[row1][col1-1]=-1;
}

if( board[row1][col1+1]==board[row2][col2])
{ 
	board[row2][col2]=tile;
	board[row1][col1+1]=-1;
}
}",0
mdea492,1696219734,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row1, col1;
FindTile(board, tile, &row1, &col1);


int row2, col2;
FindTile(board, -1, &row2, &col2);

if (row1 ==row2 && col1 ==col2-1)
 {
        board[row2][col2] = board[row1][col1];
        board[row1][col1] = -1;
  }


if (row1 ==row2 && col1 ==col2+1)
 {
        board[row2][col2] = board[row1][col1];
        board[row1][col1] = -1;
  }
  
  if (col1 == col2 && row1==row2-1)
   {
        board[row2][col2] = board[row1][col1];
        board[row1][col1] = -1;
  }
  
  if (col1 == col2 && row1 == row2+1)
   {
        board[row2][col2] = board[row1][col1];
        board[row1][col1] = -1;
  }
}",1
mfle888,1696239310,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tileRow, tileCol, emptyRow, emptyCol;
    
    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol); 
    
    if ((abs(tileRow - emptyRow) == 1 && tileCol == emptyCol) ||
        (abs(tileCol - emptyCol) == 1 && tileRow == emptyRow)) {

        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}
",1
mfuj750,1695780111,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	/*Find the tile to be moved*/
	int row, col = 0;
	FindTile(board, tile, &row, &col);

	int emptyRow, emptyCol;
	FindTile(board, -1, &emptyRow, &emptyCol);

	/*If it is adjacent to the nempty squire, then swap them*/
	int emptySquare = 0;

	if ((col == 0) && ((emptyRow == row && emptyCol == 1) || (emptyRow == row - 1 || emptyRow == row + 1) && emptyCol == col)) {
		emptySquare = 1;
	}

	if ((col == 3) && ((emptyRow == row && emptyCol == 2) || ((emptyRow == row - 1 || emptyRow == row + 1) && emptyCol == col))) {
			emptySquare = 1;
	}

	if ((col == 1 || col == 2) && (((emptyRow == row + 1 || emptyRow == row - 1) && (emptyCol == col)) || ((emptyCol == col + 1 || emptyCol == col - 1) && (emptyRow == row)))) {
			emptySquare = 1;
	}

	printf(""%d\n"", emptySquare);

	if (emptySquare == 1) {
		int a = board[row][col];

		board[row][col] = -1;
		board[emptyRow][emptyCol] = a;

	}
}",0
mfuj750,1695780539,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	/*Find the tile to be moved*/
	int row, col = 0;
	FindTile(board, tile, &row, &col);

	int emptyRow, emptyCol;
	FindTile(board, -1, &emptyRow, &emptyCol);

	/*If it is adjacent to the nempty squire, then swap them*/
	int emptySquare = 0;

	if ((col == 0) && ((emptyRow == row && emptyCol == 1) || ((emptyRow == row - 1 || emptyRow == row + 1) && emptyCol == col))) {
		emptySquare = 1;
	}

	if ((col == 3) && ((emptyRow == row && emptyCol == 2) || ((emptyRow == row - 1 || emptyRow == row + 1) && emptyCol == col))) {
		emptySquare = 1;
	}

	if ((col == 1 || col == 2) && (((emptyRow == row + 1 || emptyRow == row - 1) && (emptyCol == col)) || ((emptyCol == col + 1 || emptyCol == col - 1) && (emptyRow == row)))) {
		emptySquare = 1;
	}

	if (emptySquare == 1) {
		int a = board[row][col];

		board[row][col] = -1;
		board[emptyRow][emptyCol] = a;

	}
}",1
mger154,1695952027,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row;
	int col;
	int row1;
	int col1;

	FindTile(board, tile, &row, &col);
	FindTile(board, -1, &row1, &col1);

	if ((row - 1 == row1) | (row + 1 == row1) & (col == col1)){
		board[row][col] = -1;
		board[row1][col1] = tile;	
	}

	if ((col - 1 == col1) | (col + 1 == col1) & (row == row1)){
		board[row][col] = -1;
		board[row1][col1] = tile;
	}
}",0
mger154,1695952082,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row;
	int col;
	int row1;
	int col1;

	FindTile(board, tile, &row, &col);
	FindTile(board, -1, &row1, &col1);

	if ((row - 1 == row1) || (row + 1 == row1) && (col == col1)){
		board[row][col] = -1;
		board[row1][col1] = tile;	
	}

	if ((col - 1 == col1) || (col + 1 == col1) && (row == row1)){
		board[row][col] = -1;
		board[row1][col1] = tile;
	}
}",0
mger154,1695952468,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row;
	int col;
	int row1;
	int col1;

	FindTile(board, tile, &row, &col);
	FindTile(board, -1, &row1, &col1);

	if (((row - 1 == row1) || (row + 1 == row1)) && (col == col1)){
		board[row][col] = -1;
		board[row1][col1] = tile;	
	}

	if (((col - 1 == col1) || (col + 1 == col1)) && (row == row1)){
		board[row][col] = -1;
		board[row1][col1] = tile;
	}
}",1
mgoy303,1695632614,1,"#include <stdlib.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol, tileRow, tileCol;
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == tile) {
                tileRow = i;
                tileCol = j;
            } else if (board[i][j] == -1) {
                emptyRow = i;
                emptyCol = j;
            }
            
        }
    }
    if ((tileRow == emptyRow && abs(tileCol - emptyCol) == 1) || 
    (tileCol == emptyCol && abs(tileRow - emptyRow) == 1)) {
        board[emptyRow][emptyCol] = board[tileRow][tileCol];
        board[tileRow][tileCol] = -1;
    }
}",1
mgua740,1696204916,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) 
    {
		int numberRow, numberCol;
		FindTile(board, tile, &numberRow, &numberCol);

		{
			int empRow, empCol;
			FindTile(board, -1, &empRow, &empCol);

			
			if ((numberRow == empRow && (numberCol == empCol - 1 || numberCol == empCol + 1)) ||
				(numberCol == empCol && (numberRow == empRow - 1 ||numberRow == empRow + 1))) {
				
				board[empRow][empCol] = tile;
				board[numberRow][numberCol] = -1;
			}
		}
    }",1
mhua821,1696239615,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowBlank, colBlank, rowTile, colTile;

	FindTile(board, -1, &rowBlank, &colBlank);
	FindTile(board, tile, &rowTile, &colTile);

	if (rowBlank == rowTile) {
		if (colTile == colBlank -1 || colTile == colBlank +1) {
		board[rowBlank][colBlank] = tile;
		board[rowTile][colTile] = -1;
		}
	else if (colBlank == colTile) {
		if (rowTile == rowBlank -1 || rowTile == rowBlank +1) {
			board[rowBlank][colBlank] = tile;
			board[rowTile][colTile] = -1;
		}
	}
	}
}",0
mhua821,1696242861,2," void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowBlank, colBlank, rowTile, colTile;

    FindTile(board, -1, &rowBlank, &colBlank);
    FindTile(board, tile, &rowTile, &colTile);

    if (rowBlank == rowTile) {
        if (colBlank == colTile - 1 || colBlank == colTile + 1) {
            board[rowBlank][colBlank] = tile;
            board[rowTile][colTile] = -1;
        }
    }
    else if (colBlank == colTile) {
        if (rowBlank == rowTile - 1 || rowBlank == rowTile + 1) {
            board[rowBlank][colBlank] = tile;
            board[rowTile][colTile] = -1;
        }
    }
}",1
mjun868,1696067760,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row;
	int col;
	FindTile(board, -1, &row, &col);
	
	for (int i = 0; i < NUM_ROWS; i++){
		for (int j = 0; j < NUM_COLS; j++){
			if (board[i][j] == tile){
				if (board[i+1][j] == board[row][col] || board[i-1][j] == board[row][col] || board[i][j+1] == board[row][col] || board[i][j-1] == board[row][col]){
				board[i][j] = -1;
				board[row][col] = tile;
				}
			}
		}
	}
}",0
mjun868,1696069835,2,"
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row;
	int col;
	FindTile(board, -1, &row, &col);
	
	for (int i = 0; i < NUM_ROWS; i++){
		for (int j = 0; j < NUM_COLS; j++){
			if (board[i][j] == tile){
				if ( i + 1 < NUM_ROWS && board[i+1][j] == board[row][col]){
				board[i][j] = -1;
				board[row][col] = tile;
				}
				else if (i - 1 >= 0 && board[i-1][j] == board[row][col]){
				board[i][j] = -1;
				board[row][col] = tile;
				}
				else if (j + 1 < NUM_COLS && board[i][j + 1] == board[row][col]){
				board[i][j] = -1;
				board[row][col] = tile;
				}
				else if (j - 1 >=0 && board[i][j-1] == board[row][col]){
				board[i][j] = -1;
				board[row][col] = tile;
				}
				}
			}
		}
	}
",1
mkab524,1696205712,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;
	int rowt, colt;

	FindTile(board, -1, &row, &col);
	FindTile(board, tile, &rowt, &colt);

	if ((row == rowt + 1) && (col == colt)) {
		board[row][col] = tile;
		board[rowt][colt] = -1;
	}

	else if ((row == rowt) && (col == colt + 1)) {
		board[row][col] = tile;
		board[rowt][colt] = -1;
	}

	else if ((row == rowt - 1) && (col == colt)) {
		board[row][col] = tile;
		board[rowt][colt] = -1;
	}

	else if ((row == rowt) && (col == colt - 1)) {
		board[row][col] = tile;
		board[rowt][colt] = -1;
	}

}",1
mkaj411,1695782873,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row;
	int col;
	int temp; 
	FindTile(board, -1, &row, &col);
	if (tile == board[row + 1][col]) {
		temp = board[row+1][col];
		board[row+1][col] = -1;
		board[row][col]=temp;
	 }
	if (tile == board[row - 1][col]) {
		temp = board[row-1][col];
		board[row-1][col] = -1;
		 board[row][col]=temp;
	 }
	if (tile == board[row][col + 1]) {
		temp = board[row][col + 1];
		board[row][col + 1] = -1;
		board[row][col]=temp;
	 }
	if(tile == board[row][col - 1]) {
		temp = board[row][col - 1];
		board[row][col - 1] = -1;
		board[row][col]=temp; 
	 }
}",0
mkaj411,1695792469,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row;
	int col;
	int temp;
	FindTile(board, -1, &row, &col);
	if (tile == board[row + 1][col]) {
		temp = board[row + 1][col];
		board[row + 1][col] = -1;
		board[row][col] = temp;
	}
	if (tile == board[row - 1][col]) {
		temp = board[row - 1][col];
		board[row - 1][col] = -1;
		board[row][col] = temp;
	}
	
	if (tile == board[row][col + 1]) {
			if (col == 3) {
				return;
			}else{ temp = board[row][col + 1];
			  board[row][col + 1] = -1;
			  board[row][col] = temp;
			}
	}
	
	if (tile == board[row][col - 1]) {
		if (col == 0) {
		    return;
		}else{ temp = board[row][col - 1];
			board[row][col - 1] = -1;
			board[row][col] = temp;
		}
	}
}",1
mkee115,1695703694,1,"
#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4


void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col;
    
    FindTile(board, -1, &row, &col);

    int row2, col2;

    FindTile(board, tile, &row2, &col2);
    
    int TemporaryValueRow, TemporaryValueCol;
    

    
    
    if (((row + 1 == row2 || row - 1 == row2) && col==col2) || ((col + 1 == col2 || col - 1 == col2) && row==row2))
    {
        if (row != row2)
        {
            TemporaryValueRow = board[row][col];
            board[row][col] = board[row2][col];
            board[row2][col] = TemporaryValueRow;
        }
        if (col != col2)
        {
            TemporaryValueCol = board[row][col];
            board[row][col] = board[row][col2];
            board[row][col2] = TemporaryValueCol;
        }
        
    }
    
    else
    {
        return;
    }
    
    
}",1
mken566,1695969770,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowtile, coltile, rowempty, colempty, rowdistance, coldistance;
    FindTile(board, tile, &rowtile, &coltile);
    FindTile(board, -1, &rowempty, &colempty);
    
    rowdistance = rowtile - rowempty;
    coldistance = coltile - colempty;
    
    if ((rowdistance == 1 && coldistance == 0) || (rowdistance == -1 && coldistance == 0) || (rowdistance == 0 && coldistance == 1) || (rowdistance == 0 && coldistance == -1))
    {
    int initialempty = board[rowempty][colempty];
    board[rowempty][colempty] = board[rowtile][coltile];
    board[rowtile][coltile] = initialempty;
    } else 
    {
        return;
    }
}",1
mket106,1696165985,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
  	int row, col;
	int tilerow, tilecol;

  	FindTile(board, -1, &row, &col);
  	FindTile(board, tile, &tilerow, &tilecol);
	  
  	if (tilerow == row && (tilecol - 1 == col || tilecol + 1)) {
    	board[tilerow][tilecol] = -1; 
    	board[row][col] = tile;
  	} else if (tilecol == col && (tilerow - 1 == row || tilerow + 1 == row)) {
    	board[tilerow][tilecol] = -1;
    	board[row][col] = tile;
  	}
}",1
mkim670,1695807471,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, rowNew, colNew, temp;

	FindTile(board, -1, &row, &col);

	FindTile(board, tile, &rowNew, &colNew);

	//printf(""\n%d %d\n%d %d\n"", row, col, rowNew, colNew);

	if (((rowNew - row == 1) || (rowNew - row == -1)) && ((colNew - col == 1) || (colNew - col == -1))) {
		return;
	}

	if (row == 0) {
		if (col == 0) {
			if ((rowNew == row + 1 || rowNew == row) && (colNew == col + 1 || colNew == col)) {
				temp = board[rowNew][colNew];
				board[rowNew][colNew] = -1;
				board[row][col] = temp;
			}
			else {
				return;
			}
		}
		else if (col == NUM_COLS - 1) {
			if ((rowNew == row + 1 || rowNew == row) && (colNew == col - 1 || colNew == col)) {
				temp = board[rowNew][colNew];
				board[rowNew][colNew] = -1;
				board[row][col] = temp;
			}
			else {
				return;
			}
		}
		else {
			if ((rowNew == row + 1 || rowNew == row) && (colNew == col + 1 || colNew == col - 1 || colNew == col)) {
				temp = board[rowNew][colNew];
				board[rowNew][colNew] = -1;
				board[row][col] = temp;
			}
			else {
				return;
			}
		}
	} else if (row == NUM_ROWS - 1) {
		if (col == 0) {
			if ((rowNew == row - 1 || rowNew == row) && (colNew == col + 1 || colNew == col)) {
				temp = board[rowNew][colNew];
				board[rowNew][colNew] = -1;
				board[row][col] = temp;
			}
			else {
				return;
			}
		}
		else if (col == NUM_COLS - 1) {
			if ((rowNew == row - 1 || rowNew == row) && (colNew == col - 1 || colNew == col)) {
				temp = board[rowNew][colNew];
				board[rowNew][colNew] = -1;
				board[row][col] = temp;
			}
			else {
				return;
			}
		}
		else {
			if ((rowNew == row - 1 || rowNew == row) && (colNew == col + 1 || colNew == col - 1 || colNew == col)) {
				temp = board[rowNew][colNew];
				board[rowNew][colNew] = -1;
				board[row][col] = temp;
			}
			else {
				return;
			}
		}
	}
	else if (col == 0) {
		if ((colNew == col + 1 || colNew == col) && (rowNew == row + 1 || rowNew == row - 1 || rowNew == row)) {
			temp = board[rowNew][colNew];
			board[rowNew][colNew] = -1;
			board[row][col] = temp;
		}
		else {
			return;
		}
	}
	else if (col == NUM_COLS - 1) {
		if ((colNew == col - 1 || colNew == col) && (rowNew == row + 1 || rowNew == row - 1 || rowNew == row)) {
			temp = board[rowNew][colNew];
			board[rowNew][colNew] = -1;
			board[row][col] = temp;
		}
		else {
			return;
		}
	}
	else {
		if ((rowNew == row + 1 || rowNew == row - 1 || rowNew == row) && (colNew == col + 1 || colNew == col - 1 || colNew == col)) {
			temp = board[rowNew][colNew];
			board[rowNew][colNew] = -1;
			board[row][col] = temp;
		}
		else {
			return;
		}
	}
}",1
mkim719,1696065807,1,"#define NUM_ROWS 4
#define NUM_COLS 4

void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos)
{
    int i, j;
    
    for (i=0 ; i<NUM_ROWS ; i++) 
    {
        for (j=0 ; j<NUM_COLS ; j++)
        {
            if(board[i][j]==tile)
            {
                *rowPos = i;
                *colPos = j;
                
                //printf("" row[%d] col[%d] \n"", i, j);
                return;
            }
        }
    }
    
    *rowPos = -1;
    *rowPos = -1;
    //printf("" Error!. Can't find [%d] \n"", tile);
}


void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int i, j;
    int row1, col1, row2, col2;
    
    FindTile(board, -1, &row1, &col1);
    
    FindTile(board, tile, &row2, &col2);
    
    
    if ( (  ((row1 - row2)==1) &&  (col1==col2) ) || 
         (  ((row1 - row2)==-1) && (col1==col2) ) || 
         (  ((col1 - col2)==1) &&  (row1==row2) ) || 
         (  ((col1 - col2)==-1) && (row1==row2) )  )
     {
         //printf(""Can swap!!\n"");
         board[row1][col1] = board[row2][col2];
         board[row2][col2] = '_';
     }
    else
     {
         //printf(""Can not swap!!\n"");
         board[row1][col1] = '_';
     }
}

void PrintBoard(int board[NUM_ROWS][NUM_COLS])
{
    int i, j;
    
    for (i=0 ; i<NUM_ROWS ; i++) 
    {
        for (j=0 ; j<NUM_COLS ; j++)
        {
            if (board[i][j]=='_')
                printf(""%-2c "", board[i][j]);
            else
                printf(""%-2d "", board[i][j]);
        }
        printf(""\n"");
    }
}",0
mkim719,1696068181,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row1, col1, row2, col2;
    
    FindTile(board, -1, &row1, &col1);
    FindTile(board, tile, &row2, &col2);
    
    if ( (  ((row1 - row2)==1) &&  (col1==col2) ) || 
         (  ((row1 - row2)==-1) && (col1==col2) ) || 
         (  ((col1 - col2)==1) &&  (row1==row2) ) || 
         (  ((col1 - col2)==-1) && (row1==row2) )  )
     {
         //printf(""Can swap!!\n"");
         board[row1][col1] = board[row2][col2];
         board[row2][col2] = -1;
     }
}
",1
mlal864,1696233751,1,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

int MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRow, tileCol, emptyRow, emptyCol;

    // Find the positions of the specified tile and the empty square
    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol);

    // Check if the tile is adjacent to the empty square
    if ((tileRow == emptyRow && (tileCol == emptyCol - 1 || tileCol == emptyCol + 1)) ||
        (tileCol == emptyCol && (tileRow == emptyRow - 1 || tileRow == emptyRow + 1))) {
        // Swap the tile and the empty square
        int temp = board[emptyRow][emptyCol];
        board[emptyRow][emptyCol] = board[tileRow][tileCol];
        board[tileRow][tileCol] = temp;

        return 1; // Move successfully made
    } else {
        return 0; // Move cannot be made
    }
}",1
mlaw649,1696243844,1,"
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    
    // set variables
    int row_tile;
    int col_tile;
    int empty_row;
    inte empty_column;
    
    //call findtile function
    findTitle(board, tile, &row_tile, &col_tile);
    findTitle(board, -1, &empty_row, empty_column);
    
    
    // check if the input tile is adjacent next to square 
    if (((row_tile - empty_row ==1 || row_tile - empty_row ==-1) && col_tile == empty_column) ||
        ((col_tile- empty_column == 1 || col_tile -empty_column == -1) && row_tile == empty_row)) {
            
        // Swap input tile with the empty square
        board[empty_row][empty_column] = tile;
        board[row_tile][col_tile] = -1;
        
    // else, do nothing
    } else {
       
       
    }
}
    
    
}

",0
mlaw649,1696243946,2,"
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    
    // set variables
    int row_tile;
    int col_tile;
    int empty_row;
    int empty_column;
    
    //call findtile function
    FindTitle(board, tile, &row_tile, &col_tile);
    FindTitle(board, -1, &empty_row, empty_column);
    
    
    // check if the input tile is adjacent next to square 
    if (((row_tile - empty_row ==1 || row_tile - empty_row ==-1) && col_tile == empty_column) ||
        ((col_tile- empty_column == 1 || col_tile -empty_column == -1) && row_tile == empty_row)) {
            
        // Swap input tile with the empty square
        board[empty_row][empty_column] = tile;
        board[row_tile][col_tile] = -1;
        
    // else, do nothing
    } else {
       
       
    }
}
    

",0
mlaw649,1696244075,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    
    // Set variables
    int row_tile;
    int col_tile;
    int empty_row;
    int empty_column;
    
    // Call FindTile function
    FindTile(board, tile, &row_tile, &col_tile);
    FindTile(board, -1, &empty_row, &empty_column); // Pass the address of empty_column
    
    // Check if the input tile is touchig empty square 
    if (((row_tile - empty_row == 1 || row_tile - empty_row == -1) && col_tile == empty_column) ||
        ((col_tile - empty_column == 1 || col_tile - empty_column == -1) && row_tile == empty_row)) {
            
        // Swap input tile with the empty square
        board[empty_row][empty_column] = tile;
        board[row_tile][col_tile] = -1;
        
        
    }
}


",1
mle063,1695789605,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{

    int row;
    int col;

    int val_row;
    int val_col;
    
//  First obtain the empty tile's position
    FindTile(board, -1, &row, &col);

//  Then obtain the inputed value's position
    FindTile(board, tile, &val_row, &val_col);

//  Do lots of check to see are they next to each others
//  If yes, swap them    
//  If no, end the function


    if (val_col == col + 1 && val_row == row){
        board[row][col] = tile;
        board[val_row][val_col] = -1;
    } 
    
    else if (val_col == col - 1 && val_row == row) {
        board[row][col] = tile;
        board[val_row][val_col] = -1;        
    }
    
    else if (val_row == row + 1 && val_col == col) {
        board[row][col] = tile;
        board[val_row][val_col] = -1;        
    }  
    
    else if (val_row == row - 1 && val_col == col) {
        board[row][col] = tile;
        board[val_row][val_col] = -1;        
    }  
    
    else if (val_row == row - 1 && col == 0 && val_col == 3) {
        board[row][col] = tile;
        board[val_row][val_col] = -1;        
    }  
        
    else if (val_row == row + 1 && col == 3 && val_col == 0) {
        board[row][col] = tile;
        board[val_row][val_col] = -1;        
    }  
    
    else {
        return;
    }
     
}",0
mle063,1695790130,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{

    int row;
    int col;

    int val_row;
    int val_col;
    
//  First obtain the empty tile's position
    FindTile(board, -1, &row, &col);

//  Then obtain the inputed value's position
    FindTile(board, tile, &val_row, &val_col);

//  Do lots of check to see are they next to each others
//  If yes, swap them    
//  If no, end the function


    if (val_col == col + 1 && val_row == row){
        board[row][col] = tile;
        board[val_row][val_col] = -1;
    } 
    
    else if (val_col == col - 1 && val_row == row) {
        board[row][col] = tile;
        board[val_row][val_col] = -1;        
    }
    
    else if (val_row == row + 1 && val_col == col) {
        board[row][col] = tile;
        board[val_row][val_col] = -1;        
    }  
    
    else if (val_row == row - 1 && val_col == col) {
        board[row][col] = tile;
        board[val_row][val_col] = -1;        
    }  
    
    
    else {
        return;
    }
     
}",1
mlin729,1695766979,1,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int rowPos, colPos, rowTile, colTile;

    FindTile(board, -1, &rowPos, &colPos);
    FindTile(board, tile, &rowTile, &colTile);

    int rowDiff = rowPos - rowTile;
    int colDiff = colPos - colTile;

    if ((rowDiff == 1 && colDiff == 0) || (rowDiff == -1 && colDiff == 0) || (rowDiff == 0 && colDiff == 1) || (rowDiff == 0 && colDiff == -1)) {
        board[rowPos][colPos] = tile;
        board[rowTile][colTile] = -1;
    }
}",1
mloh302,1695791161,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row1, col1, row2, col2;
    FindTile(board, -1, &row1, &col1);
    FindTile(board, tile, &row2, &col2);
    
    // Replace the value at board[row1][col1] with the value at board[row2][col2] and vice versa
    board[row1][col1] = board[row2][col2];
    board[row2][col2] = -1;
}",0
mloh302,1695792350,2,"#include <math.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row1, col1, row2, col2, rowDiff, colDiff;
    FindTile(board, -1, &row1, &col1);
    FindTile(board, tile, &row2, &col2);

    rowDiff = fabs(row1-row2);
    colDiff = fabs(col1-col2);
    
    if ((rowDiff <= 1 && colDiff <= 1) && !(rowDiff == 1 && colDiff == 1)){
        // Replace the value at board[row1][col1] with the value at board[row2][col2] and vice versa
        board[row1][col1] = board[row2][col2];
        board[row2][col2] = -1;
    }
}",1
mmak111,1696228869,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;
	int nrow, ncol;
	FindTile(board, tile, &row, &col);
	nrow = row;
	ncol = col;

	if (row > 0 && board[row - 1][col] == -1) {
		nrow = row - 1;
	}
	if (row < NUM_ROWS - 1 && board[row + 1][col] == -1) {
		nrow = row + 1;
	}
	if (col > 0 && board[row][col - 1] == -1) {
		ncol = col - 1;
	}
	if (col < NUM_COLS - 1 && board[row][col + 1] == -1) {
		ncol = col + 1;
	}

	if (nrow != row || ncol != col) {
		board[nrow][ncol] = tile;
		board[row][col] = -1;
	}
}",1
mman402,1696046358,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	//int emptyRow, emptyCol;
	int tileRow, tileCol;
	int temp;

	FindTile(board, tile, &tileRow, &tileCol);
	if (tileRow > 0)
	{
		if (board[tileRow - 1][tileCol] == -1)
		{
			board[tileRow - 1][tileCol] = tile;
			board[tileRow][tileCol] = -1;
			return;
		}
	} 
	if (tileRow<3)
	{
		if (board[tileRow + 1][tileCol] == -1)
		{
			board[tileRow + 1][tileCol] = tile;
			board[tileRow][tileCol] = -1;
			return;
		}
	}
	if (tileCol < 3)
	{
		if (board[tileRow][tileCol+1] == -1)
		{
			board[tileRow][tileCol+1] = tile;
			board[tileRow][tileCol] = -1;
			return;
		}
	}
	if (tileCol > 0)
	{
		if (board[tileRow][tileCol-1] == -1)
		{
			board[tileRow][tileCol-1] = tile;
			board[tileRow][tileCol] = -1;
			return;
		}
	}
	else
	{

	}
}",0
mman402,1696046374,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	//int emptyRow, emptyCol;
	int tileRow, tileCol;


	FindTile(board, tile, &tileRow, &tileCol);
	if (tileRow > 0)
	{
		if (board[tileRow - 1][tileCol] == -1)
		{
			board[tileRow - 1][tileCol] = tile;
			board[tileRow][tileCol] = -1;
			return;
		}
	} 
	if (tileRow<3)
	{
		if (board[tileRow + 1][tileCol] == -1)
		{
			board[tileRow + 1][tileCol] = tile;
			board[tileRow][tileCol] = -1;
			return;
		}
	}
	if (tileCol < 3)
	{
		if (board[tileRow][tileCol+1] == -1)
		{
			board[tileRow][tileCol+1] = tile;
			board[tileRow][tileCol] = -1;
			return;
		}
	}
	if (tileCol > 0)
	{
		if (board[tileRow][tileCol-1] == -1)
		{
			board[tileRow][tileCol-1] = tile;
			board[tileRow][tileCol] = -1;
			return;
		}
	}
	else
	{

	}
}",1
mman808,1696237808,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int TRow, TCol, row, col;
	FindTile(board, -1, &row, &col);
	FindTile(board, tile, &TRow, &TCol);
//if chosen tile is adjacent to empty tile
	if ((TRow == row + 1 && TCol == col) || 
	(TRow == row - 1 && TCol == col) || 
	(TRow == row && TCol == col + 1) || 
	(TRow == row && TCol == col - 1)){
		//Swap empty tile and chosen tile
		board[row][col] = tile;
		board[TRow][TCol] = -1;
	}
}",1
mmas199,1696228460,1,"#include <stdio.h>
#include <stdlib.h> 

#define NUM_ROWS 4
#define NUM_COLS 4


void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int RowPos, ColPos;
    int empRowPos, empColPos;

    FindTile(board, tile, &RowPos, &ColPos);
    FindTile(board, -1, &empRowPos, &empColPos);

    if ((abs(RowPos - empRowPos) == 1 && ColPos == empColPos) ||
        (abs(ColPos - empColPos) == 1 && RowPos == empRowPos))
    {

        board[empRowPos][empColPos] = tile;
        board[RowPos][ColPos] = -1;
    }
}",1
mmca276,1695892788,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rows ;
    int columns ;
    int tile_rows ;
    int tile_cols ;
    int temp ;
FindTile(board, tile, &tile_rows, &tile_cols) ;
FindTile(board, -1, &rows, &columns) ;
    if (tile_rows == rows && tile_cols == (columns + 1)) {
        temp = board[rows][columns] ;
        board[rows][columns] = board[tile_rows][tile_cols] ;
        board[tile_rows][tile_cols] = temp ;
    }
        else if (tile_rows == rows && tile_cols == (columns - 1)) {
            temp = board[rows][columns] ;
            board[rows][columns] = board[tile_rows][tile_cols] ;
            board[tile_rows][tile_cols] = temp ; 
        }
        else if (tile_cols == columns && tile_rows == (rows + 1)) {
            temp = board[rows][columns] ;
            board[rows][columns] = board[tile_rows][tile_cols] ;
            board[tile_rows][tile_cols] = temp ;
        }
        else if (tile_cols == columns && tile_rows == (rows - 1)) {
            temp = board[rows][columns] ;
            board[rows][columns] = board[tile_rows][tile_cols] ;
            board[tile_rows][tile_cols] = temp ; 

        }
}",1
mmcg745,1696237797,1,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4
#define EMPTY -1

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
   
    int row, col;
   
    int FindTile(board, -1, row, col);
    
    
    int tileRow, tileCol;
    
    int foundTile = 0;


    

   
    if (foundTile &&
        ((tileRow == row && (tileCol == col - 1 || tileCol == col + 1)) ||
         (tileCol == col && (tileRow == row - 1 || tileRow == row + 1)))) {
        
        board[row][col] = tile;
        board[tileRow][tileCol] = EMPTY;
       
    }
    
}",0
mmcg745,1696238162,2,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4
#define EMPTY -1

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    
    int tileRow, tileCol;
    int emptyRow, emptyCol;
    int foundTile = 0;


    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == tile) {
                tileRow = i;
                tileCol = j;
                foundTile = 1;
            } else if (board[i][j] == EMPTY) {
                emptyRow = i;
                emptyCol = j;
            }
        }
    }


    if (foundTile &&
        ((tileRow == emptyRow && (tileCol == emptyCol - 1 || tileCol == emptyCol + 1)) ||
         (tileCol == emptyCol && (tileRow == emptyRow - 1 || tileRow == emptyRow + 1)))) {

        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = EMPTY;
         
         
        }
         
}",1
mmoh314,1696239195,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowTile, colTile, rowEmpty, colEmpty;
	FindTile(board, tile, &rowTile, &colTile);
	FindTile(board, -1, &rowEmpty, &colEmpty);

	if ((rowTile - 1 == rowEmpty && colTile == colEmpty) || (rowTile + 1 == rowEmpty && colTile == colEmpty) || 
		(rowTile == rowEmpty && colTile - 1 == colEmpty) || (rowTile == rowEmpty && colTile + 1 == colEmpty))
	{
		board[rowEmpty][colEmpty] = tile;
		board[rowTile][colTile] = -1;
	}
}",1
mmoh456,1696136791,1,"#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
	int blankRow;
	int blankCol;
	int tileRow;
	int tileCol;

	for (int i = 0; i < NUM_ROWS; i++) {
		for (int j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == -1) {
				blankRow = i;
				blankCol = j;
				
			}
			else if (board[i][j] == tile) {
				tileRow = i;
				tileCol = j;
		}
	}
}
	
	if ((tileCol == blankCol && (tileRow - blankRow == 1 || tileRow - blankRow == -1)) 
	|| (tileRow == blankRow &&(tileCol - blankCol == 1) || (tileCol - blankCol == -1))) {
	    
	board[blankRow][blankCol] = tile;
	board[tileRow][tileCol] = -1;
     }
}",0
mmoh456,1696137029,2,"#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
	int blankRow;
	int blankCol;
	int tileRow;
	int tileCol;

	for (int i = 0; i < NUM_ROWS; i++) {
		for (int j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == -1) {
				blankRow = i;
				blankCol = j;
				
			}
			else if (board[i][j] == tile) {
				tileRow = i;
				tileCol = j;
		}
	}
}
	
	if ((tileCol == blankCol && (tileRow - blankRow == 1 || tileRow - blankRow == -1)) 
	|| (tileRow == blankRow &&(tileCol - blankCol == 1 || tileCol - blankCol == -1))) {
	    
	board[blankRow][blankCol] = tile;
	board[tileRow][tileCol] = -1;
     }
}",1
mnay503,1696146688,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyTileRow, emptyTileCol;
    FindTile(board, -1, &emptyTileRow, &emptyTileCol);

    int tileRow, tileCol;
    FindTile(board, tile, &tileRow, &tileCol);

    if ((tileRow == emptyTileRow && (tileCol == emptyTileCol - 1 || tileCol == emptyTileCol + 1)) ||
        (tileCol == emptyTileCol && (tileRow == emptyTileRow - 1 || tileRow == emptyTileRow + 1))) 
        {
        
        board[emptyTileRow][emptyTileCol] = tile;
        board[tileRow][tileCol] = -1;
        } 
    else
      {
        printf(""Incorrect move! Please choose a neighboring tile.\n"");
       }
}",0
mnay503,1696200869,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyTileRow, emptyTileCol;
    FindTile(board, -1, &emptyTileRow, &emptyTileCol);

    int tileRow, tileCol;
    FindTile(board, tile, &tileRow, &tileCol);

    if ((tileRow == emptyTileRow && (tileCol == emptyTileCol - 1 || tileCol == emptyTileCol + 1)) ||
        (tileCol == emptyTileCol && (tileRow == emptyTileRow - 1 || tileRow == emptyTileRow + 1))) 
        {
        
        board[emptyTileRow][emptyTileCol] = tile;
        board[tileRow][tileCol] = -1;
        }
}",1
moco678,1696143752,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int* NewCol, * NewRow, row, col;
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == tile)
                *NewCol = i;
            *NewRow = j;
        }
    }
    FindTile(board, -1, &row, &col);

    if (NewCol == col + 1 || col - 1 || NewRow == row + 1 || row - 1){
        board[row][col] = tile;
        board[*NewRow][*NewCol] = -1; 
    }
}",0
moco678,1696145944,2,"#include <stdio.h>
#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
	int NewCol, NewRow, row, col;

	FindTile(board, tile, &NewCol, &NewRow);

	FindTile(board, -1, &row, &col);

	if ((col == NewCol + 1 || col == NewCol - 1) || (row == NewRow + 1 || row == NewRow - 1)) {

		board[NewRow][NewCol] = -1;
		board[row][col] = board[NewRow][NewCol];
	}
	return;
}
",0
moco678,1696146393,3,"#include <stdio.h>
#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int NewCol, NewRow, row, col;

	FindTile(board, tile, &NewCol, &NewRow);

	FindTile(board, -1, &row, &col);

	if ((col == NewCol + 1 || col == NewCol - 1) || (row == NewRow + 1 && col == NewCol || row == NewRow - 1 && col == NewCol)) {

		board[NewRow][NewCol] = -1;
		board[row][col] = board[NewRow][NewCol];
	}
	return;
}",0
moco678,1696146514,4,"#include <stdio.h>
#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int NewCol, NewRow, row, col;

	FindTile(board, tile, &NewCol, &NewRow);

	FindTile(board, -1, &row, &col);

	if ((col == NewCol + 1 || col == NewCol - 1) || ((row == NewRow + 1 && col == NewCol) || (row == NewRow - 1 && col == NewCol)) {

		board[NewRow][NewCol] = -1;
		board[row][col] = board[NewRow][NewCol];
	}
	return;",0
mpar342,1696232738,1,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) 
{
    int noRow, noCol, tileRow, tileCol;
    
    FindTile(board, -1, &noRow, &noCol);
    
    FindTile(board, tile, &tileRow, &tileCol);
    
    if ((abs(noRow - tileRow) == 1 && noCol == tileCol) || 
        (noRow == tileRow && abs(noCol - tileCol) == 1)) 
        {
        
        board[noRow][noCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}",1
mpat501,1695699011,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{

    int rPos, cPos, Posi, Posj, temperary ; 
    for (int i=0 ; i<NUM_ROWS ; i++) {
		for (int j=0 ; j<NUM_COLS ; j++) {
			if ( board[i][j] == -1 ) {
				rPos=i ;
				cPos=j ;
			}
		}
	}

	for (int i=0 ; i<NUM_ROWS ; i++) {
		for (int j=0 ; j<NUM_COLS ; j++) {
			if ( board[i][j] == tile ) {
				Posi=i ;
				Posj=j ;
			}
		}
	}

    if (rPos==Posi+1 && Posi+1<NUM_ROWS && cPos==Posj) {
        temperary=board[rPos][cPos] ;
        board[rPos][cPos] = board[Posi][Posj] ;
        board[Posi][Posj] = temperary ;
    }

    if (rPos==Posi-1 && Posi-1>-1 && cPos==Posj) {
        temperary=board[rPos][cPos] ;
        board[rPos][cPos] = board[Posi][Posj] ;
        board[Posi][Posj] = temperary ;
    }

    if (cPos==Posj+1 && Posj+1<NUM_COLS && rPos==Posi) {
        temperary=board[rPos][cPos] ;
        board[rPos][cPos] = board[Posi][Posj] ;
        board[Posi][Posj] = temperary ;
    }

    if (cPos==Posj-1 && Posj-1>-1 && rPos==Posi) {
        temperary=board[rPos][cPos] ;
        board[rPos][cPos] = board[Posi][Posj] ;
        board[Posi][Posj] = temperary ;
    }
}",1
mpey262,1695706869,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int i,j,k,l,temp;
    for (i = 0; i < NUM_ROWS; i++) {
        for (j = 0; j < NUM_COLS; j++)
        //find tile
        if (board[i][j] == tile) {
            printf(""%d and %d\n"", i, j);
            //check if empty tile is adjacent
            if (board[i-1][j] == -1) {
                temp = board[i-1][j];
                board[i][j-1] = board[i][j];
            }
            if (board[i+1][j] == -1) {
                temp = board[i+1][j];
                board[i+1][j] = board[i][j];
            }
            if (board[i][j-1] == -1) {
                temp = board[i][j-1];
                board[i][j-1] = board[i][j];
            }
            if (board[i][j+1] == -1) {
                temp = board[i][j+1];
                board[i][j+1] = board[i][j];
            }
            board[i][j] = temp;
            return; 
        }
    }   
}",0
mpey262,1695706902,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int i,j,temp;
    for (i = 0; i < NUM_ROWS; i++) {
        for (j = 0; j < NUM_COLS; j++)
        //find tile
        if (board[i][j] == tile) {
            printf(""%d and %d\n"", i, j);
            //check if empty tile is adjacent
            if (board[i-1][j] == -1) {
                temp = board[i-1][j];
                board[i][j-1] = board[i][j];
            }
            if (board[i+1][j] == -1) {
                temp = board[i+1][j];
                board[i+1][j] = board[i][j];
            }
            if (board[i][j-1] == -1) {
                temp = board[i][j-1];
                board[i][j-1] = board[i][j];
            }
            if (board[i][j+1] == -1) {
                temp = board[i][j+1];
                board[i][j+1] = board[i][j];
            }
            board[i][j] = temp;
            return; 
        }
    }   
}",0
mpey262,1695800548,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int i,j,temp = tile;
    for (i = 0; i < NUM_ROWS; i++) {
        for (j = 0; j < NUM_COLS; j++)
        //find tile
        if (board[i][j] == tile) {
            //check if empty tile is adjacent
            if (board[i-1][j] == -1 && i > 0) {
                temp = board[i-1][j];
                board[i-1][j] = board[i][j];
            }
            if (board[i+1][j] == -1 && i < 4) {
                temp = board[i+1][j];
                board[i+1][j] = board[i][j];
            }
            if (board[i][j-1] == -1 && j > 0) {
                temp = board[i][j-1];
                board[i][j-1] = board[i][j];
            }
            if (board[i][j+1] == -1 && j < 4) {
                temp = board[i][j+1];
                board[i][j+1] = board[i][j];
            }
            board[i][j] = temp;
            return; 
        }
    }   
}
",1
mran851,1696211780,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
	int rowPos, colPos;
	FindTile(board, tile, &rowPos, &colPos);


	if (rowPos < NUM_ROWS - 1 && board[rowPos + 1][colPos] == -1) {
		board[rowPos + 1][colPos] = tile;
		board[rowPos][colPos] = -1;
		return;
	}
	if (colPos < NUM_COLS - 1 && board[rowPos][colPos + 1] == -1) {
		board[rowPos][colPos + 1] = tile;
		board[rowPos][colPos] = -1;
		return;
	}
	if (colPos > 0 && board[rowPos][colPos - 1] == -1) {
		board[rowPos][colPos - 1] = tile;
		board[rowPos][colPos] = -1;
		return;
	}
	if (rowPos > 0 && board[rowPos - 1][colPos] == -1) {
		// Swap the tile with the empty square
		board[rowPos - 1][colPos] = tile;
		board[rowPos][colPos] = -1;
		return;
	}
	
}",1
mrog757,1695873792,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int j;
    int i;
    int emptyX = 0;
    int emptyY = 0;
    int tileX = 0;
    int tileY = 0;
    int tileX2 = 0;
    int tileY2 = 0;
    
    for (i=0; i<NUM_ROWS; i++) {
        for (j=0; j<NUM_COLS; j++) {
            if (board[i][j] == tile) {
                tileX = j;
                tileY = i;
            }
        }
    }
    
    for (i=0; i<NUM_ROWS; i++) {
        for (j=0; j<NUM_COLS; j++) {
            if (board[i][j] == -1) {
                emptyX = j;
                emptyY = i;
            }
        }
    }
    
    if ((emptyX == tileX + 1 || emptyX == tileX - 1) && emptyY == tileY) {
        tileX2 = emptyX;
        board[tileY][tileX2] = tile;
        board[tileY][tileX] = -1;
    }
    else if ((emptyY == tileY + 1 || emptyY == tileY - 1) && emptyX == tileX) {
        tileY2 = emptyY;
        board[tileY2][tileX] = tile;
        board[tileY][tileX] = -1;
    }

}",1
mron793,1696042485,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
  // check that input tile is valid
  if (tile < 1 || tile > 15)
  {
    return;
  }

  // swap with empty tile
  int rowPos, colPos;
  FindTile(board, tile, &rowPos, &colPos);
  int emptyRow, emptyCol;
  FindTile(board, -1, &emptyRow, &emptyCol);
  if ((rowPos == emptyRow &&
       (colPos == emptyCol + 1 || colPos == emptyCol - 1)) ||
      (colPos == emptyCol &&
       (rowPos == emptyRow + 1 || rowPos == emptyRow - 1))) {
    board[emptyRow][emptyCol] = tile;
    board[rowPos][colPos] = -1;
  }
}
",1
mshi672,1696125426,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;
	FindTile(board, tile, &row, &col);

	if ((row > 0) && ((row-1) == -1))
	{
		board[row - 1][col] = tile;
		board[row][col] = -1;
	}
	else if ((row < 3) && ((row + 1) == -1))
	{
		board[row + 1][col] = tile;
		board[row][col] = -1;
	}
	else if ((col > 0) && ((col - 1) == -1))
	{
		board[row][col - 1] = tile;
		board[row][col] = -1;
	}
	else if ((col < 3) && ((col + 1) == -1))
	{
		board[row][col + 1] = tile;
		board[row][col] = -1;
	}
}",0
mshi672,1696126320,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int trow, tcol;
	FindTile(board, tile, &trow, &tcol);

	if ((trow > 0) && (board[trow - 1] == -1))
	{
		board[trow - 1][tcol] = tile;
		board[trow][tcol] = -1;
	}
	else if ((trow < 3) && (board[trow + 1] == -1))
	{
		board[trow + 1][tcol] = tile;
		board[trow][tcol] = -1;
	}
	else if ((tcol > 0) && (board[tcol - 1] == -1))
	{
		board[trow][tcol - 1] = tile;
		board[trow][tcol] = -1;
	}
	else if ((tcol < 3) && (board[tcol + 1] == -1))
	{
		board[trow][tcol + 1] = tile;
		board[trow][tcol] = -1;
	}
}",0
msil440,1696240899,1,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

// Creating a function to locate the position of the tile on the board
void LocateTile(int board[NUM_ROWS][NUM_COLS], int targetTile, int *rowPosition, int *colPosition) {
    for (int row = 0; row < NUM_ROWS; row++) {
        for (int col = 0; col < NUM_COLS; col++) {
            if (board[row][col] == targetTile) {
                *rowPosition = row;
                *colPosition = col;
                return;
            }
        }
    }
    
    *rowPosition = -1;
    *colPosition = -1;
}",0
msil440,1696240965,2,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

// Creating a function to locate the position of the tile on the board
void LocateTile(int board[NUM_ROWS][NUM_COLS], int targetTile, int *rowPosition, int *colPosition) {
    for (int row = 0; row < NUM_ROWS; row++) {
        for (int col = 0; col < NUM_COLS; col++) {
            if (board[row][col] == targetTile) {
                *rowPosition = row;
                *colPosition = col;
                return;
            }
        }
    }
    
    *rowPosition = -1;
    *colPosition = -1;
}

// Now creating a function to make a move on the board by swapping a tile with the empty square
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol;
    int tileRow, tileCol;

    // Find the positions of the empty square and the specified tile
    LocateTile(board, -1, &emptyRow, &emptyCol);
    LocateTile(board, tile, &tileRow, &tileCol);

    // Checking to see if the specified tile is adjacent to the empty square
    if ((abs(emptyRow - tileRow) == 1 && emptyCol == tileCol) || (abs(emptyCol - tileCol) == 1 && emptyRow == tileRow)) {
        // Swap the specified tile with the empty square
        int temp = board[emptyRow][emptyCol];
        board[emptyRow][emptyCol] = board[tileRow][tileCol];
        board[tileRow][tileCol] = temp;
    }
}

// Creating a function to print the board
void DisplayBoard(int board[NUM_ROWS][NUM_COLS]) {
    for (int row = 0; row < NUM_ROWS; row++) {
        for (int col = 0; col < NUM_COLS; col++) {
            if (board[row][col] == -1) {
                printf("" _ "");
            } else {
                printf(""%2d "", board[row][col]);
            }
        }
        printf(""\n"");
    }
}

",1
msin609,1696135393,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int emptyrow, emptycol;
	int choserow, chosecol;
	int hortrue = 0;
	int verttrue = 0;

	FindTile(board, -1, &emptyrow, &emptycol);
	FindTile(board, tile, &choserow, &chosecol);

	if (choserow - 1 == emptyrow || choserow + 1 == emptyrow) {
		hortrue = 1;
	}
	if (chosecol - 1 == emptycol || chosecol + 1 == emptycol) {
		verttrue = 1;
	}
	if (verttrue + hortrue == 1) {
		board[emptyrow][emptycol] = board[choserow][chosecol];
		board[choserow][chosecol] = -1;
	}
}",0
msin609,1696136671,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int emptyrow, emptycol;
	int choserow, chosecol;
	int hortrue = 0;
	int verttrue = 0;

	FindTile(board, -1, &emptyrow, &emptycol);
	FindTile(board, tile, &choserow, &chosecol);

	if (emptyrow > 3 || emptycol > 3 || choserow > 3 || chosecol > 3) {
		return;
	}

	if (choserow - 1 == emptyrow || choserow + 1 == emptyrow) {
		hortrue = 1;
	}
	if (chosecol - 1 == emptycol || chosecol + 1 == emptycol) {
		verttrue = 1;
	}

	if (verttrue == 1 && choserow == emptyrow) {
		board[emptyrow][emptycol] = board[choserow][chosecol];
		board[choserow][chosecol] = -1;
	}
	if (hortrue == 1 && chosecol == emptycol) {
		board[emptyrow][emptycol] = board[choserow][chosecol];
		board[choserow][chosecol] = -1;
	}
}",1
msu975,1696040054,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j, posi, posj;
	for (i = 0; i < 4; i++) {
		for (j = 0; j < 4; j++) {
			if (board[j][i] == -1) {
				posj = j;
				posi = i;
			}
		}
	}

	if (tile == board[posj + 1][posi]) {
		board[posj + 1][posi] = -1;
		board[posj][posi] = tile;
	}

	else if (tile == board[posj - 1][posi]) {
		board[posj - 1][posi] = -1;
		board[posj][posi] = tile;
	}

	else if (tile == board[posj][posi + 1]) {
		board[posj][posi + 1] = -1;
		board[posj][posi] = tile;
	}

	else if (tile == board[posj][posi - 1]) {
		board[posj][posi - 1] = -1;
		board[posj][posi] = tile;
	}
}",0
msu975,1696044207,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j, posi, posj;
	for (i = 0; i < 4; i++) {
		for (j = 0; j < 4; j++) {
			if (board[j][i] == -1) {
				posj = j;
				posi = i;
			}
		}
	}

	//For valid position moves at (1,1), (1,2), (2,1) and (2,2):
	if ((posj == 1 && posi == 1) || (posj == 1 && posi == 2) || (posj == 2 && posi == 1) || (posj == 2 && posi == 2)) {
		if (tile == board[posj + 1][posi]) {
			board[posj + 1][posi] = -1;
			board[posj][posi] = tile;
		}

		else if (tile == board[posj - 1][posi]) {
			board[posj - 1][posi] = -1;
			board[posj][posi] = tile;
		}

		else if (tile == board[posj][posi + 1]) {
			board[posj][posi + 1] = -1;
			board[posj][posi] = tile;
		}

		else if (tile == board[posj][posi - 1]) {
			board[posj][posi - 1] = -1;
			board[posj][posi] = tile;
		}
	}

	//For valid position moves at (0,0):
	else if ((posj == 0 && posi == 0)) {
		if (tile == board[posj + 1][posi]) {
			board[posj + 1][posi] = -1;
			board[posj][posi] = tile;
		}

		else if (tile == board[posj][posi + 1]) {
			board[posj][posi + 1] = -1;
			board[posj][posi] = tile;
		}
	}

	//For valid position moves at (0,3):
	else if ((posj == 0 && posi == 3)) {
		if (tile == board[posj + 1][posi]) {
			board[posj + 1][posi] = -1;
			board[posj][posi] = tile;
		}

		else if (tile == board[posj][posi - 1]) {
			board[posj][posi - 1] = -1;
			board[posj][posi] = tile;
		}
	}

	//For valid position moves at (3,0):
	else if ((posj == 3 && posi == 0)) {
		if (tile == board[posj - 1][posi]) {
			board[posj - 1][posi] = -1;
			board[posj][posi] = tile;
		}

		else if (tile == board[posj][posi + 1]) {
			board[posj][posi + 1] = -1;
			board[posj][posi] = tile;
		}
	}

	//For valid position moves at (3,3):
	else if ((posj == 3 && posi == 3)) {
		if (tile == board[posj - 1][posi]) {
			board[posj - 1][posi] = -1;
			board[posj][posi] = tile;
		}

		else if (tile == board[posj][posi - 1]) {
			board[posj][posi - 1] = -1;
			board[posj][posi] = tile;
		}
	}

	//For valid position moves at (0,1) and (0,2):
	else if ((posj == 0 && posi == 1) || (posj == 0 && posi == 2)) {
		if (tile == board[posj][posi - 1]) {
			board[posj][posi - 1] = -1;
			board[posj][posi] = tile; 
		}

		else if (tile == board[posj][posi + 1]) {
			board[posj][posi + 1] = -1;
			board[posj][posi] = tile;
		}

		else if (tile == board[posj + 1][posi]) {
			board[posj + 1][posi] = -1;
			board[posj][posi] = tile;
		}
	}

	//For valid position moves at (1,0) and (2,0):
	else if ((posj == 1 && posi == 0) || (posj == 2 && posi == 0)) {
		if (tile == board[posj + 1][posi]) {
			board[posj + 1][posi] = -1;
			board[posj][posi] = tile;
		}

		else if (tile == board[posj - 1][posi]) {
			board[posj - 1][posi] = - 1;
			board[posj][posi] = tile;
		}

		else if (tile == board[posj][posi + 1]) {
			board[posj][posi + 1] = -1;
			board[posj][posi] = tile;
		}
	}

	//For valid position moves at (1,3) and (2,3):
	else if ((posj == 1 && posi == 3) || (posj == 2 && posi == 3)) {
		if (tile == board[posj + 1][posi]) {
			board[posj + 1][posi] = -1;
			board[posj][posi] = tile;
		}

		else if (tile == board[posj - 1][posi]) {
			board[posj - 1][posi] = -1;
			board[posj][posi] = tile;
		}

		else if (tile == board[posj][posi - 1]) {
			board[posj][posi - 1] = -1;
			board[posj][posi] = tile;
		}	
	}

	//For valid position moves at (3,1) and (3,2):
	else if ((posj == 3 && posi == 1) || (posj == 3 && posi == 2)) {
		if (tile == board[posj][posi - 1]) {
			board[posj][posi - 1] = -1;
			board[posj][posi] = tile;
		}

		else if (tile == board[posj][posi + 1]) {
			board[posj][posi + 1] = -1;
			board[posj][posi] = tile;
		}

		else if (tile == board[posj - 1][posi]) {
			board[posj - 1][posi] = -1;
			board[posj][posi] = tile;
		}
	}	
}",1
msuv992,1696234375,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col, inrow, incol; 
    
    FindTile(board, -1, &row, &col);
    FindTile(board, tile, &inrow, &incol);
     

    if (((row - inrow == 1)  && (col == incol)) || ((col - incol == 1) && (row == inrow)) || (((row - inrow == -1)) && (col == incol)) || ((col - incol == -1 ) && (row == inrow))) {
            board[row][col] = tile;
            board[inrow][incol] = -1;
        }
        
    
}",1
mtam709,1696221439,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    
    int r_blank, c_blank;
    FindTile(board, -1, &r_blank, &c_blank);
    
    int r_swap, c_swap;
    FindTile(board, tile, &r_swap, &c_swap);
    
    if (r_swap == r_blank - 1 || r_swap == r_blank + 1 && c_swap == c_blank - 1 || c_swap == c_blank + 1) {
        // swap
        board[r_blank][c_blank] = board[r_swap][c_swap];
        board[r_swap][c_swap] = -1;
        return;
        }
    }
    
}",0
mtam709,1696225012,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    
    int r_blank, c_blank;
    FindTile(board, -1, &r_blank, &c_blank);
    
    int r_swap, c_swap;
    FindTile(board, tile, &r_swap, &c_swap);
    
    if (r_swap == r_blank - 1 || r_swap == r_blank + 1 && c_swap == c_blank - 1 || c_swap == c_blank + 1) {
        // swap
        int *pos_blank;
        int *pos_swap;
        
        pos_blank = &board[r_blank][c_blank];
        pos_swap = &board[r_swap][c_swap];
        
        *pos_blank = tile;
        *pos_swap = -1;
    }

}",0
mtam709,1696225157,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    
    int r_blank, c_blank;
    FindTile(board, -1, &r_blank, &c_blank);
    
    int r_swap, c_swap;
    FindTile(board, tile, &r_swap, &c_swap);
    
    if ((r_swap == r_blank - 1 || r_swap == r_blank + 1 ) && ( c_swap == c_blank - 1 || c_swap == c_blank + 1)) {
        // swap
        int *pos_blank;
        int *pos_swap;
        
        pos_blank = &board[r_blank][c_blank];
        pos_swap = &board[r_swap][c_swap];
        
        *pos_blank = tile;
        *pos_swap = -1;
    }

}",0
mtam709,1696227063,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int r_blank, c_blank;
    FindTile(board, -1, &r_blank, &c_blank);
    
    int r_swap, c_swap;
    FindTile(board, tile, &r_swap, &c_swap);
    
    if (((r_swap == r_blank) && (abs(c_swap - c_blank) == 1)) || ((c_swap == c_blank) &&(abs(r_swap - r_blank) == 1))) {
        //swap
        int *pos_blank;
        int *pos_swap;
        
        pos_blank = &board[r_blank][c_blank];
        pos_swap = &board[r_swap][c_swap];
        
        *pos_blank = tile;
        *pos_swap = -1;
    }

}",1
mtha724,1695970510,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tilerow, tilecol, row, col;
	FindTile(board, tile, &tilerow, &tilecol);
	FindTile(board, -1, &row, &col);
	if ((((row == tilerow) && ((col + 1 == tilecol) || (col - 1 == tilecol))) || ((col == tilecol) && ((row + 1 == tilerow) || (row - 1 == tilerow)))))
	{
		board[row][col] = tile;
		board[tilerow][tilecol] = -1;
	}
}",1
mtob213,1696136937,1,"/* This function should swap the specified tile with the empty square */
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tileRow, tileCol, emptyRow, emptyCol;
    
    // Locate the position of the specified tile and empty square
	FindTile(board, tile, &tileRow, &tileCol);
	FindTile(board, -1, &emptyRow, &emptyCol);
    
    // Check if the empty square is adjacent to the specified tile
	if ((emptyCol - tileCol) + (emptyRow - tileRow) == 1) 
	{
        board[tileRow][tileCol] = -1; // Specified tile becomes the empty square
		board[emptyRow][emptyCol] = tile; // Empty square becomes the specified tile
    // If the tiles are not adjacent, the board does not change
	}
}",0
mtob213,1696137330,2,"/* This function should swap the specified tile with the empty square */
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tileRow, tileCol, emptyRow, emptyCol;
    
    // Locate the position of the specified tile and empty square
	FindTile(board, tile, &tileRow, &tileCol);
	FindTile(board, -1, &emptyRow, &emptyCol);
    
    // Check if the empty square is adjacent to the specified tile
	if (((emptyCol - tileCol) + (emptyRow - tileRow) == 1) || ((emptyCol - tileCol) + (emptyRow - tileRow) == -1))
	{
        board[tileRow][tileCol] = -1; // Specified tile becomes the empty square
		board[emptyRow][emptyCol] = tile; // Empty square becomes the specified tile
    // If the tiles are not adjacent, the board does not change
	}
}",1
mwan364,1695794122,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
	int row, col, adj_row, adj_col;
	
	FindTile(board, -1, &row, &col);
	FindTile(board, tile, &adj_row, &adj_col);

		if ((adj_col == col && (adj_row == row + 1 || adj_row == row - 1)) ||
			(adj_row == row && (adj_col == col + 1 || adj_col == col - 1))) {
			
			board[row][col] = tile;
			board[adj_row][adj_col] = -1;
		}
		else {
			return;
		}
}",1
myou984,1695701102,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;
	int *rowPos = &row;
	int *colPos = &col;
	FindTile(board, tile, rowPos, colPos);
    if ((board[row-1][col] != -1) && (board[row][col-1] != -1) && (board[row+1][col] != -1) && (board[row][col+1] != -1)) {
		return;
	}
	if (row > 0) {
		if (board[row-1][col] == -1) {
			board[row-1][col] = tile;
			board[row][col] = -1;
		}
	}
	if (col > 0) {
		if (board[row][col-1] == -1) {
			board[row][col-1] = tile;
			board[row][col] = -1;
		}
	}
	if (row < NUM_ROWS) {
		if (board[row+1][col] == -1) {
			board[row+1][col] = tile;
			board[row][col] = -1;
		}
	}
	if (col < NUM_COLS) {
		if (board[row][col+1] == -1) {
			board[row][col+1] = tile;
			board[row][col] = -1;
		}
	}
}",1
mzha612,1695697392,1,"
// MakeMove moves the tiles if its a valid move
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowblank, colblank;
	int rownum, colnum;

	 //Identifying the location of the blank and tile position
	FindTile(board, -1, &rowblank, &colblank);
	FindTile(board, tile, &rownum, &colnum);



	int r = rownum - rowblank;
	int c = colnum - colblank ;

	board[rownum - r*(c <= 1 && c >= -1 && r <= 1 && r >= -1)*((r == 1 || r == -1) && c == 0)][colnum -c * (c <= 1 && c >= -1  && r <= 1 && r >= -1) * ((c == 1 || c == -1) && r == 0)] = board[rownum][colnum];
	board[rownum][colnum] = ((c == 1 || c == -1) && r == 0) ^ ((r == 1 || r == -1) && c == 0) ? -1 : board[rownum][colnum];

}

",1
mzha612,1696208499,2,"
// MakeMove moves the tiles if its a valid move
// void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
// {
// 	int rowblank, colblank;
// 	int rownum, colnum;

// 	 //Identifying the location of the blank and tile position
// 	FindTile(board, -1, &rowblank, &colblank);
// 	FindTile(board, tile, &rownum, &colnum);



// 	int r = rownum - rowblank;
// 	int c = colnum - colblank ;

// 	board[rownum - r*(c <= 1 && c >= -1 && r <= 1 && r >= -1)*((r == 1 || r == -1) && c == 0)][colnum -c * (c <= 1 && c >= -1  && r <= 1 && r >= -1) * ((c == 1 || c == -1) && r == 0)] = board[rownum][colnum];
// 	board[rownum][colnum] = ((c == 1 || c == -1) && r == 0) ^ ((r == 1 || r == -1) && c == 0) ? -1 : board[rownum][colnum];

// }

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) { int tileRow, tileCol, spaceRow, spaceCol; FindTile(board, tile, &tileRow, &tileCol); FindTile(board, -1, &spaceRow, &spaceCol); if (tile < 1 || tile > 15) { return; } else if ((tileRow == spaceRow && tileCol == spaceCol - 1) || (tileRow == spaceRow && tileCol == spaceCol + 1) || (tileCol == spaceCol && tileRow == spaceCol - 1) || (tileCol == spaceCol && tileRow == spaceCol + 1)) { int *spacept = *(board + spaceRow) + spaceCol; int *tilept = *(board + tileRow) + tileCol; *spacept = tile; *tilept = -1; return; } else { return; } }",0
mzha612,1696208519,3,"
// MakeMove moves the tiles if its a valid move
// void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
// {
// 	int rowblank, colblank;
// 	int rownum, colnum;

// 	 //Identifying the location of the blank and tile position
// 	FindTile(board, -1, &rowblank, &colblank);
// 	FindTile(board, tile, &rownum, &colnum);



// 	int r = rownum - rowblank;
// 	int c = colnum - colblank ;

// 	board[rownum - r*(c <= 1 && c >= -1 && r <= 1 && r >= -1)*((r == 1 || r == -1) && c == 0)][colnum -c * (c <= 1 && c >= -1  && r <= 1 && r >= -1) * ((c == 1 || c == -1) && r == 0)] = board[rownum][colnum];
// 	board[rownum][colnum] = ((c == 1 || c == -1) && r == 0) ^ ((r == 1 || r == -1) && c == 0) ? -1 : board[rownum][colnum];

// }
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) { int tileRow, tileCol, spaceRow, spaceCol; FindTile(board, tile, &tileRow, &tileCol); FindTile(board, -1, &spaceRow, &spaceCol); if (tile < 1 || tile > 15) { return; } else if (tileRow == spaceRow && tileCol == spaceCol - 1 || tileRow == spaceRow && tileCol == spaceCol + 1 || tileCol == spaceCol && tileRow == spaceCol - 1 || tileCol == spaceCol && tileRow == spaceCol + 1) { int *spacept = *(board + spaceRow) + spaceCol; int *tilept = *(board + tileRow) + tileCol; *spacept = tile; *tilept = -1; return; } else { return; } }",0
mzha612,1696208544,4,"
// MakeMove moves the tiles if its a valid move
// void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
// {
// 	int rowblank, colblank;
// 	int rownum, colnum;

// 	 //Identifying the location of the blank and tile position
// 	FindTile(board, -1, &rowblank, &colblank);
// 	FindTile(board, tile, &rownum, &colnum);



// 	int r = rownum - rowblank;
// 	int c = colnum - colblank ;

// 	board[rownum - r*(c <= 1 && c >= -1 && r <= 1 && r >= -1)*((r == 1 || r == -1) && c == 0)][colnum -c * (c <= 1 && c >= -1  && r <= 1 && r >= -1) * ((c == 1 || c == -1) && r == 0)] = board[rownum][colnum];
// 	board[rownum][colnum] = ((c == 1 || c == -1) && r == 0) ^ ((r == 1 || r == -1) && c == 0) ? -1 : board[rownum][colnum];

// }
// void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) { int tileRow, tileCol, spaceRow, spaceCol; FindTile(board, tile, &tileRow, &tileCol); FindTile(board, -1, &spaceRow, &spaceCol); if (tile < 1 || tile > 15) { return; } else if (tileRow == spaceRow && tileCol == spaceCol - 1 || tileRow == spaceRow && tileCol == spaceCol + 1 || tileCol == spaceCol && tileRow == spaceCol - 1 || tileCol == spaceCol && tileRow == spaceCol + 1) { int *spacept = *(board + spaceRow) + spaceCol; int *tilept = *(board + tileRow) + tileCol; *spacept = tile; *tilept = -1; return; } else { return; } }
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) { int tileRow, tileCol, spaceRow, spaceCol; FindTile(board, tile, &tileRow, &tileCol); FindTile(board, -1, &spaceRow, &spaceCol); if (tile < 1 || tile > 15) { return; } else if ((tileRow == spaceRow) && (tileCol == spaceCol - 1) || (tileRow == spaceRow) && (tileCol == spaceCol + 1) || (tileCol == spaceCol) && (tileRow == spaceCol - 1) || (tileCol == spaceCol) && (tileRow == spaceCol + 1)) { int *spacept = *(board + spaceRow) + spaceCol; int *tilept = *(board + tileRow) + tileCol; *spacept = tile; *tilept = -1; return; } else { return; } }",0
mzha612,1696208554,5,"
// MakeMove moves the tiles if its a valid move
// void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
// {
// 	int rowblank, colblank;
// 	int rownum, colnum;

// 	 //Identifying the location of the blank and tile position
// 	FindTile(board, -1, &rowblank, &colblank);
// 	FindTile(board, tile, &rownum, &colnum);



// 	int r = rownum - rowblank;
// 	int c = colnum - colblank ;

// 	board[rownum - r*(c <= 1 && c >= -1 && r <= 1 && r >= -1)*((r == 1 || r == -1) && c == 0)][colnum -c * (c <= 1 && c >= -1  && r <= 1 && r >= -1) * ((c == 1 || c == -1) && r == 0)] = board[rownum][colnum];
// 	board[rownum][colnum] = ((c == 1 || c == -1) && r == 0) ^ ((r == 1 || r == -1) && c == 0) ? -1 : board[rownum][colnum];

// }
// void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) { int tileRow, tileCol, spaceRow, spaceCol; FindTile(board, tile, &tileRow, &tileCol); FindTile(board, -1, &spaceRow, &spaceCol); if (tile < 1 || tile > 15) { return; } else if (tileRow == spaceRow && tileCol == spaceCol - 1 || tileRow == spaceRow && tileCol == spaceCol + 1 || tileCol == spaceCol && tileRow == spaceCol - 1 || tileCol == spaceCol && tileRow == spaceCol + 1) { int *spacept = *(board + spaceRow) + spaceCol; int *tilept = *(board + tileRow) + tileCol; *spacept = tile; *tilept = -1; return; } else { return; } }
// void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) { int tileRow, tileCol, spaceRow, spaceCol; FindTile(board, tile, &tileRow, &tileCol); FindTile(board, -1, &spaceRow, &spaceCol); if (tile < 1 || tile > 15) { return; } else if ((tileRow == spaceRow) && (tileCol == spaceCol - 1) || (tileRow == spaceRow) && (tileCol == spaceCol + 1) || (tileCol == spaceCol) && (tileRow == spaceCol - 1) || (tileCol == spaceCol) && (tileRow == spaceCol + 1)) { int *spacept = *(board + spaceRow) + spaceCol; int *tilept = *(board + tileRow) + tileCol; *spacept = tile; *tilept = -1; return; } else { return; } }
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) { int tileRow, tileCol, spaceRow, spaceCol; FindTile(board, tile, &tileRow, &tileCol); FindTile(board, -1, &spaceRow, &spaceCol); if (tileRow == spaceRow - 1 || tileRow == spaceRow + 1 || tileCol == spaceCol - 1 || tileCol == spaceCol + 1) { int* spacept = *(board + spaceRow) + spaceCol; int* tilept = *(board + tileRow) + tileCol; *spacept = tile; *tilept = -1; } else { return; } }",0
mzha612,1696208565,6,"
// MakeMove moves the tiles if its a valid move
// void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
// {
// 	int rowblank, colblank;
// 	int rownum, colnum;

// 	 //Identifying the location of the blank and tile position
// 	FindTile(board, -1, &rowblank, &colblank);
// 	FindTile(board, tile, &rownum, &colnum);



// 	int r = rownum - rowblank;
// 	int c = colnum - colblank ;

// 	board[rownum - r*(c <= 1 && c >= -1 && r <= 1 && r >= -1)*((r == 1 || r == -1) && c == 0)][colnum -c * (c <= 1 && c >= -1  && r <= 1 && r >= -1) * ((c == 1 || c == -1) && r == 0)] = board[rownum][colnum];
// 	board[rownum][colnum] = ((c == 1 || c == -1) && r == 0) ^ ((r == 1 || r == -1) && c == 0) ? -1 : board[rownum][colnum];

// }
// void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) { int tileRow, tileCol, spaceRow, spaceCol; FindTile(board, tile, &tileRow, &tileCol); FindTile(board, -1, &spaceRow, &spaceCol); if (tile < 1 || tile > 15) { return; } else if (tileRow == spaceRow && tileCol == spaceCol - 1 || tileRow == spaceRow && tileCol == spaceCol + 1 || tileCol == spaceCol && tileRow == spaceCol - 1 || tileCol == spaceCol && tileRow == spaceCol + 1) { int *spacept = *(board + spaceRow) + spaceCol; int *tilept = *(board + tileRow) + tileCol; *spacept = tile; *tilept = -1; return; } else { return; } }
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) { int tileRow, tileCol, spaceRow, spaceCol; FindTile(board, tile, &tileRow, &tileCol); FindTile(board, -1, &spaceRow, &spaceCol); if (tile < 1 || tile > 15) { return; } else if ((tileRow == spaceRow) && (tileCol == spaceCol - 1) || (tileRow == spaceRow) && (tileCol == spaceCol + 1) || (tileCol == spaceCol) && (tileRow == spaceCol - 1) || (tileCol == spaceCol) && (tileRow == spaceCol + 1)) { int *spacept = *(board + spaceRow) + spaceCol; int *tilept = *(board + tileRow) + tileCol; *spacept = tile; *tilept = -1; return; } else { return; } }
// void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) { int tileRow, tileCol, spaceRow, spaceCol; FindTile(board, tile, &tileRow, &tileCol); FindTile(board, -1, &spaceRow, &spaceCol); if (tileRow == spaceRow - 1 || tileRow == spaceRow + 1 || tileCol == spaceCol - 1 || tileCol == spaceCol + 1) { int* spacept = *(board + spaceRow) + spaceCol; int* tilept = *(board + tileRow) + tileCol; *spacept = tile; *tilept = -1; } else { return; } }",0
nabr105,1695775241,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) 
{
    int rowPos, colPos;
    // Search for the tile
    FindTile(board, tile, &rowPos, &colPos);
	printf(""Row chosen: %d, Col Chosen: %d - check COLS: %d\n"", rowPos, colPos, (NUM_COLS-1));

    // Check the eligibility of the placement (it should be one below, above, left and right)
    if (rowPos > 0) { // Checking if there is a row above
		// Check if the tile above is a blank
		if (board[rowPos-1][colPos] == -1) {
			// Switch positions
			board[rowPos-1][colPos] = tile; 
			board[rowPos][colPos] = -1;
		}
	}
	if (rowPos > 0) { // Checking if there is a row above
		// Check if the tile above is a blank
		if (board[rowPos-1][colPos] == -1) {
			// Switch positions
			board[rowPos-1][colPos] = tile; 
			board[rowPos][colPos] = -1;
		}
	}

	if (colPos > 0) { // Checking if there is a column to the left
		// Check if the tile to the left is a blank
		if (board[rowPos][colPos-1] == -1) {
			// Switch positions
			board[rowPos][colPos-1] = tile; 
			board[rowPos][colPos] = -1;
		}
	}
	if (rowPos < (NUM_ROWS-1)) { // Checking if there is a row below
		// Check if the tile above is a blank
		if (board[rowPos+1][colPos] == -1) {
			// Switch positions
			board[rowPos+1][colPos] = tile; 
			board[rowPos][colPos] = -1;
		}
	}
	if (colPos < (NUM_COLS-1)) { // Checking if there is a row to the right
		// Check if the tile above is a blank
		if (board[rowPos][colPos+1] == -1) {
			// Switch positions
			board[rowPos][colPos+1] = tile; 
			board[rowPos][colPos] = -1;
		}
	}
}",0
nabr105,1695775270,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) 
{
    int rowPos, colPos;
    // Search for the tile
    FindTile(board, tile, &rowPos, &colPos);

    // Check the eligibility of the placement (it should be one below, above, left and right)
    if (rowPos > 0) { // Checking if there is a row above
		// Check if the tile above is a blank
		if (board[rowPos-1][colPos] == -1) {
			// Switch positions
			board[rowPos-1][colPos] = tile; 
			board[rowPos][colPos] = -1;
		}
	}
	if (rowPos > 0) { // Checking if there is a row above
		// Check if the tile above is a blank
		if (board[rowPos-1][colPos] == -1) {
			// Switch positions
			board[rowPos-1][colPos] = tile; 
			board[rowPos][colPos] = -1;
		}
	}

	if (colPos > 0) { // Checking if there is a column to the left
		// Check if the tile to the left is a blank
		if (board[rowPos][colPos-1] == -1) {
			// Switch positions
			board[rowPos][colPos-1] = tile; 
			board[rowPos][colPos] = -1;
		}
	}
	if (rowPos < (NUM_ROWS-1)) { // Checking if there is a row below
		// Check if the tile above is a blank
		if (board[rowPos+1][colPos] == -1) {
			// Switch positions
			board[rowPos+1][colPos] = tile; 
			board[rowPos][colPos] = -1;
		}
	}
	if (colPos < (NUM_COLS-1)) { // Checking if there is a row to the right
		// Check if the tile above is a blank
		if (board[rowPos][colPos+1] == -1) {
			// Switch positions
			board[rowPos][colPos+1] = tile; 
			board[rowPos][colPos] = -1;
		}
	}
}",1
nalg484,1695766773,1,"#include <stdio.h>
#define NUMS_ROWS 3
#define NUMS_COLS 3
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
  int row = -1, col = -1, rows = -1, cols = -1;
  int i = 0 j = 0
   while (i < NUM_ROWS && rows == -1) {
        j = 0;
        while (j < NUM_COLS && cols == -1) {
            if (board[i][j] == -1) {
                row = i, col = j;
            }
            if (board[i][j] == tile) {
                rows = i, cols = j;
            }
            j++;
        }
        i++;
    }
}",0
nalg484,1695766782,2,"#include <stdio.h>
#define NUMS_ROWS 3
#define NUMS_COLS 3
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
  int row = -1, col = -1, rows = -1, cols = -1;
  int i = 0, j = 0
   while (i < NUM_ROWS && rows == -1) {
        j = 0;
        while (j < NUM_COLS && cols == -1) {
            if (board[i][j] == -1) {
                row = i, col = j;
            }
            if (board[i][j] == tile) {
                rows = i, cols = j;
            }
            j++;
        }
        i++;
    }
}",0
nalg484,1695766851,3,"#include <stdio.h>
#define NUMS_ROWS 3
#define NUMS_COLS 3
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
  int row = -1, col = -1, rows = -1, cols = -1;
  int i = 0, j = 0;
   while (i < NUM_ROWS && rows == -1) {
        j = 0;
        while (j < NUM_COLS && cols == -1) {
            if (board[i][j] == -1) {
                row = i, col = j;
            }
            if (board[i][j] == tile) {
                rows = i, cols = j;
            }
            j++;
        }
        i++;
    }
}",0
nalg484,1695767040,4,"#include <stdio.h>
#define NUM_ROWS 3
#define NUM_COLS 3
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int i = 0, j = 0;
    while (i < NUM_ROWS && rows == -1) {
        j = 0;
        while (j < NUM_COLS && cols == -1) {
            if (board[i][j] == -1) {
            }
            if (board[i][j] == tile) {
            }
            j++;
        }
        i++;
    }
}",0
nalg484,1695767168,5,"#include <stdio.h>
#define NUM_ROWS 3
#define NUM_COLS 3
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row = -1, col = -1, rows = -1, cols = -1;
    int i = 0, j = 0;
    while (i < NUM_ROWS && rows == -1) {
        j = 0;
        while (j < NUM_COLS && cols == -1) {
            if (board[i][j] == -1) {
                row = i, col = j;
            }
            if (board[i][j] == tile) {
                rows = i, cols = j;
            }
            j++;
        }
        i++;
    }
}",0
nask472,1695787083,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int num_row, num_col; 
    FindTile(board, tile, &num_row, &num_col );
    
	//If the input number is not in row 0, then check if -1 is in the row above it
    if (num_row != 0){
        if( board[num_row - 1][num_col] == -1){
            board[num_row - 1][num_col] = board[num_row][num_col];
            board[num_row][num_col]= -1;
        }
    }
	//If the input number is not in column 0, check if -1 is in the column to the left
    if (num_col != 0){
        if (board[num_row][num_col - 1] == -1)  {
            //SWAP THE 2 
            board[num_row][num_col - 1]= board[num_row][num_col];
            board[num_row][num_col]= -1;
        }
    }
// PrintBoard(board);
//If the input number is not in the last row check if -1 is in the row below
    if (num_row != (NUM_ROWS-1))
    {
        if( board[num_row + 1][num_col] == -1){
            board[num_row + 1][num_col] = board[num_row][num_col];
            board[num_row][num_col]= -1;
        }
    }
// PrintBoard(board);
// if the input number is not in the last column, check if 
//there is -1 in the column to the right
    if (num_col != (NUM_COLS-1))
    {
        if( board[num_row][num_col + 1] == -1){
            board[num_row ][num_col +1] = board[num_row][num_col];
            board[num_row][num_col]= -1;
        }
    }
	// PrintBoard(board);
}",1
ncha509,1695772616,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col, a, b;
    for (row=0;row<NUM_ROWS;row++){
        for (col=0;col<NUM_COLS;col++){
            if (board[row][col]==tile){
                a=row;
                b=col;
            }
        }
    }
    if (board[a][(b-1)]==-1 && b!=0){
        board[a][b]=-1;
        board[a][(b-1)]=tile;
    }
    else if (board[(a-1)][(b)]==-1&& (a-1)>0){
        board[a][b]=-1;
        board[a-1][(b)]=tile;        
    }
    else if (board[a][(b+1)]==-1 && b!=(NUM_COLS-1)){
        board[a][b]=-1;
        board[a][(b+1)]=tile;          
    }
    else if (board[a+1][(b)]==-1){
        board[a][b]=-1;
        board[a+1][b]=tile;         
    }
}",0
ncha509,1695772970,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col, a, b;
    for (row=0;row<NUM_ROWS;row++){
        for (col=0;col<NUM_COLS;col++){
            if (board[row][col]==tile){
                a=row;
                b=col;
            }
        }
    }
    if (board[a][(b-1)]==-1 && b!=0){
        board[a][b]=-1;
        board[a][(b-1)]=tile;
    }
    else if (board[(a-1)][(b)]==-1){
        board[a][b]=-1;
        board[a-1][(b)]=tile;        
    }
    else if (board[a][(b+1)]==-1 && b!=(NUM_COLS-1)){
        board[a][b]=-1;
        board[a][(b+1)]=tile;          
    }
    else if (board[a+1][(b)]==-1){
        board[a][b]=-1;
        board[a+1][b]=tile;         
    }
}",1
ndas832,1696069714,1,"#include <stdio.h>
#define NUM_ROWS 4 
#define NUM_COLS 4
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    // tilerow/tilecol represents the row/col the number tile is in, 
    //and emptyRow/emptyCol represents the row/col that -1 is in (which is an empty space)
    int tilerow, tilecol, emptyRow, emptyCol; 
    
    //The FindTile Function is used to find where the tile and -1 (empty space) are positioned on the board
    FindTile(board,tile, &tilerow, &tilecol); 
    FindTile(board, -1, &emptyRow, &emptyCol); 
    
    //Write a Boolean expression to determine horizontal movement of the tile
    if (tilerow == emptyRow && (tilecol == emptyCol+1 || tilecol == emptyCol-1)) {
        board[emptyRow][emptyCol] = tile; 
        board[tilerow][tilecol] = -1; 
    }
    
    //Write a Boolean expression to determine vertical movement of the tile
    if (tilecol == emptyCol && (tilerow == emptyRow+1 || tilerow == emptyRow-1)) {
        board[emptyRow][emptyCol] = tile; 
        board[tilerow][tilecol] = -1;  
    }
}",1
ndso791,1696138419,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	FindTile(board, -1, &row, &col);
	FindTile(board, tile, &newR, &newC);
	if ((row - newR == 1 || -1) && (col - newC == 1 || -1))
	{
		board[row][col] = tile;
		board[newR][newC] = -1;
	}
}",0
ndso791,1696138511,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, newR, newC;
	FindTile(board, -1, &row, &col);
	FindTile(board, tile, &newR, &newC);
	if ((row - newR == 1 || -1) && (col - newC == 1 || -1))
	{
		board[row][col] = tile;
		board[newR][newC] = -1;
	}
}",0
ndso791,1696197510,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, newR, newC;
	FindTile(board, -1, &row, &col);
	FindTile(board, tile, &newR, &newC);
	int checkR = (newR - row == -1 || 1);
	int checkC = (newC - col == -1 || 1);
	if (checkR + checkC > 0)
	{
		board[row][col] = tile;
		board[newR][newC] = -1;
	}
}",0
ngam724,1696218460,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
	int emptyRow, emptyCol;
	FindTile(board, -1, &emptyRow, &emptyCol);
	
	if (tile < 1 || tile > 15) {
		printf(""Enter a number between 1 and 15.\n"");
		return 0; 
	}

	int moveRow = -1, moveCol = -1;
	for (int i = 0; i < NUM_ROWS; i++) {
		for (int j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == tile) {
				moveRow = i;
				moveCol = j;
				break;
			}
		}
	}

	if (moveRow == -1 || moveCol == -1) {
		printf(""The selected number is not on the board.\n"");
		return 0;
	}

	if ((moveRow == emptyRow && (moveCol == emptyCol - 1 || moveCol == emptyCol + 1)) ||
		(moveCol == emptyCol && (moveRow == emptyRow - 1 || moveRow == emptyRow + 1))) {
		
		board[emptyRow][emptyCol] = tile;
		board[moveRow][moveCol] = -1; 
		return 1; 
	}
	else {
		printf(""This number cannot be moved.\n"");
		return 0;
	}
}",0
ngam724,1696219711,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
	int emptyRow, emptyCol;
	FindTile(board, -1, &emptyRow, &emptyCol);
	
	int moveRow = -1, moveCol = -1;
	for (int i = 0; i < NUM_ROWS; i++) {
		for (int j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == tile) {
				moveRow = i;
				moveCol = j;
			}
		}
	}

	if (moveRow == -1 || moveCol == -1) {
		printf(""This number cannot be moved.\n"");
		return 0;
	}

	if ((moveRow == emptyRow && (moveCol == emptyCol - 1 || moveCol == emptyCol + 1)) ||
		(moveCol == emptyCol && (moveRow == emptyRow - 1 || moveRow == emptyRow + 1))) {
		
		board[emptyRow][emptyCol] = tile;
		board[moveRow][moveCol] = -1; 
		return 1; 
	}
	else {
		printf(""This number cannot be moved.\n"");
		return 0;
	}
}",0
ngam724,1696220200,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
	int emptyRow, emptyCol;
	FindTile(board, -1, &emptyRow, &emptyCol);
	
	int moveRow = -1, moveCol = -1;
	for (int i = 0; i < NUM_ROWS; i++) {
		for (int j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == tile) {
				moveRow = i;
				moveCol = j;
			}
		}
	}

	if (moveRow == -1 || moveCol == -1) {
		printf(""This number cannot be moved.\n"");
	}

	if ((moveRow == emptyRow && (moveCol == emptyCol - 1 || moveCol == emptyCol + 1)) ||
		(moveCol == emptyCol && (moveRow == emptyRow - 1 || moveRow == emptyRow + 1))) {
		
		board[emptyRow][emptyCol] = tile;
		board[moveRow][moveCol] = -1; 
		
	}
	else {
		printf(""This number cannot be moved.\n"");
	
	}
}",0
ngam724,1696220348,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
	int emptyRow, emptyCol;
	FindTile(board, -1, &emptyRow, &emptyCol);
	
	int moveRow = -1, moveCol = -1;
	for (int i = 0; i < NUM_ROWS; i++) {
		for (int j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == tile) {
				moveRow = i;
				moveCol = j;
			}
		}
	}

	if ((moveRow == emptyRow && (moveCol == emptyCol - 1 || moveCol == emptyCol + 1)) ||
		(moveCol == emptyCol && (moveRow == emptyRow - 1 || moveRow == emptyRow + 1))) {
		
		board[emptyRow][emptyCol] = tile;
		board[moveRow][moveCol] = -1; 
		
	}
}",1
ngan146,1696235365,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int r = 0;
	int c = 0;

	FindTile(board, -1, &r, &c);

	if(r != -1 && board[r-1][c] == -1) {
		board[r-1][c] = tile;
		board[r][c] = -1;
	}else if(board[r+1][c] == -1) {
		board[r+1][c] = tile;
		board[r][c] =-1;
	}else if(board[r][c-1] == -1) {
		board[r][c-1] = tile;
		board[r][c] = - 1;
	}else if(board[r][c+1] == -1) {
		board[r][c+1] = tile
		board[r][c] = -1
	}
}",0
ngan146,1696235385,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int r = 0;
	int c = 0;

	FindTile(board, -1, &r, &c);

	if(r != -1 && board[r-1][c] == -1) {
		board[r-1][c] = tile;
		board[r][c] = -1;
	}else if(board[r+1][c] == -1) {
		board[r+1][c] = tile;
		board[r][c] =-1;
	}else if(board[r][c-1] == -1) {
		board[r][c-1] = tile;
		board[r][c] = - 1;
	}else if(board[r][c+1] == -1) {
		board[r][c+1] = tile;
		board[r][c] = -1;
	}
}",0
ngan146,1696235727,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int r = 0;
	int c = 0;

	FindTile(board, -1, &r, &c);

	if(r > 0 && board[r-1][c] == -1) {
		board[r-1][c] = tile;
		board[r][c] = -1;
	}else if(board[r+1][c] == -1) {
		board[r+1][c] = tile;
		board[r][c] =-1;
	}else if( c > 0 && board[r][c-1] == -1) {
		board[r][c-1] = tile;
		board[r][c] = - 1;
	}else if(board[r][c+1] == -1) {
		board[r][c+1] = tile
		board[r][c] = -1;
	}
}",0
ngan146,1696235894,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int r = 0;
	int c = 0;

	FindTile(board, -1, &r, &c);

	
	if( c != 0 && board[r][c-1] == -1) {
		board[r][c-1] = tile;
		board[r][c] = - 1;
	}else if(c != NUM_COLS && [r][c+1] == -1) {
		board[r][c+1] = tile;
		board[r][c] = -1;
	}else if(r != 0 && board[r-1][c] == -1) {
		board[r-1][c] = tile;
		board[r][c] = -1;
	}else if(r != NUM_ROWS [r+1][c] == -1) {
		board[r+1][c] = tile;
		board[r][c] =-1;
	}
	
}",0
ngan146,1696236140,5,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
	
    int r = 0;
    int c = 0;

    FindTile(board, -1, &r, &c);

    if (c != 0 && board[r][c - 1] == -1) {
        board[r][c - 1] = tile;
        board[r][c] = -1;
    } else if (c < NUM_COLS - 1 && board[r][c + 1] == -1) {
        board[r][c + 1] = tile;
        board[r][c] = -1;
    } else if (r != 0 && board[r - 1][c] == -1) {
        board[r - 1][c] = tile;
        board[r][c] = -1;
    } else if (r < NUM_ROWS - 1 && board[r + 1][c] == -1) {
        board[r + 1][c] = tile;
        board[r][c] = -1;
    }
}",0
ngan146,1696236448,6,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
	
    int r = 0;
    int c = 0;

    FindTile(board, tile, &r, &c);

    if (c != 0 && board[r][c - 1] == -1) {
        board[r][c - 1] = tile;
        board[r][c] = -1;
    } else if (c < NUM_COLS - 1 && board[r][c + 1] == -1) {
        board[r][c + 1] = tile;
        board[r][c] = -1;
    } else if (r != 0 && board[r - 1][c] == -1) {
        board[r - 1][c] = tile;
        board[r][c] = -1;
    } else if (r < NUM_ROWS - 1 && board[r + 1][c] == -1) {
        board[r + 1][c] = tile;
        board[r][c] = -1;
    }
}",1
ngna565,1695862273,1,"#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptRow, emptCol, tileRow, tileCol;

    FindTile(board, -1, &emptRow, &emptCol);
    FindTile(board, tile, &tileRow, &tileCol);

    if ((tileRow == emptRow && (tileCol == emptCol - 1 || tileCol == emptCol + 1)) ||
        (tileCol == emptCol && (tileRow == emptRow - 1 || tileRow == emptRow + 1))) {

        board[emptRow][emptCol] = tile;
        board[tileRow][tileCol] = -1;
    } else {
        printf(""Cannot move tile %d.\n"", tile);
    }
}",0
ngna565,1695862697,2,"#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptRow, emptCol, tileRow, tileCol;

    FindTile(board, -1, &emptRow, &emptCol);
    FindTile(board, tile, &tileRow, &tileCol);

    if ((tileRow == emptRow && (tileCol == emptCol - 1 || tileCol == emptCol + 1)) ||
        (tileCol == emptCol && (tileRow == emptRow - 1 || tileRow == emptRow + 1))) {

        board[emptRow][emptCol] = tile;
        board[tileRow][tileCol] = -1;
    } else {
        return;
    }
}",1
nhar865,1696160969,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyRow, emptyColumn, targetRow, targetColumn;

    FindTile(board, -1, &emptyRow, &emptyColumn);
    FindTile(board, tile, &targetRow, &targetColumn);

    int rowDiff = (emptyRow - targetRow) * (emptyRow < targetRow ? -1 : 1);
    int columnDiff = (emptyColumn - targetColumn) * (emptyColumn < targetColumn ? -1 : 1);

    if ((rowDiff == 1 && columnDiff == 0) || (rowDiff == 0 && columnDiff == 1)) {
        board[targetRow][targetColumn] = -1;
        board[emptyRow][emptyColumn] = tile;
    }
}",1
nhrs452,1695857961,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	// finds position of input tile to move FROM
	int rowInput, colInput, rowInputLine, colInputLine;
	FindTile(board, tile, &rowInput, &colInput);
	//colInputLine = (rowInput*4) + colInput; //0x16 array
	//rowInputLine = 0;
	
	// finds position of blank tile (-1) to move TO
	int rowBlank, colBlank, rowBlankLine, colBlankLine;
	FindTile(board, -1, &rowBlank, &colBlank);
	//colBlankLine = (rowBlank*4) + colBlank; //0x16 array
	//rowBlankLine = 0;

	//find out if adjacent, otherwise don't swap
	int i = 0;
	
	while (i == 0){

		if (rowInput == 0 || rowInput == 1 || rowInput == 2 || rowInput == 3){
			if ((rowBlank == rowInput - 1 || rowBlank == rowInput + 1) && colBlank == colInput){
				//then swap
				int temp;
				temp = board[rowInput][colInput];
				board[rowInput][colInput] = board[rowBlank][colBlank];
				board[rowBlank][colBlank] = temp;
			}
		}
	
		if (colInput == 0 || colInput == 1 || colInput == 2 || colInput == 3){
			if ((colBlank == colInput - 1 || colBlank == colInput + 1 ) && rowBlank == rowInput){
				//swap
				int temp;
				temp = board[rowInput][colInput];
				board[rowInput][colInput] = board[rowBlank][colBlank];
				board[rowBlank][colBlank] = temp;
			}
		}
	i++;
	}
}",0
nhrs452,1695858060,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	// finds position of input tile to move FROM
	int rowInput, colInput;
	FindTile(board, tile, &rowInput, &colInput);
	//colInputLine = (rowInput*4) + colInput; //0x16 array
	//rowInputLine = 0;
	
	// finds position of blank tile (-1) to move TO
	int rowBlank, colBlank;
	FindTile(board, -1, &rowBlank, &colBlank);
	//colBlankLine = (rowBlank*4) + colBlank; //0x16 array
	//rowBlankLine = 0;

	//find out if adjacent, otherwise don't swap
	int i = 0;
	
	while (i == 0){

		if (rowInput == 0 || rowInput == 1 || rowInput == 2 || rowInput == 3){
			if ((rowBlank == rowInput - 1 || rowBlank == rowInput + 1) && colBlank == colInput){
				//then swap
				int temp;
				temp = board[rowInput][colInput];
				board[rowInput][colInput] = board[rowBlank][colBlank];
				board[rowBlank][colBlank] = temp;
			}
		}
	
		if (colInput == 0 || colInput == 1 || colInput == 2 || colInput == 3){
			if ((colBlank == colInput - 1 || colBlank == colInput + 1 ) && rowBlank == rowInput){
				//swap
				int temp;
				temp = board[rowInput][colInput];
				board[rowInput][colInput] = board[rowBlank][colBlank];
				board[rowBlank][colBlank] = temp;
			}
		}
	i++;
	}
}",1
nhua986,1695817993,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowEmpty, colEmpty, rowTile, colTile;
    FindTile(board, -1, &rowEmpty, &colEmpty);
    FindTile(board, tile, &rowTile, &colTile);
    
    if (((rowEmpty + 1) == rowTile) && (colEmpty == colTile)) {
        board[rowEmpty][colEmpty] = tile;
        board[rowTile][colTile] = -1;
        return;
    }
    else if (((rowEmpty - 1) == rowTile) && (colEmpty == colTile)) {
        board[rowEmpty][colEmpty] = tile;
        board[rowTile][colTile] = -1;
        return;
    } 
    else if ((rowEmpty == rowTile) && ((colEmpty + 1) == colTile)) {
        board[rowEmpty][colEmpty] = tile;
        board[rowTile][colTile] = -1;
        return;
    }
    else if ((rowEmpty == rowTile) && ((colEmpty - 1) == colTile)) {
        board[rowEmpty][colEmpty] = tile;
        board[rowTile][colTile] = -1;
        return;
    }
    else {
        return;
    }
return;
}",1
nhut042,1695791091,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int tilerow, tilecol, gaprow, gapcol;
    FindTile(board, tile, &tilerow, &tilecol);
    FindTile(board, -1, &gaprow, &gapcol);

    if (((gaprow == tilerow) && (gapcol == tilecol + 1 || gapcol == tilecol - 1)) || (gapcol == tilecol && (gaprow == tilerow + 1 || gaprow == tilerow - 1)))
    { 
        board[gaprow][gapcol] = board[tilerow][tilecol];
        board[tilerow][tilecol] = -1;
        return;
    }
    else 
    {
        return;
    }
}",1
nisa397,1695871202,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tilerow, tilecol;
	//Find the tile to be moved (you might like to use the FindTile() function!)
	FindTile(board, tile, &tilerow, &tilecol);
	//above
	if (tilerow > 0 && board[tilerow - 1][tilecol] == -1) {
		board[tilerow - 1][tilecol] = tile;
		board[tilerow][tilecol] = -1;
	}
	else if (tilerow < NUM_ROWS - 1 && board[tilerow + 1][tilecol] == -1) {
		board[tilerow + 1][tilecol] = tile;
		board[tilerow][tilecol] = -1;
	}
	else if (tilecol > 0 && board[tilerow][tilecol - 1] == -1) {
		board[tilerow][tilecol - 1] = tile;
		board[tilerow][tilecol] = -1;
	}
	else if (tilecol < NUM_ROWS - 1 && board[tilerow][tilecol + 1] == -1) {
		board[tilerow][tilecol + 1] = tile;
		board[tilerow][tilecol] = -1;
	}
}",1
njon803,1695955659,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tileRow, tileCol, emptyRow, emptyCol;

	FindTile(board, tile, &tileRow, &tileCol);
	FindTile(board, -1, &emptyRow, &emptyCol);

	if (tileRow == emptyRow && (abs(tileCol - emptyCol) == 1) || tileCol == emptyCol && (abs(tileRow - emptyRow) == 1)) {

		board[emptyRow] [emptyCol] = board[tileRow] [tileCol];
		board[tileRow] [tileCol] = -1;
	}

}",0
njon803,1695956675,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tileRow, tileCol, emptyRow, emptyCol;

	FindTile(board, tile, &tileRow, &tileCol);
	FindTile(board, -1, &emptyRow, &emptyCol);

	if ((tileRow == emptyRow) && (abs(tileCol - emptyCol) == 1) || (tileCol == emptyCol) && (abs(tileRow - emptyRow) == 1)) {

		board[emptyRow][emptyCol] = board[tileRow][tileCol];
		board[tileRow][tileCol] = -1;
	}
	return 0;

}",0
njon803,1695956922,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tileRow, tileCol, emptyRow, emptyCol;

	FindTile(board, tile, &tileRow, &tileCol);
	FindTile(board, -1, &emptyRow, &emptyCol);

	if ((tileRow == emptyRow) && (abs(tileCol - emptyCol) == 1) || (tileCol == emptyCol) && (abs(tileRow - emptyRow) == 1)) {

		board[emptyRow][emptyCol] = board[tileRow][tileCol];
		board[tileRow][tileCol] = -1;
	}

}",0
njon803,1695957190,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tileRow, tileCol, emptyRow, emptyCol;

	FindTile(board, tile, &tileRow, &tileCol);
	FindTile(board, -1, &emptyRow, &emptyCol);

	if (((tileRow == emptyRow) && (abs(tileCol - emptyCol) == 1)) || ((tileCol == emptyCol) && (abs(tileRow - emptyRow) == 1))) {

		board[emptyRow][emptyCol] = board[tileRow][tileCol];
		board[tileRow][tileCol] = -1;
	}

}",1
nlal162,1695820731,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col; //empty row and empty col
	int t_row, t_col; //tile row and tile col

	//find position of tile and empty square
	FindTile(board, tile, &t_row, &t_col);
	FindTile(board, -1, &row, &col);

	//tile is adjacent to empty sqaure
		if ((t_row - row) == 1 && t_col == col) || 
		((t_col - col) == 1 && t_row == row) {
			board[row][col] = tile;
			board[t_row][t_col] = -1;
		}


}",0
nlal162,1695820746,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col; //empty row and empty col
	int t_row, t_col; //tile row and tile col

	//find position of tile and empty square
	FindTile(board, tile, &t_row, &t_col);
	FindTile(board, -1, &row, &col);

	//tile is adjacent to empty sqaure
		if (((t_row - row) == 1 && t_col == col) || 
		((t_col - col) == 1 && t_row == row)) {
			board[row][col] = tile;
			board[t_row][t_col] = -1;
		}


}",0
nlal162,1695893798,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int e_row, e_col; //empty row and empty col
	int t_row, t_col; //tile row and tile col

	//find position of tile and empty square
	FindTile(board, tile, &t_row, &t_col);
	FindTile(board, -1, &e_row, &e_col);

	//tile is adjacent to empty sqaure
		if (((t_row - e_row) == 1 && t_col == e_col) ||
			((e_row - t_row) == 1 && t_col == e_col) ||
			((t_col - e_col) == 1 && t_row == e_row) ||
			((e_col - t_col) == 1 && t_row == e_row)) {
			board[e_row][e_col] = tile;
			board[t_row][t_col] = -1;
		}


}
",1
nmah920,1696127510,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int empty_row, empty_col;
    int move_row, move_col;

    FindTile(board, -1, &empty_row, &empty_col);
    FindTile(board, tile, &move_row, &move_col);

    if ((empty_row == move_row && (empty_col - 1 == move_col || empty_col + 1 == move_col)) || (empty_col == move_col && (empty_row - 1 == move_row || empty_row + 1 == move_row)))
    {
        int temp = board[move_row][move_col];
        board[move_row][move_col] = board[empty_row][empty_col];
        board[empty_row][empty_col] = temp;
    }

}",1
nqua370,1696242660,1,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyTileRow, emptyTileCol, moveTileRow, moveTileCol;

    FindTile(board, -1, &emptyTileRow, &emptyTileCol);

    FindTile(board, tile, &moveTileRow, &moveTileCol);

    if ((emptyTileRow == moveTileRow && (emptyTileCol == moveTileCol - 1  emptyTileCol == moveTileCol + 1)) 
        (emptyTileCol == moveTileCol && (emptyTileRow == moveTileRow - 1 || emptyTileRow == moveTileRow + 1))) {

        gameBoard[emptyTileRow][emptyTileCol] = tile;
        gameBoard[movingTileRow][movingTileCol] = -1;
    }",0
nqua370,1696242825,2,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyTileRow, emptyTileCol, moveTileRow, moveTileCol;

    FindTile(board, -1, &emptyTileRow, &emptyTileCol);

    FindTile(board, tile, &moveTileRow, &moveTileCol);

    if ((emptyTileRow == moveTileRow && (emptyTileCol == moveTileCol - 1 || emptyTileCol == moveTileCol + 1)) ||
        (emptyTileCol == moveTileCol && (emptyTileRow == moveTileRow - 1 || emptyTileRow == moveTileRow + 1))) {

        board[emptyTileRow][emptyTileCol] = tile;
        board[moveTileRow][moveTileCol] = -1;
    }",0
nqua370,1696242853,3,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyTileRow, emptyTileCol, moveTileRow, moveTileCol;

    FindTile(board, -1, &emptyTileRow, &emptyTileCol);

    FindTile(board, tile, &moveTileRow, &moveTileCol);

    if ((emptyTileRow == moveTileRow && (emptyTileCol == moveTileCol - 1 || emptyTileCol == moveTileCol + 1)) ||
        (emptyTileCol == moveTileCol && (emptyTileRow == moveTileRow - 1 || emptyTileRow == moveTileRow + 1))) {

        board[emptyTileRow][emptyTileCol] = tile;
        board[moveTileRow][moveTileCol] = -1;
    }
}",1
nrub019,1695801558,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    //locate empty tile
    int emptyrowpos, emptycolpos;
    int pass = 0;
    FindTile(board, -1, &emptyrowpos, &emptycolpos);

    //locate tile to swap
    int tilerowpos, tilecolpos;
    FindTile(board, tile, &tilerowpos, &tilecolpos);

    //check if tile to swap is next to empty tile
    if ((tilerowpos == emptyrowpos) && (tilecolpos - 1 == emptycolpos)){
        pass = 1;
    }
    if ((tilerowpos - 1 == emptyrowpos) && (tilecolpos == emptycolpos)){
        pass = 1;
    }
    if ((tilerowpos == emptyrowpos) && (tilecolpos + 1== emptycolpos)){
        pass = 1;
    }
    if ((tilerowpos + 1 == emptyrowpos) && (tilecolpos == emptycolpos)){
        pass = 1;
    }

    //swapping
    if (pass == 1)
    {
        board[emptyrowpos][emptycolpos] = tile;
        board[tilerowpos][tilecolpos] = -1;
    }
}
",1
nthe160,1696144784,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j;
	int row, col;
	int tile_row, tile_col;
	int originalvalue;

	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == -1) {
				row = i;
				col = j;
			}
		}
	}
	
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == 9) {
				tile_row = i;
				tile_col = j;
			}
		}
	}

	if ((tile_row == row - 1) && (tile_col == col)) {
		printf(""yes\n"");
		originalvalue = board[row][col];
		board[row][col] = board[tile_row][tile_col];
		board[tile_row][tile_col] = originalvalue;

	}
	if ((tile_row == row + 1) && (tile_col == col)) {
		printf(""yes\n"");
		originalvalue = board[row][col];
		board[row][col] = board[tile_row][tile_col];
		board[tile_row][tile_col] = originalvalue;

	}
	if ((tile_row == row) && (tile_col == col - 1)) {
		printf(""yes\n"");
		originalvalue = board[row][col];
		board[row][col] = board[tile_row][tile_col];
		board[tile_row][tile_col] = originalvalue;

	}
	if ((tile_row == row) && (tile_col == col + 1)) {
		printf(""yes\n"");
		originalvalue = board[row][col];
		board[row][col] = board[tile_row][tile_col];
		board[tile_row][tile_col] = originalvalue;

	}
}",0
nthe160,1696145049,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j;
	int row, col;
	int tile_row, tile_col;
	int originalvalue;

	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == -1) {
				row = i;
				col = j;
			}
		}
	}
	
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == tile) {
				tile_row = i;
				tile_col = j;
			}
		}
	}

	if ((tile_row == row - 1) && (tile_col == col)) {
		originalvalue = board[row][col];
		board[row][col] = board[tile_row][tile_col];
		board[tile_row][tile_col] = originalvalue;

	}
	if ((tile_row == row + 1) && (tile_col == col)) {
		originalvalue = board[row][col];
		board[row][col] = board[tile_row][tile_col];
		board[tile_row][tile_col] = originalvalue;

	}
	if ((tile_row == row) && (tile_col == col - 1)) {
		originalvalue = board[row][col];
		board[row][col] = board[tile_row][tile_col];
		board[tile_row][tile_col] = originalvalue;

	}
	if ((tile_row == row) && (tile_col == col + 1)) {
		originalvalue = board[row][col];
		board[row][col] = board[tile_row][tile_col];
		board[tile_row][tile_col] = originalvalue;

	}
}",1
ntia856,1696068802,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;
	FindTile(board, -1, &row, &col);
	if (board[row - 1][col] == tile && board[row - 1][col] >= 0) {
		board[row][col] = tile;
		board[row - 1][col] = -1;
	}
	else if(board[row + 1][col] == tile && board[row + 1][col] >= 0) {
		board[row][col] = tile;
		board[row + 1][col] = -1;
	}
	else if(board[row][col + 1] == tile && board[row][col + 1] >= 0) {
		board[row][col] = tile;
		board[row][col + 1] = -1;
	}
	else if(board[row][col - 1] == tile && board[row][col - 1] >= 0) {
		board[row][col] = tile;
		board[row][col - 1] = -1;
	}
}",0
ntia856,1696073064,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;
	FindTile(board, -1, &row, &col);
	if (board[row - 1][col] == tile && row > 0) {
		board[row - 1][col] = -1;
		board[row][col] = tile;
	}
	else if(board[row + 1][col] == tile && NUM_ROWS - 1 > row) {
		board[row + 1][col] = -1;
		board[row][col] = tile;
	}
	else if(board[row][col + 1] == tile && NUM_COLS - 1 > col) {
		board[row][col + 1] = -1;
		board[row][col] = tile;
	}
	else if(board[row][col - 1] == tile && col > 0) {
		board[row][col - 1] = -1;
		board[row][col] = tile;
	}
}",1
ntur101,1695892802,1,"	int EmptyRow, EmptyCol;

	for (int i = 0; i < NUM_ROWS; i++)
	{
		for (int j = 0; j < NUM_COLS; j++)
		{
			if (board[i][j] == -1)
			{
				EmptyRow = i;
				EmptyCol = j;
			}
		}
	}

	if (board[EmptyRow + 1][EmptyCol] == tile)
	{
		board[EmptyRow][EmptyCol] = tile;
		board[EmptyRow + 1][EmptyCol] = -1;
	}

	if (board[EmptyRow - 1][EmptyCol] == tile)
	{
		board[EmptyRow][EmptyCol] = tile;
		board[EmptyRow - 1][EmptyCol] = -1;
	}

	if (board[EmptyRow][EmptyCol + 1] == tile)
	{
		board[EmptyRow][EmptyCol] = tile;
		board[EmptyRow][EmptyCol + 1] = -1;
	}

	if (board[EmptyRow][EmptyCol - 1] == tile)
	{
		board[EmptyRow][EmptyCol] = tile;
		board[EmptyRow][EmptyCol - 1] = -1;
	}",0
ntur101,1695892820,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int EmptyRow, EmptyCol;

	for (int i = 0; i < NUM_ROWS; i++)
	{
		for (int j = 0; j < NUM_COLS; j++)
		{
			if (board[i][j] == -1)
			{
				EmptyRow = i;
				EmptyCol = j;
			}
		}
	}

	if (board[EmptyRow + 1][EmptyCol] == tile)
	{
		board[EmptyRow][EmptyCol] = tile;
		board[EmptyRow + 1][EmptyCol] = -1;
	}

	if (board[EmptyRow - 1][EmptyCol] == tile)
	{
		board[EmptyRow][EmptyCol] = tile;
		board[EmptyRow - 1][EmptyCol] = -1;
	}

	if (board[EmptyRow][EmptyCol + 1] == tile)
	{
		board[EmptyRow][EmptyCol] = tile;
		board[EmptyRow][EmptyCol + 1] = -1;
	}

	if (board[EmptyRow][EmptyCol - 1] == tile)
	{
		board[EmptyRow][EmptyCol] = tile;
		board[EmptyRow][EmptyCol - 1] = -1;
	}
}",0
ntur101,1695894384,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int EmptyRow, EmptyCol;

	for (int i = 0; i < NUM_ROWS; i++)
	{
		for (int j = 0; j < NUM_COLS; j++)
		{
			if (board[i][j] == -1)
			{
				EmptyRow = i;
				EmptyCol = j;
			}
		}
	}

	if (board[EmptyRow + 1][EmptyCol] == tile && EmptyRow > 0)
	{
		board[EmptyRow][EmptyCol] = tile;
		board[EmptyRow + 1][EmptyCol] = -1;
	}

	if (board[EmptyRow - 1][EmptyCol] == tile && EmptyCol < NUM_ROWS)
	{
		board[EmptyRow][EmptyCol] = tile;
		board[EmptyRow - 1][EmptyCol] = -1;
	}

	if (board[EmptyRow][EmptyCol + 1] == tile && EmptyCol < NUM_COLS)
	{
		board[EmptyRow][EmptyCol] = tile;
		board[EmptyRow][EmptyCol + 1] = -1;
	}

	if (board[EmptyRow][EmptyCol - 1] == tile && EmptyCol > 0)
	{
		board[EmptyRow][EmptyCol] = tile;
		board[EmptyRow][EmptyCol - 1] = -1;
	}
}",0
ntur101,1695894703,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int EmptyRow, EmptyCol;

	for (int i = 0; i < NUM_ROWS; i++)
	{
		for (int j = 0; j < NUM_COLS; j++)
		{
			if (board[i][j] == -1)
			{
				EmptyRow = i;
				EmptyCol = j;
			}
		}
	}

	if (board[EmptyRow + 1][EmptyCol] == tile && EmptyRow > 0)
	{
		board[EmptyRow][EmptyCol] = tile;
		board[EmptyRow + 1][EmptyCol] = -1;
	}

	if (board[EmptyRow - 1][EmptyCol] == tile && EmptyRow < NUM_ROWS)
	{
		board[EmptyRow][EmptyCol] = tile;
		board[EmptyRow - 1][EmptyCol] = -1;
	}

	if (board[EmptyRow][EmptyCol + 1] == tile && EmptyCol < NUM_COLS)
	{
		board[EmptyRow][EmptyCol] = tile;
		board[EmptyRow][EmptyCol + 1] = -1;
	}

	if (board[EmptyRow][EmptyCol - 1] == tile && EmptyCol > 0)
	{
		board[EmptyRow][EmptyCol] = tile;
		board[EmptyRow][EmptyCol - 1] = -1;
	}
}",0
ntur101,1695895280,5,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int EmptyRow, EmptyCol;

	for (int i = 0; i < NUM_ROWS; i++)
	{
		for (int j = 0; j < NUM_COLS; j++)
		{
			if (board[i][j] == -1)
			{
				EmptyRow = i;
				EmptyCol = j;
				printf(""row %d, col %d \n"", EmptyRow, EmptyCol);
			}
		}
	}

	if (board[EmptyRow + 1][EmptyCol] == tile && EmptyCol < NUM_COLS - 1)
	{
		board[EmptyRow][EmptyCol] = tile;
		board[EmptyRow + 1][EmptyCol] = -1;
	}

	if (board[EmptyRow - 1][EmptyCol] == tile && EmptyCol > 0)
	{
		board[EmptyRow][EmptyCol] = tile;
		board[EmptyRow - 1][EmptyCol] = -1;
	}

	if (board[EmptyRow][EmptyCol + 1] == tile && EmptyRow > 0)
	{
		board[EmptyRow][EmptyCol] = tile;
		board[EmptyRow][EmptyCol + 1] = -1;
	}

	if (board[EmptyRow][EmptyCol - 1] == tile && EmptyRow < NUM_ROWS - 1)
	{
		board[EmptyRow][EmptyCol] = tile;
		board[EmptyRow][EmptyCol - 1] = -1;
	}
}",0
ntur101,1695895292,6,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int EmptyRow, EmptyCol;

	for (int i = 0; i < NUM_ROWS; i++)
	{
		for (int j = 0; j < NUM_COLS; j++)
		{
			if (board[i][j] == -1)
			{
				EmptyRow = i;
				EmptyCol = j;
			}
		}
	}

	if (board[EmptyRow + 1][EmptyCol] == tile && EmptyCol < NUM_COLS - 1)
	{
		board[EmptyRow][EmptyCol] = tile;
		board[EmptyRow + 1][EmptyCol] = -1;
	}

	if (board[EmptyRow - 1][EmptyCol] == tile && EmptyCol > 0)
	{
		board[EmptyRow][EmptyCol] = tile;
		board[EmptyRow - 1][EmptyCol] = -1;
	}

	if (board[EmptyRow][EmptyCol + 1] == tile && EmptyRow > 0)
	{
		board[EmptyRow][EmptyCol] = tile;
		board[EmptyRow][EmptyCol + 1] = -1;
	}

	if (board[EmptyRow][EmptyCol - 1] == tile && EmptyRow < NUM_ROWS - 1)
	{
		board[EmptyRow][EmptyCol] = tile;
		board[EmptyRow][EmptyCol - 1] = -1;
	}
}",0
ntur101,1695895554,7,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int EmptyRow, EmptyCol;

	for (int i = 0; i < NUM_ROWS; i++)
	{
		for (int j = 0; j < NUM_COLS; j++)
		{
			if (board[i][j] == -1)
			{
				EmptyRow = i;
				EmptyCol = j;
				printf(""row %d, col %d \n"", EmptyRow, EmptyCol);
			}
		}
	}

	if (board[EmptyRow + 1][EmptyCol] == tile && EmptyRow < NUM_ROWS - 1)
	{
		board[EmptyRow][EmptyCol] = tile;
		board[EmptyRow + 1][EmptyCol] = -1;
	}

	if (board[EmptyRow - 1][EmptyCol] == tile && EmptyRow > 0)
	{
		board[EmptyRow][EmptyCol] = tile;
		board[EmptyRow - 1][EmptyCol] = -1;
	}

	if (board[EmptyRow][EmptyCol + 1] == tile && EmptyCol < NUM_COLS - 1)
	{
		board[EmptyRow][EmptyCol] = tile;
		board[EmptyRow][EmptyCol + 1] = -1;
	}

	if (board[EmptyRow][EmptyCol - 1] == tile && EmptyCol > 0)
	{
		board[EmptyRow][EmptyCol] = tile;
		board[EmptyRow][EmptyCol - 1] = -1;
	}
}",0
ntur101,1695895560,8,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int EmptyRow, EmptyCol;

	for (int i = 0; i < NUM_ROWS; i++)
	{
		for (int j = 0; j < NUM_COLS; j++)
		{
			if (board[i][j] == -1)
			{
				EmptyRow = i;
				EmptyCol = j;
			}
		}
	}

	if (board[EmptyRow + 1][EmptyCol] == tile && EmptyRow < NUM_ROWS - 1)
	{
		board[EmptyRow][EmptyCol] = tile;
		board[EmptyRow + 1][EmptyCol] = -1;
	}

	if (board[EmptyRow - 1][EmptyCol] == tile && EmptyRow > 0)
	{
		board[EmptyRow][EmptyCol] = tile;
		board[EmptyRow - 1][EmptyCol] = -1;
	}

	if (board[EmptyRow][EmptyCol + 1] == tile && EmptyCol < NUM_COLS - 1)
	{
		board[EmptyRow][EmptyCol] = tile;
		board[EmptyRow][EmptyCol + 1] = -1;
	}

	if (board[EmptyRow][EmptyCol - 1] == tile && EmptyCol > 0)
	{
		board[EmptyRow][EmptyCol] = tile;
		board[EmptyRow][EmptyCol - 1] = -1;
	}
}",1
nwei818,1695685295,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowPos, colPos;
	FindTile(board, tile, &rowPos, &colPos);

	if (colPos < NUM_COLS - 1 && board[rowPos][colPos + 1] == -1) {
		board[rowPos][colPos + 1] = tile;
		board[rowPos][colPos] = -1;
	}
	else if (colPos > 0 && board[rowPos][colPos - 1] == -1) { 
		board[rowPos][colPos - 1] = tile;
		board[rowPos][colPos] = -1;
	}
	else if (rowPos > 0 && board[rowPos - 1][colPos] == -1) { 
		board[rowPos - 1][colPos] = tile;
		board[rowPos][colPos] = -1;
	}
	else if (rowPos < NUM_ROWS - 1 && board[rowPos + 1][colPos] == -1) { 
		board[rowPos + 1][colPos] = tile;
		board[rowPos][colPos] = -1;
	}
}
",1
nwil850,1695876936,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row, col, rowtile, coltile;
    FindTile(board, -1, &row, &col);
    FindTile(board, tile, &rowtile, &coltile);
    if (((coltile - col) == 1 && rowtile == row) || 
    ((rowtile - row) == 1 && coltile == col)){
        board[row][col] = tile;
        board[rowtile][coltile] = -1;
        }
    }
",0
nwil850,1695877982,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row, col, rowtile, coltile;
    FindTile(board, -1, &row, &col);
    FindTile(board, tile, &rowtile, &coltile);
    if ((abs(coltile - col) == 1 && rowtile == row) || 
    (abs(rowtile - row) == 1 && coltile == col)
    ){
        board[row][col] = tile;
        board[rowtile][coltile] = -1;
    }
}
",1
nyua944,1695635810,1,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int foundi;
    int foundj;
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == tile) {
                foundi = i;
                foundj = j;
                return;
            }
        }
    }
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == -1) {
                board[i][j] == tile;
                board[foundi][foundj] == -1;
                return;
            }
        }
    }
}",0
nyua944,1695635921,2,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int foundi = 0;
    int foundj = 0;
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == tile) {
                foundi = i;
                foundj = j;
                return;
            }
        }
    }
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == -1) {
                board[i][j] = tile;
                board[foundi][foundj] = -1;
                return;
            }
        }
    }
}",0
nyua944,1695636265,3,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int foundi = 0;
    int foundj = 0;
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == tile) {
                foundi = i;
                foundj = j;
            }
        }
    }
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == -1) {
                if (abs(i - foundi) <= 1 && abs(j - foundj) <= 1){
                    board[i][j] = tile;
                    board[foundi][foundj] = -1;
                }
                return;
            }
        }
    }
}",1
obar199,1696235393,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowMove,colMove,rowEmpty,colEmpty;
   FindTile(board,tile,&rowMove,&colMove);
   FindTile(board,-1,&rowEmpty,&colEmpty);
   if ((rowMove-rowEmpty == -1)||(rowMove-rowEmpty == 1)||(colMove-colEmpty == -1)||(colMove-colEmpty == 1)){
       board[rowEmpty][colEmpty] = tile;
       board[rowMove][colMove] = -1;
   }

}",0
obar199,1696235669,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowMove,colMove,rowEmpty,colEmpty;
   FindTile(board,tile,&rowMove,&colMove);
   FindTile(board,-1,&rowEmpty,&colEmpty);
   if (((abs(rowMove-rowEmpty) == 1)||(abs(colMove-colEmpty) == 1))&&(abs(rowMove-rowEmpty)+abs(colMove-colEmpty)==1)){
       board[rowEmpty][colEmpty] = tile;
       board[rowMove][colMove] = -1;
   }",0
obar199,1696235730,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowMove,colMove,rowEmpty,colEmpty;
   FindTile(board,tile,&rowMove,&colMove);
   FindTile(board,-1,&rowEmpty,&colEmpty);
   if (((abs(rowMove-rowEmpty) == 1)||(abs(colMove-colEmpty) == 1))&&(abs(rowMove-rowEmpty)+abs(colMove-colEmpty)==1)){
       board[rowEmpty][colEmpty] = tile;
       board[rowMove][colMove] = -1;
   }
}",1
ogab251,1695879129,1,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col;
    int tilerow, tilecol;
    
    FindTile(board, -1, &row, &col);
    FindTile(board, tile, &tilerow, &tilecol);
    
    if ((tilerow == row) && ((tilecol == col + 1) || (tilecol == col - 1))) || ((tilecol == col) && ((tilerow == row + 1) || (tilerow == row - 1))) {
        
        board[row][col] = board[row][col] + board[tilerow][tilecol];
        board[tilerow][tilecol] = board[row][col] - board[tilerow][tilecol];
        board[row][col] = board[row][col] - board[tilerow][tilecol];
    }
}",0
ogab251,1695879279,2,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col;
    int tilerow, tilecol;
    
    FindTile(board, -1, &row, &col);
    FindTile(board, tile, &tilerow, &tilecol);
    
    if (((tilerow == row) && ((tilecol == col + 1) || (tilecol == col - 1))) || ((tilecol == col) && ((tilerow == row + 1) || (tilerow == row - 1)))) {
        
        board[row][col] = board[row][col] + board[tilerow][tilecol];
        board[tilerow][tilecol] = board[row][col] - board[tilerow][tilecol];
        board[row][col] = board[row][col] - board[tilerow][tilecol];
    }
}",1
ogan176,1696049875,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tileRow, tileCol, emptyRow, emptyCol;
	FindTile(board, tile, &tileRow, &tileCol);
	FindTile(board, -1, &emptyRow, &emptyCol);

	if (((tileRow == emptyRow) && (tileCol == emptyCol - 1 || tileCol == emptyCol + 1)) ||
		((tileCol == emptyCol) && (tileRow == emptyRow - 1 || tileRow == emptyRow + 1))) {
		board[emptyRow][emptyCol] = tile;
		board[tileRow][tileCol] = -1;
	}
}",1
ogar584,1695778483,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyrow, emptycol, i, j;
    i = 0;
    j = 0;
    FindTile(board, -1, &emptyrow, &emptycol);
    
    for (i = 0; i < 4; i++)
    {
        for (j = 0; j < 4; j++)
        {
            if (board[i][j] == tile)
            {
                if (emptyrow + 1 < i || i < emptyrow - 1 || emptycol + 1 < j || j < emptycol - 1)
                {
                    break;
                }
                board[i][j] = -1;
                board[emptyrow][emptycol] = tile;
                break;
            }
        }
    }
}",1
oguo680,1696043146,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowEmpty, colEmpty;
    int rowTile = -1, colTile = -1;

    FindTile(board, -1, &rowEmpty, &colEmpty);
    FindTile(board, tile, &rowTile, &colTile);

    if (colTile == colEmpty && (rowTile == rowEmpty - 1 || rowTile == rowEmpty + 1)) {
        board[rowEmpty][colEmpty] = tile;
        board[rowTile][colTile] = -1;
    } else if (rowTile == rowEmpty && (colTile == colEmpty - 1 || colTile == colEmpty + 1)) {
        board[rowEmpty][colEmpty] = tile;
        board[rowTile][colTile] = -1;
    }
}",1
oko158,1695993959,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row, col;
    FindTile(board, tile, &row, &col);

    if (row > 0 && board[row - 1][col] == -1) {
        board[row - 1][col] = tile;
        board[row][col] = -1;
    }

    else if (col > 0 && board[row][col - 1] == -1) {
        board[row][col - 1] = tile;
        board[row][col] = -1;
    }
    else if (row < NUM_ROWS && board[row + 1][col] == -1) {
        board[row + 1][col] = tile;
        board[row][col] = -1;
    }

    else if (col < NUM_COLS && board[row][col + 1] == -1) {
        board[row][col + 1] = tile;
        board[row][col] = -1;
    }
}",1
opat597,1696240859,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyRow, emptyCol, tileRow, tileCol;

    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);

    if (((emptyRow == tileRow) && ((emptyCol - tileCol) == 1 || (tileCol - emptyCol) == 1)) ||
        ((emptyCol == tileCol) && ((emptyRow - tileRow) == 1 || (tileRow - emptyRow) == 1))) {
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}",1
opre469,1696150814,1,"//MakeMove moves the blank space to an adjacent tile//
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	//finding the position of the blank space//
	int row, col;
	FindTile(board, -1, &row, &col);

	//if statement to move blank space upwards//
	if (board[row - 1][col] == tile && row > 0) {
		board[row - 1][col] = -1;
		board[row][col] = tile;
	}

	//if statement to move blank space downwards//
	if (board[row + 1][col] == tile && row < 3) {
		board[row + 1][col] = -1;
		board[row][col] = tile;
	}

	//blank space to move blank space to the left//
	if (board[row][col - 1] == tile && col > 0) {
		board[row][col - 1] = -1;
		board[row][col] = tile;
	}

	//if statement to move blank statment to the right//
	if (board[row][col + 1] == tile && col < 3) {
		board[row][col + 1] = -1;
		board[row][col] = tile;
	}
}",1
orow585,1696227105,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tile_row, tile_col;
	int block;

	FindTile(board, tile, &tile_row, &tile_col);
	block = board[tile_row][tile_col];

	int blank_row, blank_col;

	FindTile(board, -1, &blank_row, &blank_col);
	board[blank_row][blank_col] = block;
	board[tile_row][tile_col] = -1;
}",0
orow585,1696227872,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tile_row, tile_col;
	int block;

	FindTile(board, tile, &tile_row, &tile_col);
	block = board[tile_row][tile_col];

	int blank_row, blank_col;

	FindTile(board, -1, &blank_row, &blank_col);

	if ( (tile_col == blank_col && (tile_row == blank_row - 1 || tile_row == blank_row + 1)) || (tile_row == blank_row && (tile_col == blank_col - 1 || tile_col == blank_col + 1)))
	{
		board[blank_row][blank_col] = block;
		board[tile_row][tile_col] = -1;
	}
}",1
osca399,1695781081,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

// this code was written by Olano Scarlett

{
	int row, col;
	FindTile(board, tile, &row, &col);

	int emptyRow,emptyCol;
	FindTile(board, -1, &emptyRow, &emptyCol);

	if ((row > 0 && board[row - 1][col] == -1) ||
		(row < NUM_ROWS - 1 && board[row + 1][col] == -1) ||
		(col > 0 && board[row][col - 1] == -1) ||
		(col < NUM_COLS - 1 && board[row][col + 1] == -1)) {

		board[row][col] = -1;
		board[emptyRow][emptyCol] = tile;
	}
}",1
osko432,1696241548,1,"#include <stdio.h>
#define Deez_Nuts
#define NUM_ROWS 4
#define NUM_COLS 4
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
int row1, col1, row2, col2;
FindTile(board, tile, &row1, &col1);
FindTile(board, -1, &row2, &col2);

if(((row1-row2+col1-col2)<1)&&((row1-row2+col1-col2)>-1)){
int hold;
hold=board[row1][col1];
board[row1][col1]=-1;
board[row2][col2]=hold;
}
}",0
osko432,1696242097,2,"#include <stdio.h>
#define Deez_Nuts
#define NUM_ROWS 4
#define NUM_COLS 4
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
int row1, col1, row2, col2;
FindTile(board, tile, &row1, &col1);
FindTile(board, -1, &row2, &col2);

if((row1-row2)*(row1-row2)+(col1-col2)*(col1-col2)==1){
int hold;
hold=board[row1][col1];
board[row1][col1]=-1;
board[row2][col2]=hold;
}
}
",1
pchh683,1695857359,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;
	FindTile(board, tile, &row, &col);
	if ( (row != 0) && (board[row-1][col] == -1))
	{
		board[row-1][col] = board[row][col];
		board[row][col] = -1;
	}
	else if ((col != 0) && (board[row][col-1] == -1))
	{
		board[row][col-1] = board[row][col];
		board[row][col] = -1;
	}
	else if ((col != 3) && (board[row][col+1] == -1))
	{
		board[row][col+1] = board[row][col];
		board[row][col] = -1;
	}
	else if ((row != 3) && (board[row+1][col] == -1))
	{
		board[row+1][col] = board[row][col];
		board[row][col] = -1;
	}
}",1
pfil701,1696239421,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    int colPos, rowPos;
    FindTile(board, -1, &rowPos, &colPos);
    
    if (tile <= 0) {
        return;
    }
    
    if (rowPos > 0 && board[rowPos - 1][colPos] == tile) {
        board[rowPos][colPos] = tile;
        board[rowPos - 1][colPos] = -1;
    } 
    
    else if (rowPos < NUM_ROWS - 1 && board[rowPos + 1][colPos] == tile) {
        board[rowPos][colPos] = tile;
        board[rowPos + 1][colPos] = -1;
    } 
    
    else if (colPos > 0 && board[rowPos][colPos - 1] == tile) {
        board[rowPos][colPos] = tile;
        board[rowPos][colPos - 1] = -1;
    } 
    
    else if (colPos < NUM_COLS - 1 && board[rowPos][colPos + 1] == tile) {
        board[rowPos][colPos] = tile;
        board[rowPos][colPos + 1] = -1;
    } 
    
    else {
        printf(""Cannot move tile %d\n"", tile);
    }
}",0
pfil701,1696239565,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    int colPos, rowPos;
    FindTile(board, -1, &rowPos, &colPos);
    
    if (tile <= 0) {
        return;
    }
    
    if (rowPos > 0 && board[rowPos - 1][colPos] == tile) {
        board[rowPos][colPos] = tile;
        board[rowPos - 1][colPos] = -1;
    } 
    
    else if (rowPos < NUM_ROWS - 1 && board[rowPos + 1][colPos] == tile) {
        board[rowPos][colPos] = tile;
        board[rowPos + 1][colPos] = -1;
    } 
    
    else if (colPos > 0 && board[rowPos][colPos - 1] == tile) {
        board[rowPos][colPos] = tile;
        board[rowPos][colPos - 1] = -1;
    } 
    
    else if (colPos < NUM_COLS - 1 && board[rowPos][colPos + 1] == tile) {
        board[rowPos][colPos] = tile;
        board[rowPos][colPos + 1] = -1;
    } 
}",1
pfon568,1696222670,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyTileRow, emptyTileCol, tileRow, tileCol;
    
    FindTile(board, -1, &emptyTileRow, &emptyTileCol);
    FindTile(board, tile, &tileRow, &tileCol);
    
    if (((tileRow + 1 == emptyTileRow) || (tileRow - 1 == emptyTileRow)) || ((tileCol + 1 == emptyTileCol) || (tileCol - 1 == emptyTileCol)))
    {
        board[tileRow][tileCol] = -1;
        board[emptyTileRow][emptyTileCol] = tile;
        
    } 
    
}",0
pfon568,1696222751,2,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyTileRow, emptyTileCol, tileRow, tileCol;
    
    FindTile(board, -1, &emptyTileRow, &emptyTileCol);
    FindTile(board, tile, &tileRow, &tileCol);
    
    if (((tileRow + 1 == emptyTileRow) || (tileRow - 1 == emptyTileRow)) || ((tileCol + 1 == emptyTileCol) || (tileCol - 1 == emptyTileCol)))
    {
        board[tileRow][tileCol] = -1;
        board[emptyTileRow][emptyTileCol] = tile;
        
    } 
    
}",0
pfon568,1696224601,3,"/* MakeMove.c moves a block into an empty slot
   
Inputs: board (board game)
      : tile (the tile to move into empty slot
Output: tile in new position
Author: Pesah Fonua

*/
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    // declare the data types //
    int emptyTileRow, emptyTileCol, tileRow, tileCol;
    
    // Find the positions of the empty slot and the specified tile //
    FindTile(board, -1, &emptyTileRow, &emptyTileCol);
    FindTile(board, tile, &tileRow, &tileCol);
    
    if (((tileRow + 1 == emptyTileRow) || (tileRow - 1 == emptyTileRow)) || ((tileCol + 1 == emptyTileCol) || (tileCol - 1 == emptyTileCol)))
    {
        board[tileRow][tileCol] = -1;
        board[emptyTileRow][emptyTileCol] = tile;
        
    } 
    
}",0
pfon568,1696230273,4,"/* MakeMove.c moves a block into an empty slot
   
Inputs: board (board game)
      : tile (the tile to move into empty slot
Output: tile in new position
Author: Pesah Fonua

*/

#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    
    int emptyRow, emptyCol, tileRow, tileCol;
    
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);
    
    if (tileRow > 0) && (tileCol > 0)
    {
        if ((tileRow + 1 == emptyTileRow) || (tileRow - 1 == emptyTileRow) || (tileCol + 1 == emptyTileCol) || (tileCol - 1 == emptyTileCol))
        {
            board[tileRow][tileCol] = -1;
            board[emptyTileRow][emptyTileCol] = tile;
        } 
   
    } else if (tileRow == 0) {
        
        if ((tileRow + 1 == emptyTileRow) || (tileCol + 1 == emptyTileCol) || (tileCol - 1 == emptyTileCol))
        {
            board[tileRow][tileCol] = -1;
            board[emptyTileRow][emptyTileCol] = tile;
        } 
        
    } else if (tileCol == 0) {
        
        if ((tileRow + 1 == emptyTileRow) || (tileRow - 1 == emptyTileRow) || (tileCol + 1 == emptyTileCol))
        {
            board[tileRow][tileCol] = -1;
            board[emptyTileRow][emptyTileCol] = tile;
        } 
    
    } else if (tileRow == NUM_ROWS - 1) {
        
        if ((tileRow - 1 == emptyTileRow) || (tileCol + 1 == emptyTileCol) || (tileCol - 1 == emptyTileCol))
        {
            board[tileRow][tileCol] = -1;
            board[emptyTileRow][emptyTileCol] = tile;
        } 
        
    } else if (tileCol == NUM_COLS - 1) {
        
        if ((tileRow + 1 == emptyTileRow) || (tileRow - 1 == emptyTileRow) || (tileCol - 1 == emptyTileCol))
        {
            board[tileRow][tileCol] = -1;
            board[emptyTileRow][emptyTileCol] = tile;
        } 
        
    } else {
        
        return;
    }
    
}",0
pfon568,1696230323,5,"/* MakeMove.c moves a block into an empty slot
   
Inputs: board (board game)
      : tile (the tile to move into empty slot
Output: tile in new position
Author: Pesah Fonua

*/

#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    
    int emptyRow, emptyCol, tileRow, tileCol;
    
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);
    
    if ((tileRow > 0) && (tileCol > 0))
    {
        if ((tileRow + 1 == emptyTileRow) || (tileRow - 1 == emptyTileRow) || (tileCol + 1 == emptyTileCol) || (tileCol - 1 == emptyTileCol))
        {
            board[tileRow][tileCol] = -1;
            board[emptyTileRow][emptyTileCol] = tile;
        } 
   
    } else if (tileRow == 0) {
        
        if ((tileRow + 1 == emptyTileRow) || (tileCol + 1 == emptyTileCol) || (tileCol - 1 == emptyTileCol))
        {
            board[tileRow][tileCol] = -1;
            board[emptyTileRow][emptyTileCol] = tile;
        } 
        
    } else if (tileCol == 0) {
        
        if ((tileRow + 1 == emptyTileRow) || (tileRow - 1 == emptyTileRow) || (tileCol + 1 == emptyTileCol))
        {
            board[tileRow][tileCol] = -1;
            board[emptyTileRow][emptyTileCol] = tile;
        } 
    
    } else if (tileRow == NUM_ROWS - 1) {
        
        if ((tileRow - 1 == emptyTileRow) || (tileCol + 1 == emptyTileCol) || (tileCol - 1 == emptyTileCol))
        {
            board[tileRow][tileCol] = -1;
            board[emptyTileRow][emptyTileCol] = tile;
        } 
        
    } else if (tileCol == NUM_COLS - 1) {
        
        if ((tileRow + 1 == emptyTileRow) || (tileRow - 1 == emptyTileRow) || (tileCol - 1 == emptyTileCol))
        {
            board[tileRow][tileCol] = -1;
            board[emptyTileRow][emptyTileCol] = tile;
        } 
        
    } else {
        
        return;
    }
    
}",0
pfon568,1696230353,6,"/* MakeMove.c moves a block into an empty slot
   
Inputs: board (board game)
      : tile (the tile to move into empty slot
Output: tile in new position
Author: Pesah Fonua

*/

#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    
    int emptyTileRow, emptyTileCol, tileRow, tileCol;
    
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);
    
    if ((tileRow > 0) && (tileCol > 0))
    {
        if ((tileRow + 1 == emptyTileRow) || (tileRow - 1 == emptyTileRow) || (tileCol + 1 == emptyTileCol) || (tileCol - 1 == emptyTileCol))
        {
            board[tileRow][tileCol] = -1;
            board[emptyTileRow][emptyTileCol] = tile;
        } 
   
    } else if (tileRow == 0) {
        
        if ((tileRow + 1 == emptyTileRow) || (tileCol + 1 == emptyTileCol) || (tileCol - 1 == emptyTileCol))
        {
            board[tileRow][tileCol] = -1;
            board[emptyTileRow][emptyTileCol] = tile;
        } 
        
    } else if (tileCol == 0) {
        
        if ((tileRow + 1 == emptyTileRow) || (tileRow - 1 == emptyTileRow) || (tileCol + 1 == emptyTileCol))
        {
            board[tileRow][tileCol] = -1;
            board[emptyTileRow][emptyTileCol] = tile;
        } 
    
    } else if (tileRow == NUM_ROWS - 1) {
        
        if ((tileRow - 1 == emptyTileRow) || (tileCol + 1 == emptyTileCol) || (tileCol - 1 == emptyTileCol))
        {
            board[tileRow][tileCol] = -1;
            board[emptyTileRow][emptyTileCol] = tile;
        } 
        
    } else if (tileCol == NUM_COLS - 1) {
        
        if ((tileRow + 1 == emptyTileRow) || (tileRow - 1 == emptyTileRow) || (tileCol - 1 == emptyTileCol))
        {
            board[tileRow][tileCol] = -1;
            board[emptyTileRow][emptyTileCol] = tile;
        } 
        
    } else {
        
        return;
    }
    
}",0
pfon568,1696230389,7,"/* MakeMove.c moves a block into an empty slot
   
Inputs: board (board game)
      : tile (the tile to move into empty slot
Output: tile in new position
Author: Pesah Fonua

*/

#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    
    int emptyTileRow, emptyTileCol, tileRow, tileCol;
    
    FindTile(board, -1, &emptyTileRow, &emptyTileCol);
    FindTile(board, tile, &tileRow, &tileCol);
    
    if ((tileRow > 0) && (tileCol > 0))
    {
        if ((tileRow + 1 == emptyTileRow) || (tileRow - 1 == emptyTileRow) || (tileCol + 1 == emptyTileCol) || (tileCol - 1 == emptyTileCol))
        {
            board[tileRow][tileCol] = -1;
            board[emptyTileRow][emptyTileCol] = tile;
        } 
   
    } else if (tileRow == 0) {
        
        if ((tileRow + 1 == emptyTileRow) || (tileCol + 1 == emptyTileCol) || (tileCol - 1 == emptyTileCol))
        {
            board[tileRow][tileCol] = -1;
            board[emptyTileRow][emptyTileCol] = tile;
        } 
        
    } else if (tileCol == 0) {
        
        if ((tileRow + 1 == emptyTileRow) || (tileRow - 1 == emptyTileRow) || (tileCol + 1 == emptyTileCol))
        {
            board[tileRow][tileCol] = -1;
            board[emptyTileRow][emptyTileCol] = tile;
        } 
    
    } else if (tileRow == NUM_ROWS - 1) {
        
        if ((tileRow - 1 == emptyTileRow) || (tileCol + 1 == emptyTileCol) || (tileCol - 1 == emptyTileCol))
        {
            board[tileRow][tileCol] = -1;
            board[emptyTileRow][emptyTileCol] = tile;
        } 
        
    } else if (tileCol == NUM_COLS - 1) {
        
        if ((tileRow + 1 == emptyTileRow) || (tileRow - 1 == emptyTileRow) || (tileCol - 1 == emptyTileCol))
        {
            board[tileRow][tileCol] = -1;
            board[emptyTileRow][emptyTileCol] = tile;
        } 
        
    } else {
        
        return;
    }
    
}",0
pfon568,1696231502,8,"/* MakeMove.c moves a block into an empty slot
   
Inputs: board (board game)
      : tile (the tile to move into empty slot
Output: tile in new position
Author: Pesah Fonua

*/

#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyTileRow, emptyTileCol;
    
    FindTile(board, -1, *emptyTileRow, *emptyTileCol);
    FindTile(board, tile, *tileRow, *tileCol);
    
    if ((tileRow == emptyTileRow && (tileCol == emptyTileCol - 1 || tileCol == emptyTileCol + 1)) || (tileCol == emptyTileCol && (tileRow == emptyRow - 1 || tileRow == emptyRow + 1)))
    {
        board[emptyTileRow][emptyTileColCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}",0
pfon568,1696231531,9,"/* MakeMove.c moves a block into an empty slot
   
Inputs: board (board game)
      : tile (the tile to move into empty slot
Output: tile in new position
Author: Pesah Fonua

*/

#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyTileRow, emptyTileCol;
    
    FindTile(board, -1, &emptyTileRow, &emptyTileCol);
    FindTile(board, tile, &tileRow, &tileCol);
    
    if ((tileRow == emptyTileRow && (tileCol == emptyTileCol - 1 || tileCol == emptyTileCol + 1)) || (tileCol == emptyTileCol && (tileRow == emptyRow - 1 || tileRow == emptyRow + 1)))
    {
        board[emptyTileRow][emptyTileColCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}",0
pfon568,1696231558,10,"/* MakeMove.c moves a block into an empty slot
   
Inputs: board (board game)
      : tile (the tile to move into empty slot
Output: tile in new position
Author: Pesah Fonua

*/

#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyTileRow, emptyTileCol, tileRow, tileCol;
    
    FindTile(board, -1, &emptyTileRow, &emptyTileCol);
    FindTile(board, tile, &tileRow, &tileCol);
    
    if ((tileRow == emptyTileRow && (tileCol == emptyTileCol - 1 || tileCol == emptyTileCol + 1)) || (tileCol == emptyTileCol && (tileRow == emptyRow - 1 || tileRow == emptyRow + 1)))
    {
        board[emptyTileRow][emptyTileColCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}",0
pfon568,1696231673,11,"/* MakeMove.c moves a block into an empty slot
   
Inputs: board (board game)
      : tile (the tile to move into empty slot
Output: tile in new position
Author: Pesah Fonua

*/

#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyTileRow, emptyTileCol, tileRow, tileCol;
    
    FindTile(board, -1, &emptyTileRow, &emptyTileCol);
    FindTile(board, tile, &tileRow, &tileCol);
    
    if ((tileRow == emptyTileRow && (tileCol == emptyTileCol - 1 || tileCol == emptyTileCol + 1)) || (tileCol == emptyTileCol && (tileRow == emptyTileRow - 1 || tileRow == emptyTileRow + 1)))
    {
        board[emptyTileRow][emptyTileColCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}",0
pfon568,1696231756,12,"/* MakeMove.c moves a block into an empty slot
   
Inputs: board (board game)
      : tile (the tile to move into empty slot
Output: tile in new position
Author: Pesah Fonua

*/

#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyTileRow, emptyTileCol, tileRow, tileCol;
    
    FindTile(board, -1, &emptyTileRow, &emptyTileCol);
    FindTile(board, tile, &tileRow, &tileCol);
    
    if ((tileRow == emptyTileRow && (tileCol == emptyTileCol - 1 || tileCol == emptyTileCol + 1)) || (tileCol == emptyTileCol && (tileRow == emptyTileRow - 1 || tileRow == emptyTileRow + 1)))
    {
        board[emptyTileRow][emptyTileCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}",1
phao209,1696240999,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol;
    int tileRow, tileCol;

    // Find the positions of the empty square and the specified tile
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);

    // Calculate the row and column differences
    int rowDiff = tileRow - emptyRow;
    int colDiff = tileCol - emptyCol;

    // Check if the move is valid based on the row and column differences
    if ((abs(rowDiff) == 1 && colDiff == 0) || (abs(colDiff) == 1 && rowDiff == 0)) {
        // Swap the tile and the empty square
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}",1
pkim777,1695707644,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyRow, emptyCol, interestRow, interestCol;
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &interestRow, &interestCol);
    if ((interestRow == (emptyRow + 1) || interestRow == (emptyRow - 1)) && interestCol == emptyCol) {
        board[emptyRow][emptyCol] = board[interestRow][interestCol];
        board[interestRow][interestCol] = -1;
    }
    if (emptyCol == 0) {
        if (interestCol == (emptyCol + 1) && interestRow == emptyRow) {
            board[emptyRow][emptyCol] = board[interestRow][interestCol];
            board[interestRow][interestCol] = -1;
        }
    } else if (emptyCol == 3) {
        if (interestCol == (emptyCol - 1) && interestRow == emptyRow) {
            board[emptyRow][emptyCol] = board[interestRow][interestCol];
            board[interestRow][interestCol] = -1;
        }
    } else if ((interestCol == (emptyCol + 1) || interestCol == (emptyCol - 1)) && interestRow == emptyRow) {
        board[emptyRow][emptyCol] = board[interestRow][interestCol];
        board[interestRow][interestCol] = -1;
    }
    
}",1
plah275,1696214466,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rpos, cpos, mptr, mptc, var1;

	FindTile(board, -1, &rpos, &cpos);

	mptr = rpos;
	mptc = cpos;

	FindTile(board, tile, &rpos, &cpos);

	var1 = ((mptr == rpos) && ((mptc == (cpos + 1)) || (mptc == (cpos - 1)))) || ((mptc == cpos) && ((mptr == (rpos + 1)) || (mptr == (rpos - 1))));
    
		if (var1) {

			board[mptr][mptc] = board[rpos][cpos];

			board[rpos][cpos] = -1;
		}

}",1
plan310,1695898821,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int trow, tcol, row, col;
    
	FindTile(board, tile, &trow, &tcol);
		printf(""tile is at trow=%d and tcol=%d.\n"", trow, tcol);
		

	FindTile(board, -1, &row, &col);
		printf(""Empty tile is at row=%d and col=%d.\n"", row, col);

	if (tcol == col) {
	    if (trow> 0 && trow < NUM_ROWS) {
	        if (row == trow - 1 || row == trow + 1) {
                board[trow][tcol] = -1;
				board[row][col] = tile;
			}
	    }
		else if (trow > 0) {
			if (row == trow - 1) {
				board[trow][tcol] = -1;
				board[row][col] = tile;
			}
		}
		else if (trow < NUM_ROWS) {
			if (row == trow + 1) {
				board[trow][tcol] = -1;
				board[row][col] = tile;
			}
		}
	}
	else if (trow == row) {
	    if (tcol > 0 && tcol < NUM_COLS) {
	        if (col == tcol - 1 || col == tcol + 1) {
                board[trow][tcol] = -1;
				board[row][col] = tile;
			}
	    }
		else if (tcol > 0) {
			if (col == tcol - 1) {
                board[trow][tcol] = -1;
				board[row][col] = tile;
			}
		}
		else if (tcol < NUM_COLS) {
			if (col == tcol + 1) {
				board[trow][tcol] = -1;
				board[row][col] = tile;
			}
		}
	}

}",0
plan310,1695899268,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int trow, tcol, row, col;
    
	FindTile(board, tile, &trow, &tcol);
	FindTile(board, -1, &row, &col);

	if (tcol == col) {
	    if (trow> 0 && trow < NUM_ROWS) {
	        if (row == trow - 1 || row == trow + 1) {
                board[trow][tcol] = -1;
				board[row][col] = tile;
			}
	    }
		else if (trow > 0) {
			if (row == trow - 1) {
				board[trow][tcol] = -1;
				board[row][col] = tile;
			}
		}
		else if (trow < NUM_ROWS) {
			if (row == trow + 1) {
				board[trow][tcol] = -1;
				board[row][col] = tile;
			}
		}
	}
	else if (trow == row) {
	    if (tcol > 0 && tcol < NUM_COLS) {
	        if (col == tcol - 1 || col == tcol + 1) {
                board[trow][tcol] = -1;
				board[row][col] = tile;
			}
	    }
		else if (tcol > 0) {
			if (col == tcol - 1) {
                board[trow][tcol] = -1;
				board[row][col] = tile;
			}
		}
		else if (tcol < NUM_COLS) {
			if (col == tcol + 1) {
				board[trow][tcol] = -1;
				board[row][col] = tile;
			}
		}
	}

}",1
pper327,1696118874,1,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tileRow, tileCol, emptyRow, emptyCol;
	int *tileRowPnt;
	int *tileColPnt;
	int *emptyRowPnt;
	int *emptyColPnt;


	FindTile(board, tile, &tileRow, &tileCol);
	FindTile(board, -1, &emptyRow, &emptyCol);

	if ((emptyRow == tileRow) && ((emptyCol == (tileCol +1 )) || (emptyCol == (tileCol - 1)))){
		board [emptyRow] [emptyCol] = tile; 
		board [tileRow] [tileCol] = -1;
	} else if ((emptyCol == tileCol) && ((emptyRow == (tileRow +1)) || (emptyRow == (tileRow - 1)))){
		board [emptyRow] [emptyCol] = tile; 
		board [tileRow] [tileCol] = -1; 
	}

}",0
pper327,1696118915,2,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tileRow, tileCol, emptyRow, emptyCol;



	FindTile(board, tile, &tileRow, &tileCol);
	FindTile(board, -1, &emptyRow, &emptyCol);

	if ((emptyRow == tileRow) && ((emptyCol == (tileCol +1 )) || (emptyCol == (tileCol - 1)))){
		board [emptyRow] [emptyCol] = tile; 
		board [tileRow] [tileCol] = -1;
	} else if ((emptyCol == tileCol) && ((emptyRow == (tileRow +1)) || (emptyRow == (tileRow - 1)))){
		board [emptyRow] [emptyCol] = tile; 
		board [tileRow] [tileCol] = -1; 
	}

}",1
pshe539,1695703932,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tile_row, tile_col;

	FindTile(board, -1, &tile_row, &tile_col);

	int move_row = 0;
	int move_col = 0;

	FindTile(board, tile, &move_row, &move_col);

	if (tile_row == move_row){ // Same row
		if (tile_col == (move_col + 1) || tile_col == (move_col - 1)){
			board[tile_row][tile_col] = board[move_row][move_col];
			board[move_row][move_col] = -1;
		}
	} else if (tile_col == move_col){ // Same col
		if (tile_row == (move_row + 1) || tile_row == (move_row - 1)){
			board[tile_row][tile_col] = board[move_row][move_col];
			board[move_row][move_col] = -1;
		}
	}
}",1
psin207,1695945424,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row;
    int col;
    
    FindTile(board, tile, &row, &col);
    
    if (row>0 && row<4 && col>0 && col<4) {
        if (board[row+1][col] == -1) {
        board[row+1][col] = tile;
        board[row][col] = -1;
        }else if (board[row-1][col] == -1) {
        board[row-1][col] = tile;
        board[row][col] = -1;
        }else if (board[row][col+1]==-1){
        board[row][col+1]=tile;
        board[row][col]=-1;
        }else if (board[row][col-1]==-1){
        board[row][col-1]=tile;
        board[row][col]=-1;
        }else {
        board[row][col]=tile;
        }
    } else if (row==0 && col<4){
        if (board[row+1][col] ==-1) {
        board[row+1][col] = tile;
        board[row][col] = -1;
        }else if (board[row][col+1]==-1){
        board[row][col+1]=tile;
        board[row][col]=-1;
        }else if (board[row][col-1]==-1){
        board[row][col-1]=tile;
        board[row][col]=-1;
        }else {
        board[row][col]=tile;
        }
    }else if (row==3 && col<4){
        if (board[row-1][col] ==-1) {
        board[row-1][col] = tile;
        board[row][col] = -1;
        }else if (board[row][col+1]==-1){
        board[row][col+1]=tile;
        board[row][col]=-1;
        }else if (board[row][col-1]==-1){
        board[row][col-1]=tile;
        board[row][col]=-1;
        }else {
        board[row][col]=tile;
        }
    }else if (row<4 && col==0){
        if (board[row][col+1] ==-1) {
        board[row][col+1] = tile;
        board[row][col] = -1;
        }else if (board[row-1][col]==-1){
        board[row-1][col]=tile;
        board[row][col]=-1;
        }else if (board[row+1][col]==-1){
        board[row+1][col]=tile;
        board[row][col]=-1;
        }else {
        board[row][col]=tile;
        }
    }else if (row<4 && col==3) {
        if (board[row][col-1] ==-1) {
        board[row][col-1] = tile;
        board[row][col] = -1;
        }else if (board[row+1][col]==-1){
        board[row+1][col]=tile;
        board[row][col]=-1;
        }else if (board[row-1][col]==-1){
        board[row-1][col]=tile;
        board[row][col]=-1;
        }else {
        board[row][col]=tile;
        }
    }
    
    
}
",0
psin207,1695956975,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row;
    int col;
    
    FindTile(board, tile, &row, &col);
    
    if (row>0){
        if (board[row-1][col]==-1) {
        board[row][col]=-1;
        board[row-1][col]=tile;
        }
    }
    if (row<3){
        if (board[row+1][col]==-1) {
        board[row][col]=-1;
        board[row+1][col]=tile;
        }
    }
   
    if (col>0){
        if (board[row][col-1]==-1) {
        board[row][col]=-1;
        board[row][col-1]=tile;
        }
    }
   
    if (col<3){
        if (board[row][col+1]==-1){
        board[row][col]=-1;
        board[row][col+1]=tile;
        }
    }
}
        ",1
pwat943,1695729713,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	// Initialize the Tile position and the empty position
	int RowT;
	int ColT;
	int emptyRow;
	int emptyCol;

	// Find the position of the specified tile 
	FindTile(board, tile, &RowT, &ColT);
	
	// Find the position of the empty square
	FindTile(board, -1, &emptyRow, &emptyCol);

	// Check if the specified tile is adjacent to the empty square
	if ((RowT == emptyRow && (ColT == emptyCol - 1 || ColT == emptyCol + 1)) ||
		(ColT == emptyCol && (RowT == emptyRow - 1 || RowT == emptyRow + 1))) {
		// Swap the specified tile and the empty square
		int temp = board[RowT][ColT];
		board[RowT][ColT] = board[emptyRow][emptyCol];
		board[emptyRow][emptyCol] = temp;
	}
}",1
pwil422,1696228072,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol, tileRow, tileCol;
    
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);

    if ((emptyRow - tileRow==1&&emptyCol==tileCol) ||
        (emptyCol-tileCol==1&&emptyRow==tileRow)) {
        board[emptyRow][emptyCol]=tile;
        board[tileRow][tileCol]=-1;
    }
}",0
pwil422,1696229776,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol, tileRow, tileCol;
    
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);

    if ((abs(emptyRow-tileRow==1&&emptyCol==tileCol)) ||
        (abs(emptyCol-tileCol==1&&emptyRow==tileRow))) {
        board[emptyRow][emptyCol]=tile;
        board[tileRow][tileCol]=-1;
    }
}",0
pwu278,1695877021,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowPos;
	int colPos;
	int GaprowPos;
	int GapcolPos;

	FindTile(board, tile, &rowPos, &colPos);
	FindTile(board, -1, &GaprowPos, &GapcolPos);

	if (GaprowPos - 1 == rowPos && GapcolPos == colPos || GaprowPos + 1 == rowPos && GapcolPos == colPos 
		|| GapcolPos - 1 == colPos && GaprowPos == rowPos || GapcolPos + 1 == colPos && GaprowPos == rowPos) {
		board[rowPos][colPos] = -1;
		board[GaprowPos][GapcolPos] = tile;
	}
}",0
pwu278,1695877374,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowPos;
	int colPos;
	int GaprowPos;
	int GapcolPos;

	FindTile(board, tile, &rowPos, &colPos);
	FindTile(board, -1, &GaprowPos, &GapcolPos);

	if ((GaprowPos - 1 == rowPos && GapcolPos == colPos) || (GaprowPos + 1 == rowPos && GapcolPos == colPos) || (GapcolPos - 1 == colPos && GaprowPos == rowPos) || (GapcolPos + 1 == colPos && GaprowPos == rowPos)) {
		board[rowPos][colPos] = -1;
		board[GaprowPos][GapcolPos] = tile;
	}
}",1
pxie161,1695634350,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
int row, col;
FindTile(board, -1, &row, &col);
if (tile == board[row][col+1]){
	board[row][col] = board[row][col+1];
	board[row][col+1] = -1;
}
else if (tile == board[row][col-1]){
	board[row][col] = board[row][col-1];
	board[row][col-1] = -1;
}
else if (tile == board[row+1][col]){
	board[row][col] = board[row+1][col];
	board[row+1][col] = -1;
}
else if (tile == board[row-1][col]){
	board[row][col] = board[row-1][col];
	board[row-1][col] = -1;
}
}",0
pxie161,1695688762,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
int row, col;
FindTile(board, -1, &row, &col);
if (tile == board[row][col+1]){
	if (col+1 < 4){
		board[row][col] = board[row][col+1];
		board[row][col+1] = -1;
	}
}
else if (tile == board[row][col-1]){
	if(col-1 > -1){
		board[row][col] = board[row][col-1];
		board[row][col-1] = -1;
	}
}
else if (tile == board[row+1][col]){
	if (row+1 < 4){
		board[row][col] = board[row+1][col];
		board[row+1][col] = -1;
	}
}
else if (tile == board[row-1][col]){
	if(row-1 > -1){
		board[row][col] = board[row-1][col];
		board[row-1][col] = -1;
	}
}
}",1
pyou182,1695859354,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    //Pointers for Tile to move
    int rP, cP;
    int rowPos;
    int colPos;

    FindTile(board, tile, &rowPos, &colPos);
    rP = rowPos;
    cP = colPos;

    //Pointers for empty tile
    int rE, cE;
    int rowEmpty;
    int colEmpty;
    FindTile(board, -1, &rowEmpty, &colEmpty);
    rE = rowEmpty; //Stores row location as int rE
    cE = colEmpty;

    //Checking Above Tile
    if (rP - 1 == rE && cP == cE) {
        board[rP][cP] = -1;
        board[rE][cE] = tile;
    }

    //Below Tile
    if (rP + 1 == rE && cP == cE) {
        board[rP][cP] = -1;
        board[rE][cE] = tile;
    }

    //Left Tile
    if (cP - 1 == cE && rP == rE) {
         board[rP][cP] = -1;
         board[rE][cE] = tile;
    }

    //Right Tile
    if (cP + 1 == cE && rP == rE) {
         board[rP][cP] = -1;
         board[rE][cE] = tile;
    }
    
    
}",1
qche619,1696244285,1,"void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos);",0
qkan386,1695948290,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){

	int MoveRow = 0, MoveCol = 0;

	//find the postion of the tile you are making move with 
	for (int i = 0; i < NUM_ROWS; i++) {
		for (int j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == tile) {
				MoveRow = i;
				MoveCol = j;
			}
		}
	}

	int row, col;
	FindTile(board, -1, &row, &col);

	if (MoveRow + 1 == row && MoveCol == col) {
		int temp = board[MoveRow][MoveCol];
		board[MoveRow][MoveCol] = board[row][col];
		board[row][col] = temp;
	}

	if (MoveRow - 1 == row && MoveCol == col) {
		int temp = board[MoveRow][MoveCol];
		board[MoveRow][MoveCol] = board[row][col];
		board[row][col] = temp;
	}

	if (MoveCol + 1 == col && MoveRow == row) {
		int temp = board[MoveRow][MoveCol];
		board[MoveRow][MoveCol] = board[row][col];
		board[row][col] = temp;
	}

	if (MoveCol - 1 == col && MoveRow == row) {
		int temp = board[MoveRow][MoveCol];
		board[MoveRow][MoveCol] = board[row][col];
		board[row][col] = temp;
	}
}",1
qmcc945,1695765488,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
int i, j, tilesRow, tilesCol, blankRow, blankCol;
for (i=0; i<NUM_ROWS; i++) {
	for (j=0; j<NUM_COLS; j++) {
		if (board[i][j] == tile) {
			tilesRow = i;
			tilesCol = j;
		}
	}
}	

for (i=0; i<NUM_ROWS; i++) {
	for (j=0; j<NUM_COLS; j++) {
		if (board[i][j] == -1) {
			blankRow = i;
			blankCol = j;
		}
	}
}	

if((blankRow != tilesRow) & (blankCol != tilesCol)) {
	return;
}

if((blankRow == tilesRow) & (blankCol == tilesCol)) {
	return;
}


if(board[(tilesRow+1)][tilesCol] == -1) {
	board[tilesRow][tilesCol] = -1;
	board[(tilesRow+1)][tilesCol] = tile;
}

if(board[(tilesRow-1)][tilesCol] == -1) {
	board[tilesRow][tilesCol] = -1;
	board[(tilesRow-1)][tilesCol] = tile;
}

if(board[tilesRow][(tilesCol+1)] == -1) {
	board[tilesRow][tilesCol] = -1;
	board[tilesRow][(tilesCol+1)] = tile;
}

if(board[tilesRow][(tilesCol-1)] == -1) {
	board[tilesRow][tilesCol] = -1;
	board[tilesRow][(tilesCol-1)] = tile;
}

}",1
qtra338,1695631965,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
	int i, j, tile_row, tile_col, space_row, space_col, adja[] = {-1,1};

	FindTile(board, tile, &tile_row, &tile_col);
	FindTile(board, -1, &space_row, &space_col);

	for (i = 0; i < 2; i++) {	
		if (space_row + adja[i] == tile_row && space_col == tile_col)
		{
			board[tile_row][tile_col] = -1;
			board[space_row][space_col] = tile;
		}
		else if (space_row == tile_row && space_col + adja[i] == tile_col)
		{
			board[tile_row][tile_col] = -1;
			board[space_row][space_col] = tile;
		}
		
	}

}",0
qtra338,1695632019,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
	int i, tile_row, tile_col, space_row, space_col, adja[] = {-1,1};

	FindTile(board, tile, &tile_row, &tile_col);
	FindTile(board, -1, &space_row, &space_col);

	for (i = 0; i < 2; i++) {	
		if (space_row + adja[i] == tile_row && space_col == tile_col)
		{
			board[tile_row][tile_col] = -1;
			board[space_row][space_col] = tile;
		}
		else if (space_row == tile_row && space_col + adja[i] == tile_col)
		{
			board[tile_row][tile_col] = -1;
			board[space_row][space_col] = tile;
		}
		
	}

}",1
qwu129,1696243535,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRow, tileCol;
    int emptyRow, emptyCol;

    
    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol);

  
    if (tileRow == emptyRow && (tileCol == emptyCol + 1 || tileCol == emptyCol - 1)) {
       
        board[tileRow][tileCol] = -1;
        board[emptyRow][emptyCol] = tile;
    }

   
    else if (tileCol == emptyCol && (tileRow == emptyRow + 1 || tileRow == emptyRow - 1)) {
       
        board[tileRow][tileCol] = -1;
        board[emptyRow][emptyCol] = tile;
    }",0
qzho943,1695696446,1,"
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    int row1;
    int col1;
    int row2; 
    int col2;
    FindTile(board, -1, &row1, &col1);
    FindTile(board, tile, &row2, &col2);
    
    if (row1==row2 || col1==col2){
       if (col1+1==col2 || col1-1==col2 || row1-1==row2 || row1+1==row2){
       board[row1][col1]=tile;
       board[row2][col2]=-1;
        }
    }
}
",1
raic989,1695871060,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int x,y,a,b;
    FindTile(board, tile, &x, &y);
    FindTile(board, -1, &a, &b);
    if ((y==b & (x==a+1 || x==a-1) ) || (x==a & (y==b+1 || y==b-1)))   {
        board[a][b]=board[x][y]; 
        board[x][y]=-1;
    
    } 
}",0
raic989,1695871880,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int x,y,a,b;
    FindTile(board, tile, &x, &y);
    FindTile(board, -1, &a, &b);
    if (((y==b) && (x==a+1 || x==a-1) ) ||  ((x==a) && (y==b+1 || y==b-1)))   {
        board[a][b]=board[x][y]; 
        board[x][y]=-1;

    } 
}",1
rand321,1695629395,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int i, j, row, col;
    
   FindTile(board, -1, &row, &col);
   
   
for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
		    if ((board[i][j] == tile)&&((board[i][j+1]==-1)||(board[i][j-1]==-1)||(board[i+1][j]==-1)||(board[i-1][j]==-1))){
		    board[i][j] = -1;
		    board[row][col] = tile;
		    }
        }
    }
}",0
rand321,1695631524,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int i, j, row, col;
    
   FindTile(board, -1, &row, &col);
   
   
for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
		    if (board[i][j] == tile){
		  
		        if(((j+1==col)||(j-1==col))&&(i==row)){
		        board[i][j] = -1;
		        board[row][col] = tile;
		        }
		        
		        if(((i+1==row)||(i-1==row))&&(j==col)){
		        board[i][j] = -1;
		        board[row][col] = tile;
		        }
		    }
        }
    }
}",1
rbaj698,1696231814,1,"#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

{
	int i,j;
	for (i=0; i < NUM_ROWS; i++) {
		for (j=0; j < NUM_COLS; j++) {
			if (board[i][j] == tile) {
				if (i > 0 && board[i-1][j] == -1) {
					board[i-1][j] = tile;
					board[i][j] = -1;
				} else if (i < NUM_ROWS - 1 && board[i+1][j] == -1) {
					board[i+1][j] = tile;
					board[i][j] = -1;
				} else if (j > 0 && board[i][j-1] == -1) {
					board[i][j-1] = tile;
					board[i][j] = -1;
				} else (j < NUM_COLS - 1 && board[i][j+1] == -1) {
					board[i][j+1] = tile;
					board[i][j] = -1;
				}
			}
		}
	}
}
",0
rbaj698,1696231892,2,"#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

{
	int i,j;
	for (i=0; i < NUM_ROWS; i++) {
		for (j=0; j < NUM_COLS; j++) {
			if (board[i][j] == tile) {
				if (i > 0 && board[i-1][j] == -1) {
					board[i-1][j] = tile;
					board[i][j] = -1;
				} else if (i < NUM_ROWS - 1 && board[i+1][j] == -1) {
					board[i+1][j] = tile;
					board[i][j] = -1;
				} else if (j > 0 && board[i][j-1] == -1) {
					board[i][j-1] = tile;
					board[i][j] = -1;
				} else if (j < NUM_COLS - 1 && board[i][j+1] == -1) {
					board[i][j+1] = tile;
					board[i][j] = -1;
				}
			}
		}
	}
}
",0
rbaj698,1696231958,3,"#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

{
	int i,j;
	for (i=0; i < NUM_ROWS; i++) {
		for (j=0; j < NUM_COLS; j++) {
			if (board[i][j] == tile) {
				if (i > 0 && board[i-1][j] == -1) {
					board[i-1][j] = tile;
					board[i][j] = -1;
					return;
				} else if (i < NUM_ROWS - 1 && board[i+1][j] == -1) {
					board[i+1][j] = tile;
					board[i][j] = -1;
					return;
				} else if (j > 0 && board[i][j-1] == -1) {
					board[i][j-1] = tile;
					board[i][j] = -1;
					return;
				} else if (j < NUM_COLS - 1 && board[i][j+1] == -1) {
					board[i][j+1] = tile;
					board[i][j] = -1;
					return;
				}
			}
		}
	}
}
",1
rbat374,1696226197,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row1,col1;
    int row2,col2;
    FindTile(board, tile, &row1, &col1);
    FindTile(board, -1, &row2, &col2);
    board[row1][col1] = -1;
    board[row2][col2] = tile;
}",0
rbat374,1696226761,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row1,col1;
    int row2,col2;
    FindTile(board, tile, &row1, &col1);
    FindTile(board, -1, &row2, &col2);
    if (board[row1-1][col1] == -1 || board[row1+1][col1] == -1 || board[row1][col1-1] == -1|| board[row1][col1+1] == -1){
       board[row1][col1] = -1;
       board[row2][col2] = tile; 
    } 
    
}",0
rbat374,1696229687,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row1,col1;
    int row2,col2;
    FindTile(board, tile, &row1, &col1);
    FindTile(board, -1, &row2, &col2);
    if (row1 > 0 && row1 < NUM_ROWS-1 && col1 > 0 && col1 < NUM_COLS-1){
        if (board[row1-1][col1] == -1 || board[row1+1][col1] == -1 || board[row1][col1-1] == -1|| board[row1][col1+1] == -1){
            board[row1][col1] = -1;
            board[row2][col2] = tile; 
        }
    }
    else if (row1 == 0 && col1 > 0 && col1 < NUM_COLS-1){
        if (board[row1+1][col1] == -1 || board[row1][col1-1] == -1|| board[row1][col1+1] == -1){
            board[row1][col1] = -1;
            board[row2][col2] = tile;
        }
    }
    else if (row1 == 0 && col1 == 0){
        if (board[row1+1][col1] == -1 || board[row1][col1+1] == -1){
            board[row1][col1] = -1;
            board[row2][col2] = tile;
        }
    }
    else if (row1 > 0 && row1 < NUM_ROWS-1 && col1 == 0){
        if (board[row1-1][col1] == -1 || board[row1+1][col1] == -1 || board[row1][col1+1] == -1){
            board[row1][col1] = -1;
            board[row2][col2] = tile;
        }
    }
    else if (row1 == NUM_ROWS-1 && col1 == NUM_COLS-1){
        if (board[row1-1][col1] == -1 || board[row1][col1-1] == -1){
            board[row1][col1] = -1;
            board[row2][col2] = tile;
        }
    }
    else if (row1 == NUM_ROWS-1 && col1 == 0){
        if(board[row1-1][col1] == -1 || board[row1][col1+1] == -1){
            board[row1][col1] = -1;
            board[row2][col2] = tile;
        }
    }
    else if (row1 == NUM_ROWS-1 && col1 > 0 && col1 < NUM_COLS-1){
        if(board[row1-1][col1] == -1 || board[row1][col1-1] == -1|| board[row1+1][col1] == -1){
            board[row1][col1] = -1;
            board[row2][col2] = tile;
        }
    }
    else if (row1 > 0 && row1 < NUM_ROWS-1 && col1 == NUM_COLS-1){
        if(board[row1-1][col1] == -1 || board[row1+1][col1] == -1 ||  board[row1][col1-1] == -1){
            board[row1][col1] = -1;
            board[row2][col2] = tile;
        }
    }
    else if (row1 == 0 && col1 == NUM_COLS-1){
        if(board[row1+1][col1] == -1 || board[row1][col1+1] == -1){
            board[row1][col1] = -1;
            board[row2][col2] = tile;
        }
    }
    
    
}",0
rbat374,1696230572,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row1,col1;
    int row2,col2;
    FindTile(board, tile, &row1, &col1);
    FindTile(board, -1, &row2, &col2);
    if (row1 > 0 && row1 < NUM_ROWS-1 && col1 > 0 && col1 < NUM_COLS-1){
        if (board[row1-1][col1] == -1 || board[row1+1][col1] == -1 || board[row1][col1-1] == -1|| board[row1][col1+1] == -1){
            board[row1][col1] = -1;
            board[row2][col2] = tile; 
        }
    }
    else if (row1 == 0 && col1 > 0 && col1 < NUM_COLS-1){
        if (board[row1+1][col1] == -1 || board[row1][col1-1] == -1|| board[row1][col1+1] == -1){
            board[row1][col1] = -1;
            board[row2][col2] = tile;
        }
    }
    else if (row1 == 0 && col1 == 0){
        if (board[row1+1][col1] == -1 || board[row1][col1+1] == -1){
            board[row1][col1] = -1;
            board[row2][col2] = tile;
        }
    }
    else if (row1 > 0 && row1 < NUM_ROWS-1 && col1 == 0){
        if (board[row1-1][col1] == -1 || board[row1+1][col1] == -1 || board[row1][col1+1] == -1){
            board[row1][col1] = -1;
            board[row2][col2] = tile;
        }
    }
    else if (row1 == NUM_ROWS-1 && col1 == NUM_COLS-1){
        if (board[row1-1][col1] == -1 || board[row1][col1-1] == -1){
            board[row1][col1] = -1;
            board[row2][col2] = tile;
        }
    }
    else if (row1 == NUM_ROWS-1 && col1 == 0){
        if(board[row1-1][col1] == -1 || board[row1][col1+1] == -1){
            board[row1][col1] = -1;
            board[row2][col2] = tile;
        }
    }
    else if (row1 == NUM_ROWS-1 && col1 > 0 && col1 < NUM_COLS-1){
        if(board[row1-1][col1] == -1 || board[row1][col1-1] == -1|| board[row1][col1+1] == -1){
            board[row1][col1] = -1;
            board[row2][col2] = tile;
        }
    }
    else if (row1 > 0 && row1 < NUM_ROWS-1 && col1 == NUM_COLS-1){
        if(board[row1-1][col1] == -1 || board[row1+1][col1] == -1 ||  board[row1][col1-1] == -1){
            board[row1][col1] = -1;
            board[row2][col2] = tile;
        }
    }
    else if (row1 == 0 && col1 == NUM_COLS-1){
        if(board[row1+1][col1] == -1 || board[row1][col1-1] == -1){
            board[row1][col1] = -1;
            board[row2][col2] = tile;
        }
    }
    
    
}",1
rbat561,1695634502,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{	
	int locx, locy;
	FindTile(board, tile, &locx, &locy);
	
	if (board[locx+1][locy] == -1){
		board[locx][locy] = -1;
		board[locx+1][locy] = tile;

	} else if (board[locx][locy+1] == -1){
		board[locx][locy] = -1;
		board[locx][locy+1] = tile;

	} else if (board[locx-1][locy] == -1){
		board[locx][locy] = -1;
		board[locx-1][locy] = tile;

	} else if (board[locx][locy-1] == -1) {
		board[locx][locy] = -1;
		board[locx][locy-1] = tile;
	} else{
	}
}",0
rbat561,1695719469,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{	
	int locx, locy;
	FindTile(board, tile, &locx, &locy);
	
	if (board[locx+1][locy] == -1){
		board[locx][locy] = -1;
		board[locx+1][locy] = tile;

	} else if (board[locx][locy+1] == -1){
		board[locx][locy] = -1;
		board[locx][locy+1] = tile;

	} else if (board[locx-1][locy] == -1){
		board[locx][locy] = -1;
		board[locx-1][locy] = tile;

	} else if (board[locx][locy-1] == -1) {
		board[locx][locy] = -1;
		board[locx][locy-1] = tile;
	}
}",0
rbat561,1695777458,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{	
	int locx, locy, emptyx, emptyy, rowdiff, coldiff;
	FindTile(board, tile, &locx, &locy);
	FindTile(board, -1, &emptyx, &emptyy);

	rowdiff = locx - emptyx;
	coldiff = locy - emptyy;

	if (coldiff == 0 && rowdiff == 1){
		board[locx][locy] = -1;
		board[emptyx][emptyy] = tile;

	} else if (coldiff == 1 && rowdiff == 0){
		board[locx][locy] = -1;
		board[emptyx][emptyy] = tile;

	} else if (coldiff == -1 && rowdiff == 0){
		board[locx][locy] = -1;
		board[emptyx][emptyy] = tile;

	} else if (coldiff == 0 && rowdiff == -1) {
		board[locx][locy] = -1;
		board[emptyx][emptyy] = tile;
	}
}",1
rbui853,1695707158,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;

	FindTile(board, tile, &row, &col);

	if (row > 0) {
		if (board[row - 1][col] == -1) {
			board[row - 1][col] = board[row][col];
			board[row][col] = -1;
		}
	}
	if (col > 0) {
		if (board[row][col - 1] == -1) {
			board[row][col - 1] = board[row][col];
			board[row][col] = -1;
		}
	}
	if (row < NUM_ROWS - 1) {
		if (board[row + 1][col] == -1) {
			board[row + 1][col] = board[row][col];
			board[row][col] = -1;
		}
	}
	if (col < NUM_COLS - 1) {
		if (board[row][col + 1] == -1) {
			board[row][col + 1] = board[row][col];
			board[row][col] = -1;
		}
	}
}",1
rbus291,1696114347,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol, tileRow, tileCol;

    findPosition(board, -1, &emptyRow, &emptyCol); 
    findPosition(board, tile, &tileRow, &tileCol);

    if ((emptyRow == tileRow && (emptyCol - tileCol == 1 || emptyCol - tileCol == -1)) ||
        (emptyCol == tileCol && (emptyRow - tileRow == 1 || emptyRow - tileRow == -1))) {
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
        
    } else {
        printf(""Invalid move! Tile cannot be moved.\n"");
    }
}",0
rbus291,1696117788,2,"void FindTileAndMakeMove(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos) {
    int move;
    printf(""Empty tile is at row=%d and col=%d.\nMake your move: "", *rowPos, *colPos);
    scanf(""%d"", &move);

    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == -1) {
                *rowPos = i;
                *colPos = j;
            } else if (board[i][j] == move) {
                if ((*rowPos == i && abs(*colPos - j) == 1) || (*colPos == j && abs(*rowPos - i) == 1)) 
                {
                    board[*rowPos][*colPos] = move;
                    board[i][j] = -1;
                    return;
                }
            }
        }
    }
}",0
rbus291,1696118303,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
	int emptyRow, emptyCol, tileRow, tileCol;

	
	FindTile(board, -1, &emptyRow, &emptyCol); 
	FindTile(board, tile, &tileRow, &tileCol);

	
	if ((emptyRow == tileRow && abs(emptyCol - tileCol) == 1) ||
		(emptyCol == tileCol && abs(emptyRow - tileRow) == 1)) {
		
		int temp = board[emptyRow][emptyCol];
		board[emptyRow][emptyCol] = board[tileRow][tileCol];
		board[tileRow][tileCol] = temp;
	}
}
",1
rchi339,1696133072,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tempRow, tempCol;
	int newtileRow, newtileCol;
	int colDiff, rowDiff;

	FindTile(board, -1, &tempRow, &tempCol);
	FindTile(board, tile, &newtileRow, &newtileCol);

	rowDiff = tempRow - newtileRow;
	colDiff = tempCol - newtileCol;

	bool adjacent;

	if (rowDiff == 0 && colDiff == 0) {
		adjacent = false;
	}

	else if (rowDiff == -1 || rowDiff == 1) {

		if (colDiff == 0) {
			adjacent = true;
		}

		else {
			adjacent = false;
		}
	}

	else if (colDiff == -1 || colDiff == 1) {

		if (rowDiff == 0) {
			adjacent = true;
		}

		else {
			adjacent = false;
		}
	}

	else {
		adjacent = false;
	}

	if (adjacent == true) {
		board[tempRow][tempCol] = board[newtileRow][newtileCol];
		board[newtileRow][newtileCol] = -1;
	}
}",1
rcou530,1695795496,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;

	FindTile(board, -1, &row, &col);
	int openRow = row;
	int openCol = col;

	FindTile(board, tile, &row, &col);
	int tileRow = row;
	int tileCol = col;

	if (0 < openRow < 3 && 0 < openCol < 3) {
		if ((openRow + 1 == tileRow && openCol == tileCol) || (openRow - 1 == tileRow && openCol == tileCol) || (openRow == tileRow && openCol + 1 == tileCol) || (openRow == tileRow && openCol - 1 == tileCol)) {
			int temp = board[openRow][openCol];
			board[openRow][openCol] = board[tileRow][tileCol];
			board[tileRow][tileCol] = temp;
		}
	}
	else if (openRow == 0) {
		if (openRow + 1 == tileRow && openCol == tileCol) {
			int temp = board[openRow][openCol];
			board[openRow][openCol] = board[tileRow][tileCol];
			board[tileRow][tileCol] = temp;
		}

	}
	else if (openCol == 0) {
		if (openRow == tileRow && openCol + 1 == tileCol) {
			int temp = board[openRow][openCol];
			board[openRow][openCol] = board[tileRow][tileCol];
			board[tileRow][tileCol] = temp;
		}
	}
	else if (openRow == 3) {
		if (openRow - 1 == tileRow && openCol == tileCol) {
			int temp = board[openRow][openCol];
			board[openRow][openCol] = board[tileRow][tileCol];
			board[tileRow][tileCol] = temp;
		}
	}
	else if (openCol == 3) {
		if (openRow == tileRow && openCol - 1 == tileCol) {
			int temp = board[openRow][openCol];
			board[openRow][openCol] = board[tileRow][tileCol];
			board[tileRow][tileCol] = temp;
		}
	}
	else {
		return;
	}
	return; 
}",0
rcou530,1695796047,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;

	FindTile(board, -1, &row, &col);
	int openRow = row;
	int openCol = col;

	FindTile(board, tile, &row, &col);
	int tileRow = row;
	int tileCol = col;

	if ((openRow + 1 == tileRow && openCol == tileCol) || (openRow - 1 == tileRow && openCol == tileCol) || (openRow == tileRow && openCol + 1 == tileCol) || (openRow == tileRow && openCol - 1 == tileCol)) {
			int temp = board[openRow][openCol];
			board[openRow][openCol] = board[tileRow][tileCol];
			board[tileRow][tileCol] = temp;
	}
	else {
		return;
	}
	return; 
}",1
rdas322,1696221891,1,"void MakeMove(int gameBoard[NUM_ROWS][NUM_COLS], int targetTile) {
    int EmptyRow, EmptyCol, TargetRow, TargetCol;

    
    for (int Row = 0; Row < NUM_ROWS; Row++) {
        for (int Col = 0; Col < NUM_COLS; Col++) {
            if (gameBoard[Row][Col] == -1) {
                EmptyRow = Row;
                EmptyCol = Col;
            }
            if (gameBoard[Row][Col] == targetTile) {
                TargetRow = Row;
                TargetCol = Col;
            }
        }
    }

    
    if ((abs(TargetRow - EmptyRow) == 1 && TargetCol == EmptyCol) || (abs(TargetCol - EmptyCol) == 1 && TargetRow == EmptyRow)) {
        
        gameBoard[EmptyRow][EmptyCol] = targetTile;
        gameBoard[TargetRow][TargetCol] = -1;
    }
}
",1
rdon807,1696222045,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int a=0;
    int row, col;
    FindTile(board,tile,&row,&col);
    if (board[row-1][col]==-1){
        a=board[row-1][col];
        board[row-1][col]=board[row][col];
        board[row][col]=a;
    }
    if (board[row+1][col]==-1){
        a=board[row+1][col];
        board[row+1][col]=board[row][col];
        board[row][col]=a;
    }
    if (board[row][col-1]==-1){
        a=board[row][col-1];
        board[row][col-1]=board[row][col];
        board[row][col]=a;
    }
    if (board[row][col+1]==-1){
        a=board[row][col+1];
        board[row][col+1]=board[row][col];
        board[row][col]=a;
    }
}",0
rdon807,1696238169,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int a=0;
    int row, col;
    int emptyrow, emptycol;
    FindTile(board,-1,&emptyrow,&emptycol);
    FindTile(board,tile,&row,&col);
    if (((((emptyrow - row) == 1)||((emptyrow-row)== -1)) && emptycol ==col) || 
        ((((emptycol - col) == 1)||((emptycol-col)==-1)) && emptyrow ==row)){
        a=board[emptyrow][emptycol];
        board[emptyrow][emptycol]=board[row][col];
        board[row][col]=a;
    }
   
}",1
rdun690,1695811218,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == tile) {
				rowtile = i;
				coltile = j;
			}
			else if (board[i][j] == -1) {
				emptrow = i;
				emptcol = j;
			}
		}
	}
	// checking if tile is above empty
	if (rowtile + 1 == emptrow) {
		if (coltile == emptcol) {
			board[emptrow][emptcol] = board[rowtile][coltile];
			board[rowtile][coltile] = -1;
			
		}
	}
	// checking if tile is below empty
	else if (rowtile - 1 == emptrow) {
		if (coltile == emptcol) {
			board[emptrow][emptcol] = board[rowtile][coltile];
			board[rowtile][coltile] = -1;
		}
	}
	// checking if tile is left of empty
	else if (coltile + 1 == emptcol) {
		if (rowtile == emptrow) {
			board[emptrow][emptcol] = board[rowtile][coltile];
			board[rowtile][coltile] = -1;
		}
	}
	// checking if tile is right of empty
	else if (coltile - 1 == emptcol) {
		if (rowtile == emptrow) {
			board[emptrow][emptcol] = board[rowtile][coltile];
			board[rowtile][coltile] = -1;
		}
	}
}",0
rdun690,1695811419,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int emptrow;
	int emptcol;
	int i;
	int j;
	int rowtile;
	int coltile;

	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == tile) {
				rowtile = i;
				coltile = j;
			}
			else if (board[i][j] == -1) {
				emptrow = i;
				emptcol = j;
			}
		}
	}
	// checking if tile is above empty
	if (rowtile + 1 == emptrow) {
		if (coltile == emptcol) {
			board[emptrow][emptcol] = board[rowtile][coltile];
			board[rowtile][coltile] = -1;
			
		}
	}
	// checking if tile is below empty
	else if (rowtile - 1 == emptrow) {
		if (coltile == emptcol) {
			board[emptrow][emptcol] = board[rowtile][coltile];
			board[rowtile][coltile] = -1;
		}
	}
	// checking if tile is left of empty
	else if (coltile + 1 == emptcol) {
		if (rowtile == emptrow) {
			board[emptrow][emptcol] = board[rowtile][coltile];
			board[rowtile][coltile] = -1;
		}
	}
	// checking if tile is right of empty
	else if (coltile - 1 == emptcol) {
		if (rowtile == emptrow) {
			board[emptrow][emptcol] = board[rowtile][coltile];
			board[rowtile][coltile] = -1;
		}
	}
}",1
rger104,1695782452,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    
    int holerow, holecol;
    int tilerow, tilecol;
    FindTile(board,-1,&holerow,&holecol);
    FindTile(board,-1,&tilecol,&tilecol);
   
    
    
    // if tilecol 1 higher or lower than holecol as well as tilerow and holerow are the same 
    //or if tilerow 1 higher or lower than holerow as well as holecol and tilecol are the smame
    if ( ( ( (tilecol==holecol+1) | (tilecol==holecol-1) ) & (tilerow==holerow) ) | ( ( (tilerow==holerow+1) | (tilerow==holerow-1) ) & (tilecol==holerow) ) ) {
        //replace empty tile
        board[holerow][holecol]=tile;
        //replace tile with desired 
        board[tilerow][tilecol]=-1;
    }
	
}",0
rger104,1695865157,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int holerow;
	int holecol;
	int tilerow;
	int tilecol;
	FindTile(board, -1, &holerow, &holecol);
	FindTile(board, tile, &tilerow, &tilecol);



	// if tilecol 1 higher or lower than holecol as well as tilerow and holerow are the same 
	//or if tilerow 1 higher or lower than holerow as well as holecol and tilecol are the smame
	if ((((tilecol == holecol + 1) | (tilecol == holecol - 1)) & (tilerow == holerow)) | (((tilerow == holerow + 1) | (tilerow == holerow - 1)) & (tilecol == holecol))) {
		//replace empty tile
		board[holerow][holecol] = tile;

		//replace tile with desired 
		board[tilerow][tilecol] = -1;

	}
}",1
rgre692,1696241669,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row, col, tileRow, tileCol;

    FindTile(board, -1, &row, &col);
    FindTile(board, tile, &tileRow, &tileCol);

    if ((row == tileRow && (col == tileCol - 1 || col == tileCol + 1)) ||
        (col == tileCol && (row == tileRow - 1 || row == tileRow + 1))) {
        
        if (tileRow >= 0 && tileRow < NUM_ROWS && tileCol >= 0 && tileCol < NUM_COLS) {
            board[row][col] = tile;
            board[tileRow][tileCol] = -1;
        }
    }
}
",1
rkan756,1696201651,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i;
	int j;
	int empty_x;
	int empty_y;

	FindTile(board, tile, &i, &j);

	FindTile(board, -1, &empty_x, &empty_y);

		if (empty_y == j && ((empty_x - i == 1) || (empty_x - i == -1))) {
		board[empty_x][empty_y] = board[i][j];
		board[i][j] = -1;
	}

		if (empty_x == i && ((empty_y - j == 1) || (empty_y - j == -1))) {
		board[empty_x][empty_y] = board[i][j];
		board[i][j] = -1;
		}
	}",1
rkar406,1695636382,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowblank, colblank;
	int rowtarget, coltarget;
	FindTile(board, -1, &rowblank, &colblank);
	FindTile(board, tile, &rowtarget, &coltarget);
	if (((rowtarget==rowblank-1)&&(coltarget == colblank))||((rowtarget == rowblank + 1) && (coltarget == colblank))||((rowtarget == rowblank) && (coltarget == colblank+1))||((rowtarget == rowblank) && (coltarget == colblank-1))){
		board[rowblank][colblank] = board[rowtarget][coltarget];
		board[rowtarget][coltarget] = -1;
	}
}",1
rkha931,1695782771,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row;
    int col;
    FindTile(board, tile, &row, &col);

    if (board[row-1][col] == -1) {
        board[row][col] = -1;
        board[row-1][col] = tile;
    }
    else if (board[row + 1][col] == -1) {
        board[row][col] = -1;
        board[row + 1][col] = tile;
    }

    else if (board[row][col-1] == -1){
        board[row][col] = -1;
        board[row][col-1] = tile;
    }

    else if (board[row][col+1] == -1) {
        board[row][col] = -1;
        board[row][col + 1] = tile;
    }

    else 
    board[row][col] = tile;

}",0
rkha931,1695782966,2,"#include <stdio.h>
#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row;
    int col;
    FindTile(board, tile, &row, &col);

    if (board[row-1][col] == -1) {
        board[row][col] = -1;
        board[row-1][col] = tile;
    }
    else if (board[row + 1][col] == -1) {
        board[row][col] = -1;
        board[row + 1][col] = tile;
    }

    else if (board[row][col-1] == -1){
        board[row][col] = -1;
        board[row][col-1] = tile;
    }

    else if (board[row][col+1] == -1) {
        board[row][col] = -1;
        board[row][col + 1] = tile;
    }

    else 
    board[row][col] = tile;

}",0
rkha931,1695855839,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row;
    int col;
    FindTile(board, tile, &row, &col);

    // if col > NUM_COLS-1
    // if row > NUM_ROWS -1 

    // Assuming row and col are in bounds

    if (row -1 >= 0 && board[row-1][col] == -1) {
        board[row][col] = -1;
        board[row-1][col] = tile;
    }
    else if (row + 1 <= NUM_ROWS -1 && board[row + 1][col] == -1) {
        board[row][col] = -1;
        board[row + 1][col] = tile;
    }

    else if (col -1 >= 0 && board[row][col-1] == -1){
        board[row][col] = -1;
        board[row][col-1] = tile;
    }

    else if (col + 1 <= NUM_COLS -1 && board[row][col+1] == -1) {
        board[row][col] = -1;
        board[row][col + 1] = tile;
    }

    else {
        board[row][col] = tile;
    }

}",1
rkir245,1696221574,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int blank_row_p, blank_col_p;
	int num_row_p, num_col_p;

	FindTile(board, -1, &blank_row_p, &blank_col_p);
	FindTile(board, tile, &num_row_p, &num_col_p);
	
	int temp;

	int blank_row, blank_col;
	int num_row, num_col;

	num_row = num_row_p;
	num_col = num_col_p;
	blank_row = blank_row_p;
	blank_col = blank_col_p;

	int move;

	if (blank_row == num_row)
	{
		if ((blank_col - num_col) == 1)
		{
			move = 1;
		}

		else if ((blank_col - num_col) == -1)
		{
			move = 1;
		}
		
		else{
			move = 0;
		}
	}

	else if (blank_col == num_col)
	{

		if (blank_row - num_row == 1)
		{
			move = 1;
		}
		else if (blank_row - num_row == -1)
		{
			move = 1;
		}
		else
		{
			move = 0;
		}	
	}

	else{
		move = 0;
	}


	if (move == 1)
	{
		temp = board[blank_row][blank_col];
		board[blank_row][blank_col] = board[num_row][num_col];
		board[num_row][num_col] = temp;	
	}
	else
	{

	}

}",1
rleg709,1696218220,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{ 
	int i, j, r1, c1, r, c, row1, col1;
	// Use a nested for loop to search for -1 and tile value in the 2D array.
	// Could also use FindTile function to do this.
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) { 
			if (board[i][j] == tile) {
				r = i; 
				c = j;
				} if (board[i][j] == -1) {
					r1 = i;
					c1 = j;
				}
		}
	}
	// Use if statements for constraints and restrictions when moving tiles in array.
	if ((r == r1 - 1) && (c == c1)) {
		board[r][c] = -1;
		board[r1][c1] = tile;
	} if ((r == r1 + 1) && (c == c1)) {
		board[r][c] = -1;
		board[r1][c1] = tile;		
	} if ((c == c1 - 1) && (r == r1) && (c != 0)) {
		board[r][c] = -1;
		board[r1][c1] = tile; 		
	} if ((c == c1 + 1) && (r == r1) && (c != 0)) {
		board[r][c] = -1;
		board[r1][c1] = tile;
	}
}",0
rleg709,1696224689,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{ 
	int i, j, r1, c1, r, c;
	// Use a nested for loop to search for -1 and tile value in the 2D array.
	// Could also use FindTile function to do this.
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) { 
			if (board[i][j] == tile) {
				r = i; 
				c = j;
				} if (board[i][j] == -1) {
					r1 = i;
					c1 = j;
				}
		}
	}
	// Use if statements for constraints and restrictions when moving tiles in array.
	if ((r == r1 - 1) && c == c1) {
		board[r][c] = -1;
		board[r1][c1] = tile;
	}
	if ((r == r1 + 1) && c == c1) {
		board[r][c] = -1;
		board[r1][c1] = tile;
	} 
	if ((c == c1 - 1) && r == r1 && c1 != 0) {
		board[r][c] = -1;
		board[r1][c1] = tile; 		
	}
	if ((c == c1 + 1) && r == r1 && c != 0) {
		board[r][c] = -1;
		board[r1][c1] = tile;
	}
}",1
rlin108,1696147710,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int newtilexPosition, newtileyPosition;
	int initialtilexPosition, initialtileyPosition;
	int temp;

	FindTile(board, tile, &newtileyPosition, &newtilexPosition);
	FindTile(board, -1, &initialtileyPosition, &initialtilexPosition);

	if (newtileyPosition != initialtileyPosition) {
		if ((initialtileyPosition == newtileyPosition - 1 && newtilexPosition == initialtilexPosition ||
			initialtileyPosition == newtileyPosition + 1 && newtilexPosition == initialtilexPosition)) {

			temp = board[newtileyPosition][newtilexPosition];
			board[newtileyPosition][newtilexPosition] = -1;
			board[initialtileyPosition][initialtilexPosition] = temp;
		}
	}
	else if (newtilexPosition != initialtilexPosition) {
		if ((initialtilexPosition == newtilexPosition - 1 && newtileyPosition == initialtileyPosition ||
			initialtilexPosition == newtilexPosition + 1 && newtileyPosition == initialtileyPosition)) {
			temp = board[newtileyPosition][newtilexPosition];
			board[newtileyPosition][newtilexPosition] = -1;
			board[initialtileyPosition][initialtilexPosition] = temp;
		}
	}
}",0
rlin108,1696147979,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int newtilexPosition, newtileyPosition;
	int initialtilexPosition, initialtileyPosition;
	int temp;

	FindTile(board, tile, &newtileyPosition, &newtilexPosition);
	FindTile(board, -1, &initialtileyPosition, &initialtilexPosition);

	if (newtileyPosition != initialtileyPosition) {
		if (((initialtileyPosition == newtileyPosition - 1) && (newtilexPosition == initialtilexPosition)) ||
			((initialtileyPosition == newtileyPosition + 1) && (newtilexPosition == initialtilexPosition))) {

			temp = board[newtileyPosition][newtilexPosition];
			board[newtileyPosition][newtilexPosition] = -1;
			board[initialtileyPosition][initialtilexPosition] = temp;
		}
	}
	else if (newtilexPosition != initialtilexPosition) {
		if (((initialtilexPosition == newtilexPosition - 1) && (newtileyPosition == initialtileyPosition)) ||
			((initialtilexPosition == newtilexPosition + 1) && (newtileyPosition == initialtileyPosition))) {
			temp = board[newtileyPosition][newtilexPosition];
			board[newtileyPosition][newtilexPosition] = -1;
			board[initialtileyPosition][initialtilexPosition] = temp;
		}
	}
}",1
rmar633,1696214114,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row1, col1, row, col, differencerow, differencecol;
    FindTile(board, -1, &row, &col);
    FindTile(board, tile, &row1, &col1);
    differencerow = row1 - row;
    differencecol = col1 - col;
    
    if (differencerow == -1 && differencecol == 0 )
    {
        board[row][col] = tile;
        board[row1][col1] = -1;
    }
    if (differencerow == 0 && differencecol == -1 )
    {
        board[row][col] = tile;
        board[row1][col1] = -1;
    }
    if (differencerow == 1 && differencecol == 0 )
    {
        board[row][col] = tile;
        board[row1][col1] = -1;
    }
    if (differencerow == 0 && differencecol == 1 )
    {
        board[row][col] = tile;
        board[row1][col1] = -1;
    }
    
}",1
rmur989,1696215486,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int colPos;
    int rowPos;
    
    FindTile(board, -1, &rowPos, &colPos);

    if (tile > 0) {
        
        if (rowPos > 0 && board[rowPos - 1][colPos] == tile) {
            board[rowPos][colPos] = tile;
            board[rowPos - 1][colPos] = -1;
            return;
        }

        if (rowPos < NUM_ROWS - 1 && board[rowPos + 1][colPos] == tile) {
            board[rowPos][colPos] = tile;
            board[rowPos + 1][colPos] = -1;
            return;
        }

        if (colPos > 0 && board[rowPos][colPos - 1] == tile) {
            board[rowPos][colPos] = tile;
            board[rowPos][colPos - 1] = -1;
            return;
        }

        if (colPos < NUM_COLS - 1 && board[rowPos][colPos + 1] == tile) {
            board[rowPos][colPos] = tile;
            board[rowPos][colPos + 1] = -1;
            return;
        }
    }
}",1
rnga701,1695883203,1,"#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col;
    FindTile(board, tile, &row, &col);
    
    if (row < NUM_ROWS - 1 && board[row + 1][col] == -1) {
        board[row + 1][col] = tile;
        board[row][col] = -1;
    } else if (row > 0 && board[row - 1][col] == -1) {
        board[row - 1][col] = tile;
        board[row][col] = -1;
    } else if (col < NUM_COLS - 1 && board[row][col + 1] == -1) {
        board[row][col + 1] = tile;
        board[row][col] = -1;
    } else if (col > 0 && board[row][col - 1] == -1) {
        board[row][col - 1] = tile;
        board[row][col] = -1;
    }
}",1
rnig735,1696068781,1,"#include <stdio.h>
#include <stdlib.h>
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int tilePos[2], spacePos[2];
    
    FindTile(board, tile, &tilePos[0], &tilePos[1]);
    FindTile(board, -1, &spacePos[0], &spacePos[1]);
    if ((spacePos[0] == tilePos[0] || spacePos[1] == tilePos[1]) && (abs(spacePos[0]-tilePos[0]) == 1 || abs(spacePos[1]-tilePos[1]) == 1))  {
        board[spacePos[0]][spacePos[1]] = tile;
        board[tilePos[0]][tilePos[1]] = -1;
    }
}",1
rpar376,1695891224,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int posr,posc,spacer,spacec;
    
    for (int i=0;i<NUM_ROWS;i++){
        for(int j=0;j<NUM_COLS;j++){
            if (board[i][j]==tile) {
                posr=i;
                posc=j;
            } else if (board[i][j]==-1) {
                spacer=i;
                spacec=j;
            }
        }
    }
    if ((spacer-posr==-1||spacer-posr==1&&spacec-posc==0)||(spacer-posr==0&&spacec-posc==1||spacer-posr==-1)) {
        board[spacer][spacec]=tile;
        board[posr][posc]=-1;
    }
    
}",0
rpar376,1695891371,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int posr,posc,spacer,spacec;
    
    for (int i=0;i<NUM_ROWS;i++){
        for(int j=0;j<NUM_COLS;j++){
            if (board[i][j]==tile) {
                posr=i;
                posc=j;
            } else if (board[i][j]==-1) {
                spacer=i;
                spacec=j;
            }
        }
    }
    if (((spacer-posr==-1||spacer-posr==1)&&(spacec-posc==0))||((spacer-posr==0)&&(spacec-posc==1||spacer-posr==-1))) {
        board[spacer][spacec]=tile;
        board[posr][posc]=-1;
    }
    
}",0
rpar376,1696041718,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int posr,posc,spacer,spacec;
    
    for (int i=0;i<NUM_ROWS;i++){
        for(int j=0;j<NUM_COLS;j++){
            if (board[i][j]==tile) {
                posr=i;
                posc=j;
            } else if (board[i][j]==-1) {
                spacer=i;
                spacec=j;
            }
        }
    }
    if (((spacer-posr==-1||spacer-posr==1)&&(spacec-posc==0))||((spacer-posr==0)&&(spacec-posc==1||spacec-posc==-1))) {
        board[spacer][spacec]=tile;
        board[posr][posc]=-1;
    }
    
}",1
rpat943,1695868702,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col;
    FindTile(board, tile, &row, &col);
    if (board[row + 1][col] == -1) {
        board[row + 1][col] = board[row][col];
        board[row][col] = -1;
    } else if (board[row - 1][col] == -1) {
        board[row - 1][col] = board[row][col];
        board[row][col] = -1; 
    } else if (board[row][col + 1] == -1) {
        board[row][col + 1] = board[row][col];
        board[row][col] = -1;
    } else if (board[row][col - 1] == -1) {
        board[row][col - 1] = board[row][col];
        board[row][col] = -1;
    }
    
}",0
rpat943,1695884411,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col, erow, ecol;
    FindTile(board, tile, &row, &col);
    FindTile(board, -1, &erow, &ecol);
    if (row - erow == 1 && col == ecol || erow - row == 1 && col == ecol || col - ecol == 1 && row == erow|| ecol - col == 1 && row == erow) {
        board[erow][ecol] = board[row][col];
        board[row][col] = -1;
    } else {
        board = board;
    }
    
}",0
rpat943,1695884487,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col, erow, ecol;
    FindTile(board, tile, &row, &col);
    FindTile(board, -1, &erow, &ecol);
    if ((row - erow == 1 && col == ecol) || (erow - row == 1 && col == ecol) || (col - ecol == 1 && row == erow) || (ecol - col == 1 && row == erow)) {
        board[erow][ecol] = board[row][col];
        board[row][col] = -1;
    } else {
        board = board;
    }
    
}",1
rraj313,1695674463,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j, EmptyRow = 0, EmptyCol = 0, rowPos, colPos;
	FindTile(board, tile, &rowPos, &colPos);
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == -1) {
				EmptyRow = i;
				EmptyCol = j;
			}
		}
	}

	if (((EmptyCol - colPos)*(EmptyCol - colPos) == 1 && (EmptyRow - rowPos)*(EmptyRow - rowPos) == 0) || ((EmptyCol - colPos)*(EmptyCol - colPos) == 0 && (EmptyRow - rowPos)*(EmptyRow - rowPos) == 1)) {
		board[rowPos][colPos] = -1;
		board[EmptyRow][EmptyCol] = tile;
	}
}",1
rroz381,1696227802,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col;
    FindTile(board, tile, &row, &col);
    

        if (board[row+1][col] == -1) {
            board[row+1][col] = tile;
            board[row][col] = -1;
        }
        else if (board[row-1][col] == -1) {
            board[row-1][col] = tile;
            board[row][col] = -1;
        }
        else if (board[row][col+1] == -1) {
            board[row][col+1] = tile;
            board[row][col] = -1;
        }
        else if (board[row][col-1] == -1) {
            board[row][col-1] = tile;
            board[row][col] = -1;
        }
    
}",0
rroz381,1696237995,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col;
    int diffrow, diffcol;
    FindTile(board, tile, &row, &col);
    FindTile(board, -1, &diffrow, &diffcol);

    if (board[row+1][col] == -1) {
            board[row+1][col] = tile;
            board[row][col] = -1;
        }
        else if (board[row-1][col] == -1) {
            board[row-1][col] = tile;
            board[row][col] = -1;
        }
        else if (row == diffrow) {
            if (board[row][col+1] == -1) {
            board[row][col+1] = tile;
            board[row][col] = -1;
            }
            else if (board[row][col-1] == -1) {
            board[row][col-1] = tile;
            board[row][col] = -1;
            }
        }
        
    
}",1
rsha769,1695864332,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{

    int tileRow, tileCol, emptyRow, emptyCol;

    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol);
    
    //determining if the tile can be swapped with the empty square
   

    if (tileRow == emptyRow && tileCol == emptyCol - 1) {
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
    if (tileRow == emptyRow && tileCol == emptyCol + 1) {
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
    if (tileCol == emptyCol && tileRow == emptyRow - 1) {
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
    if (tileCol == emptyCol && tileRow == emptyRow + 1) {
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }

}",1
rsha970,1695857630,1,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol;
    int tileRow, tileCol;

    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);

    if (abs(emptyRow - tileRow) + abs(emptyCol - tileCol) == 1) {

        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}
",1
rsin531,1696227564,1,"#include <stdio.h>
#include <stdlib.h> 

#define NUM_ROWS 4  
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRowPos, tileColPos;
    int emptyRowPos, emptyColPos;

    FindTile(board, tile, &tileRowPos, &tileColPos);
    FindTile(board, -1, &emptyRowPos, &emptyColPos);

    if ((abs(tileRowPos - emptyRowPos) == 1 && tileColPos == emptyColPos) ||
        (abs(tileColPos - emptyColPos) == 1 && tileRowPos == emptyRowPos)) {

        board[emptyRowPos][emptyColPos] = tile;
        board[tileRowPos][tileColPos] = -1;
    }
}",1
rsin719,1696065295,1,"
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol, tileRow, tileCol;

    // Find the positions of the empty tile and the tile to be moved
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);

    // Check if the tile can be moved (adjacent to the empty square)
    if ((abs(emptyRow - tileRow) == 1 && emptyCol == tileCol) ||
        (emptyRow == tileRow && abs(emptyCol - tileCol) == 1)) {
        
        // Swap the empty tile and the target tile
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}

void PrintBoard(int board[NUM_ROWS][NUM_COLS]) {
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == -1) {
                printf(""_ "");
            } else {
                printf(""%2d "", board[i][j]);
            }
        }
        printf(""\n"");
    }
}

",0
rsin719,1696065311,2,"
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol, tileRow, tileCol;

    // Find the positions of the empty tile and the tile to be moved
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);

    // Check if the tile can be moved (adjacent to the empty square)
    if ((abs(emptyRow - tileRow) == 1 && emptyCol == tileCol) ||
        (emptyRow == tileRow && abs(emptyCol - tileCol) == 1)) {
        
        // Swap the empty tile and the target tile
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}



",1
rsmi948,1695678029,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int total, col_length, row_length, *rowPos_empty, *colPos_empty, *rowPos_tile, *colPos_tile;

	total = sizeof(*board);
	col_length = sizeof((*board)[0]);
	row_length = total / col_length;

	for (int i = 0; i < row_length; i++){
		for (int j = 0; j < col_length; j++){
			if (board[i][j] == -1) {
				*rowPos_empty = i;
				*colPos_empty = j;
			} else if (board[i][j] == tile){
				*rowPos_tile = i;
				*colPos_empty = j;
			}
		}
	}

	if (
		(*colPos_empty == *colPos_tile && (*rowPos_empty - 1 == *rowPos_tile || *rowPos_empty + 1 == *rowPos_tile)) 
		^
		(*rowPos_empty == *rowPos_tile && (*colPos_empty - 1 == *colPos_tile || *colPos_empty + 1 == *colPos_tile))
		){
			board[*rowPos_empty][*colPos_empty] = tile;
			board[*rowPos_tile][*colPos_tile] = -1;
		}

}",0
rsmi948,1695678428,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int total, col_length, row_length, rowPos_empty, colPos_empty, rowPos_tile, colPos_tile;

	total = sizeof(*board);
	col_length = sizeof((*board)[0]);
	row_length = total / col_length;

	for (int i = 0; i < row_length; i++){
		for (int j = 0; j < col_length; j++){
			if (board[i][j] == -1) {
				rowPos_empty = i;
				colPos_empty = j;
			} else if (board[i][j] == tile){
				rowPos_tile = i;
				colPos_empty = j;
			}
		}
	}

	if (
		(colPos_empty == colPos_tile && (rowPos_empty - 1 == rowPos_tile || rowPos_empty + 1 == rowPos_tile)) 
		^
		(rowPos_empty == rowPos_tile && (colPos_empty - 1 == colPos_tile || colPos_empty + 1 == colPos_tile))
		){
			board[rowPos_empty][colPos_empty] = tile;
			board[rowPos_tile][colPos_tile] = -1;
		}

}",0
rsmi948,1695678926,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int total, col_length, row_length, rowPos_empty, colPos_empty, rowPos_tile, colPos_tile;

	total = sizeof(*board);
	col_length = sizeof((*board)[0]);
	row_length = total / col_length;

	for (int i = 0; i < row_length; i++){
		for (int j = 0; j < col_length; j++){
			if (board[i][j] == -1) {
				rowPos_empty = i;
				colPos_empty = j;
			} else if (board[i][j] == tile){
				rowPos_tile = i;
				colPos_tile = j;
			}
		}
	}

	if (
		(colPos_empty == colPos_tile && (rowPos_empty - 1 == rowPos_tile || rowPos_empty + 1 == rowPos_tile)) 
		^
		(rowPos_empty == rowPos_tile && (colPos_empty - 1 == colPos_tile || colPos_empty + 1 == colPos_tile))
		){
			board[rowPos_empty][colPos_empty] = tile;
			board[rowPos_tile][colPos_tile] = -1;
		}

}",1
rsta265,1695797511,1,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    int row1, col1;
    int row2, col2;
    FindTile(board, tile, &row1, &col1);
    FindTile(board, -1, &row2, &col2);
    if ((row1 == row2 && (col1 == col2-1 || col1 == col2+1) ) || (col1 == col2 && (row1 == row2-1 || row1 == row2+1))){
        int original = board[row2][col2];
        board[row2][col2] = board[row1][col1];
        board[row1][col1] = original;
    }
    return;
    
}",1
rtan654,1695806904,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{   
    int row1 = 0, col1 = 0, row2 = 0, col2 = 0;
    FindTile(board, -1, &row1, &col1);
    FindTile(board, tile, &row2, &col2);

    // Check if both tiles are within bounds
    if (row1 >= 0 && row1 < NUM_ROWS && col1 >= 0 && col1 < NUM_COLS && row2 >= 0 && row2 < NUM_ROWS && col2 >= 0 && col2 < NUM_COLS) {
        
        // Check if tiles are adjacent
        if ((row2 == row1 && (col2 == col1 + 1 || col2 == col1 - 1)) ||
            (col2 == col1 && (row2 == row1 + 1 || row2 == row1 - 1))) {
            
			board[row1][col1] = board[row2][col2];
 
			board[row2][col2] = -1;
        }
    }
}",1
rtap592,1696151976,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int emptyRow, emptyCol, tileRow, tileCol;

	FindTile(board, -1, &emptyRow, &emptyCol);
	FindTile(board, tile, &tileRow, &tileCol);

	if (abs(tileRow - emptyRow) + abs((tileCol - emptyCol) == 1)) {
		board[emptyRow][emptyCol] = tile;
		board[tileRow][tileCol] = -1;
	}

}",0
rtap592,1696222550,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int emptyRow, emptyCol, tileRow, tileCol;

	FindTile(board, -1, &emptyRow, &emptyCol);
	FindTile(board, tile, &tileRow, &tileCol);

	if (abs(tileRow - emptyRow) + abs(tileCol - emptyCol) == 1) {
		board[emptyRow][emptyCol] = tile;
		board[tileRow][tileCol] = -1;
	}

}",1
rvog842,1696242835,1,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    
    int emptyRow, emptyCol, Row, Col;
    FindTile(board, -1, &emptyRow, &emptyCol); 
    FindTile(board, tile, &Row, &Col); 

    int rowDiff = Row - emptyRow;
    int colDiff = Col - emptyCol;

    if ((rowDiff == 0 && (colDiff == 1 || colDiff == -1)) ||
        (colDiff == 0 && (rowDiff == 1 || rowDiff == -1))) {
      
        board[emptyRow][emptyCol] = tile;
        board[Row][Col] = -1;
        
    }
}
",1
rwar748,1695803098,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
int *rowPos;
int *colPos;
int *rowPost;
int *colPost;
FindTile(board, -1, &rowPos, &colPos);
FindTile(board,  tile, &rowPost, &colPost);
if((rowPos - rowPost == -1 && colPost == colPos) || (rowPos - rowPost == 1 && colPost == colPos) || (colPos - colPost == -1 && rowPos == rowPost) || (colPos - colPost == 1 && rowPos == rowPost)){
	board[rowPos][colPos] = tile;
	board[rowPost][colPost] = -1;
	
}
}",0
rwar748,1695803147,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
int rowPos;
int colPos;
int rowPost;
int colPost;
FindTile(board, -1, &rowPos, &colPos);
FindTile(board,  tile, &rowPost, &colPost);
if((rowPos - rowPost == -1 && colPost == colPos) || (rowPos - rowPost == 1 && colPost == colPos) || (colPos - colPost == -1 && rowPos == rowPost) || (colPos - colPost == 1 && rowPos == rowPost)){
	board[rowPos][colPos] = tile;
	board[rowPost][colPost] = -1;
	
}
}",1
rzha972,1696126041,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{ 
    int posR,posC;
    int tileR, tileC;

    FindTile(board, tile, &tileR, &tileC);
    FindTile(board, -1, &posR, &posC);
    if (tileR > 0 && tileC > 0){
        if (board[tileR -1][tileC] == -1){
            board[tileR][tileC] = -1;
            board[tileR - 1][tileC] = tile;
        }
        else if (board[tileR + 1][tileC] == -1){
            board[tileR][tileC] = -1;
            board[tileR + 1][tileC] = tile;
        }
        else if (board[tileR][tileC - 1] == -1){
            board[tileR][tileC] = -1;
            board[tileR][tileC - 1] = tile;
        }
        else if (board[tileR][tileC + 1] == -1){
            board[tileR][tileC] = -1;
            board[tileR][tileC + 1] = tile;
        }
        else{
            return;
        }
    }

    else if(tileR == 3 && tileC == 3){
        if (board[tileR -1][tileC] == -1){
            board[tileR][tileC] = -1;
            board[tileR - 1][tileC] = tile;
        }
        else if (board[tileR][tileC - 1] == -1){
            board[tileR][tileC] = -1;
            board[tileR][tileC - 1] = tile;
        }
        else{
            return;
        }

    }
    else if(tileR == 0 && tileC == 0){
        if (board[tileR + 1][tileC] == -1){
            board[tileR][tileC] = -1;
            board[tileR + 1][tileC] = tile;
        }
        else if(board[tileR][tileC + 1] == -1){
            board[tileR][tileC] = -1;
            board[tileR][tileC + 1] = tile;
        }
        else{
            return;
        }

    }
    else if(tileR > 0 && tileC == 0){
        if (board[tileR + 1][tileC] == -1){
            board[tileR][tileC] = -1;
            board[tileR + 1][tileC] = tile;
        }
        else if (board[tileR - 1][tileC] == -1){
            board[tileR][tileC] = -1;
            board[tileR - 1][tileC] = tile;
        }
        else if(board[tileR][tileC + 1] == -1){
            board[tileR][tileC] = -1;
            board[tileR][tileC + 1] = tile;
        }
        else{
            return;
        }
    }
    else if(tileR == 0 && tileC > 0){
        if (board[tileR][tileC + 1] == -1){
            board[tileR][tileC] = -1;
            board[tileR][tileC + 1] = tile;
        }
        else if (board[tileR][tileC - 1] == -1){
            board[tileR][tileC] = -1;
            board[tileR][tileC - 1] = tile;
        }
        else if(board[tileR + 1][tileC] == -1){
            board[tileR][tileC] = -1;
            board[tileR + 1][tileC] = tile;
        }
        else{
            return;
        }
    }

    else if(tileR == 3 && tileC > 0){
        if (board[tileR - 1 ][tileC] == -1){
            board[tileR][tileC] = -1;
            board[tileR - 1][tileC] = tile;
        }
        else if (board[tileR][tileC + 1] == -1){
            board[tileR][tileC] = -1;
            board[tileR][tileC + 1] = tile;
        }
        else if(board[tileR][tileC + 1] == -1){
            board[tileR][tileC] = -1;
            board[tileR][tileC + 1] = tile;
        }
        else{
            return;
        }
    }
    else if(tileR > 0 && tileC == 3){
        if (board[tileR - 1 ][tileC] == -1){
            board[tileR][tileC] = -1;
            board[tileR - 1][tileC] = tile;
        }
        else if (board[tileR + 1][tileC] == -1){
            board[tileR][tileC] = -1;
            board[tileR + 1][tileC] = tile;
        }
        else if(board[tileR][tileC - 1] == -1){
            board[tileR][tileC] = -1;
            board[tileR][tileC - 1] = tile;
        }
        else{
            return;
        }
    }
    else if(tileR == 0 && tileC == 3){
        if (board[tileR + 1 ][tileC] == -1){
            board[tileR][tileC] = -1;
            board[tileR - 1][tileC] = tile;
        }
        else if (board[tileR][tileC - 1] == -1){
            board[tileR][tileC] = -1;
            board[tileR + 1][tileC] = tile;
        }
        else{
            return;
        }
    }
    else if(tileR == 3 && tileC == 0){
        if (board[tileR + 1 ][tileC] == -1){
            board[tileR][tileC] = -1;
            board[tileR + 1][tileC] = tile;
        }
        else if (board[tileR][tileC + 1] == -1){
            board[tileR][tileC] = -1;
            board[tileR + 1][tileC] = tile;
        }
        else{
            return;
        }
    }
}",1
rzha972,1696126399,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int tileR, tileC, emptyR, emptyC;
    FindTile(board, tile, &tileR, &tileC);
    FindTile(board, -1, &emptyR, &emptyC);

    // Calculate the absolute difference in row and column positions
    int rowDiff = abs(tileR - emptyR);
    int colDiff = abs(tileC - emptyC);

    // Check if the move is valid (adjacent tile)
    if ((rowDiff == 1 && colDiff == 0) || (rowDiff == 0 && colDiff == 1))
    {
        // Swap the tile with the empty space
        board[emptyR][emptyC] = tile;
        board[tileR][tileC] = -1;
    }
}
",1
rzha972,1696126461,3,"/* ENGGEN131 (2022) - Lab 9 (25th - 30th September, 2023)
   EXERCISE SEVEN and EIGHT - Sliding Tile Puzzle
*/
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

/* The dimensions of the puzzle */
#define NUM_ROWS 4
#define NUM_COLS 4

/* Function prototype declaration */
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile);
void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos);

void PrintBoard(int board[NUM_ROWS][NUM_COLS]);
int GetMove(void);
int GameOver(int board[NUM_ROWS][NUM_COLS]);

/* The main() function for the program.  This defines the starting position of
   the puzzle, and then uses a loop to get a move from the player, and update
   the board.  This loop continues to execute until the board is in the complete
   position */
int main(void)
{
	// The starting configuration of the sliding puzzle pieces
	int board[NUM_ROWS][NUM_COLS] = {
		{1, 2, 3, 4},
		{5, 6, 7, 8},
		{9, 10, 11, 12},
		{-1, 13, 14, 15}
	};
	int row, col;

	// Play the game until the board is in the complete position
	PrintBoard(board);
	while (!GameOver(board)) {
		FindTile(board, -1, &row, &col);
		printf(""Empty tile is at row=%d and col=%d.\nMake your move: "", row, col);
		MakeMove(board, GetMove());
		PrintBoard(board);
	}
	printf(""Congratulations - you won!"");

	return 0;
}

/************************************************************
YOU NEED TO COMPLETE THESE TWO FUNCTIONS ONLY
************************************************************/
void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos)
{
    int i,j;
    *rowPos = -1;
    *colPos = -1;
    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if (board[i][j] == tile){
                *rowPos = i;
                *colPos = j;
                return;
            }
                
        }
    }
    
}

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{ 
    int posR,posC;
    int tileR, tileC;

    FindTile(board, tile, &tileR, &tileC);
    FindTile(board, -1, &posR, &posC);
    if (tileR > 0 && tileC > 0){
        if (board[tileR -1][tileC] == -1){
            board[tileR][tileC] = -1;
            board[tileR - 1][tileC] = tile;
        }
        else if (board[tileR + 1][tileC] == -1){
            board[tileR][tileC] = -1;
            board[tileR + 1][tileC] = tile;
        }
        else if (board[tileR][tileC - 1] == -1){
            board[tileR][tileC] = -1;
            board[tileR][tileC - 1] = tile;
        }
        else if (board[tileR][tileC + 1] == -1){
            board[tileR][tileC] = -1;
            board[tileR][tileC + 1] = tile;
        }
        else{
            return;
        }
    }

    else if(tileR == 3 && tileC == 3){
        if (board[tileR -1][tileC] == -1){
            board[tileR][tileC] = -1;
            board[tileR - 1][tileC] = tile;
        }
        else if (board[tileR][tileC - 1] == -1){
            board[tileR][tileC] = -1;
            board[tileR][tileC - 1] = tile;
        }
        else{
            return;
        }

    }
    else if(tileR == 0 && tileC == 0){
        if (board[tileR + 1][tileC] == -1){
            board[tileR][tileC] = -1;
            board[tileR + 1][tileC] = tile;
        }
        else if(board[tileR][tileC + 1] == -1){
            board[tileR][tileC] = -1;
            board[tileR][tileC + 1] = tile;
        }
        else{
            return;
        }

    }
    else if(tileR > 0 && tileC == 0){
        if (board[tileR + 1][tileC] == -1){
            board[tileR][tileC] = -1;
            board[tileR + 1][tileC] = tile;
        }
        else if (board[tileR - 1][tileC] == -1){
            board[tileR][tileC] = -1;
            board[tileR - 1][tileC] = tile;
        }
        else if(board[tileR][tileC + 1] == -1){
            board[tileR][tileC] = -1;
            board[tileR][tileC + 1] = tile;
        }
        else{
            return;
        }
    }
    else if(tileR == 0 && tileC > 0){
        if (board[tileR][tileC + 1] == -1){
            board[tileR][tileC] = -1;
            board[tileR][tileC + 1] = tile;
        }
        else if (board[tileR][tileC - 1] == -1){
            board[tileR][tileC] = -1;
            board[tileR][tileC - 1] = tile;
        }
        else if(board[tileR + 1][tileC] == -1){
            board[tileR][tileC] = -1;
            board[tileR + 1][tileC] = tile;
        }
        else{
            return;
        }
    }

    else if(tileR == 3 && tileC > 0){
        if (board[tileR - 1 ][tileC] == -1){
            board[tileR][tileC] = -1;
            board[tileR - 1][tileC] = tile;
        }
        else if (board[tileR][tileC + 1] == -1){
            board[tileR][tileC] = -1;
            board[tileR][tileC + 1] = tile;
        }
        else if(board[tileR][tileC + 1] == -1){
            board[tileR][tileC] = -1;
            board[tileR][tileC + 1] = tile;
        }
        else{
            return;
        }
    }
    else if(tileR > 0 && tileC == 3){
        if (board[tileR - 1 ][tileC] == -1){
            board[tileR][tileC] = -1;
            board[tileR - 1][tileC] = tile;
        }
        else if (board[tileR + 1][tileC] == -1){
            board[tileR][tileC] = -1;
            board[tileR + 1][tileC] = tile;
        }
        else if(board[tileR][tileC - 1] == -1){
            board[tileR][tileC] = -1;
            board[tileR][tileC - 1] = tile;
        }
        else{
            return;
        }
    }
    else if(tileR == 0 && tileC == 3){
        if (board[tileR + 1 ][tileC] == -1){
            board[tileR][tileC] = -1;
            board[tileR - 1][tileC] = tile;
        }
        else if (board[tileR][tileC - 1] == -1){
            board[tileR][tileC] = -1;
            board[tileR + 1][tileC] = tile;
        }
        else{
            return;
        }
    }
    else if(tileR == 3 && tileC == 0){
        if (board[tileR + 1 ][tileC] == -1){
            board[tileR][tileC] = -1;
            board[tileR + 1][tileC] = tile;
        }
        else if (board[tileR][tileC + 1] == -1){
            board[tileR][tileC] = -1;
            board[tileR + 1][tileC] = tile;
        }
        else{
            return;
        }
    }
}
/************************************************************
YOU NEED TO COMPLETE THESE TWO FUNCTIONS ONLY
************************************************************/




/************************************************************
You do not need to modify any code below this point
************************************************************/
/* This function prints the board */
void PrintBoard(int board[NUM_ROWS][NUM_COLS])
{
	int i, j;
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == -1) {
				printf("" _ "");
			} else if (board[i][j] > 9) {   // align two-digit numbers
				printf("" %d"", board[i][j]);
			} else {
				printf("" %d "", board[i][j]);
			}
		}
		printf(""\n"");
	}
	printf(""\n"");
}

/* Prompt the user to enter a move (which will be an integer representing the tile
they wish to slide), and return this entered value */
int GetMove(void)
{
	int input;
	scanf(""%d"", &input);
	return input;
}

/* Check the tiles on the board to see if they are in the complete position.  Return
true if the puzzle is completed, and false otherwise */
int GameOver(int board[NUM_ROWS][NUM_COLS])
{
	int i, j;
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] != 1 + NUM_ROWS*i + j) {
				return ((i == NUM_ROWS-1) && (j == NUM_COLS-1));
			}
		}
	}
	return 0;
}
",0
rzha972,1696126535,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{ 
    int posR,posC;
    int tileR, tileC;

    FindTile(board, tile, &tileR, &tileC);
    FindTile(board, -1, &posR, &posC);
    if (tileR > 0 && tileC > 0){
        if (board[tileR -1][tileC] == -1){
            board[tileR][tileC] = -1;
            board[tileR - 1][tileC] = tile;
        }
        else if (board[tileR + 1][tileC] == -1){
            board[tileR][tileC] = -1;
            board[tileR + 1][tileC] = tile;
        }
        else if (board[tileR][tileC - 1] == -1){
            board[tileR][tileC] = -1;
            board[tileR][tileC - 1] = tile;
        }
        else if (board[tileR][tileC + 1] == -1){
            board[tileR][tileC] = -1;
            board[tileR][tileC + 1] = tile;
        }
        else{
            return;
        }
    }

    else if(tileR == 3 && tileC == 3){
        if (board[tileR -1][tileC] == -1){
            board[tileR][tileC] = -1;
            board[tileR - 1][tileC] = tile;
        }
        else if (board[tileR][tileC - 1] == -1){
            board[tileR][tileC] = -1;
            board[tileR][tileC - 1] = tile;
        }
        else{
            return;
        }

    }
    else if(tileR == 0 && tileC == 0){
        if (board[tileR + 1][tileC] == -1){
            board[tileR][tileC] = -1;
            board[tileR + 1][tileC] = tile;
        }
        else if(board[tileR][tileC + 1] == -1){
            board[tileR][tileC] = -1;
            board[tileR][tileC + 1] = tile;
        }
        else{
            return;
        }

    }
    else if(tileR > 0 && tileC == 0){
        if (board[tileR + 1][tileC] == -1){
            board[tileR][tileC] = -1;
            board[tileR + 1][tileC] = tile;
        }
        else if (board[tileR - 1][tileC] == -1){
            board[tileR][tileC] = -1;
            board[tileR - 1][tileC] = tile;
        }
        else if(board[tileR][tileC + 1] == -1){
            board[tileR][tileC] = -1;
            board[tileR][tileC + 1] = tile;
        }
        else{
            return;
        }
    }
    else if(tileR == 0 && tileC > 0){
        if (board[tileR][tileC + 1] == -1){
            board[tileR][tileC] = -1;
            board[tileR][tileC + 1] = tile;
        }
        else if (board[tileR][tileC - 1] == -1){
            board[tileR][tileC] = -1;
            board[tileR][tileC - 1] = tile;
        }
        else if(board[tileR + 1][tileC] == -1){
            board[tileR][tileC] = -1;
            board[tileR + 1][tileC] = tile;
        }
        else{
            return;
        }
    }

    else if(tileR == 3 && tileC > 0){
        if (board[tileR - 1 ][tileC] == -1){
            board[tileR][tileC] = -1;
            board[tileR - 1][tileC] = tile;
        }
        else if (board[tileR][tileC + 1] == -1){
            board[tileR][tileC] = -1;
            board[tileR][tileC + 1] = tile;
        }
        else if(board[tileR][tileC + 1] == -1){
            board[tileR][tileC] = -1;
            board[tileR][tileC + 1] = tile;
        }
        else{
            return;
        }
    }
    else if(tileR > 0 && tileC == 3){
        if (board[tileR - 1 ][tileC] == -1){
            board[tileR][tileC] = -1;
            board[tileR - 1][tileC] = tile;
        }
        else if (board[tileR + 1][tileC] == -1){
            board[tileR][tileC] = -1;
            board[tileR + 1][tileC] = tile;
        }
        else if(board[tileR][tileC - 1] == -1){
            board[tileR][tileC] = -1;
            board[tileR][tileC - 1] = tile;
        }
        else{
            return;
        }
    }
    else if(tileR == 0 && tileC == 3){
        if (board[tileR + 1 ][tileC] == -1){
            board[tileR][tileC] = -1;
            board[tileR - 1][tileC] = tile;
        }
        else if (board[tileR][tileC - 1] == -1){
            board[tileR][tileC] = -1;
            board[tileR + 1][tileC] = tile;
        }
        else{
            return;
        }
    }
    else if(tileR == 3 && tileC == 0){
        if (board[tileR + 1 ][tileC] == -1){
            board[tileR][tileC] = -1;
            board[tileR + 1][tileC] = tile;
        }
        else if (board[tileR][tileC + 1] == -1){
            board[tileR][tileC] = -1;
            board[tileR + 1][tileC] = tile;
        }
        else{
            return;
        }
    }
}",1
sabo272,1695782581,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{

	 int emptyRowPos, emptyColPos;
	 FindTile(board, -1, &emptyRowPos, &emptyColPos);
	 int i, j;
		for (i = 0; i < 4; i++) {
			for (j = 0; j < 4; j ++) {
				if (board[i][j] == tile) {
					if (((i == emptyRowPos + 1) && j == emptyColPos) ||
						((i == emptyRowPos - 1) && j == emptyColPos) ||
						((i == emptyRowPos) && j == emptyColPos + 1) || ((i == emptyRowPos) && j == emptyColPos-1)) {
							board[i][j] = -1; // if tile is adjacent to empty tile, swap their positions.
							board[emptyRowPos][emptyColPos] = tile;
					}
				}
			}
		}
}",1
sali153,1695790178,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tile_x = 0;
	int tile_y = 0;  
	int empty_x = 0;
	int empty_y = 0;
	FindTile(board, -1, &empty_x, &empty_y);
	FindTile(board, tile, &tile_x, &tile_y);
	if(abs(tile_x - empty_x) + abs(tile_y - empty_y) == 1)
	{
		board[empty_x][empty_y] = tile;
		board[tile_x][tile_y] = -1;
	}
}",1
sban919,1695626322,1,"#include <stdio.h>

/* MakeMove function takes an integer array and a specific value as inputs
, finds the location of -1 and the specific value by using the FindTile function
, then swaps the two only when they are adjacent. */

/* Author: Subeen Ban */

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowPos, colPos, tileRow, tileCol;
    
    FindTile(board, -1, &rowPos, &colPos);
    FindTile(board, tile, &tileRow, &tileCol);
    
    if (((rowPos - tileRow == 1) && (colPos == tileCol)) || ((colPos - tileCol == 1) && (rowPos == tileRow))
    {
        board[rowPos][colPos] = tile;
        board[tileRow][tileCol] = -1;
    }

}",0
sban919,1695626333,2,"#include <stdio.h>

/* MakeMove function takes an integer array and a specific value as inputs
, finds the location of -1 and the specific value by using the FindTile function
, then swaps the two only when they are adjacent. */

/* Author: Subeen Ban */

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowPos, colPos, tileRow, tileCol;
    
    FindTile(board, -1, &rowPos, &colPos);
    FindTile(board, tile, &tileRow, &tileCol);
    
    if (((rowPos - tileRow == 1) && (colPos == tileCol)) || ((colPos - tileCol == 1) && (rowPos == tileRow)))
    {
        board[rowPos][colPos] = tile;
        board[tileRow][tileCol] = -1;
    }

}",0
sban919,1695627291,3,"#include <stdio.h>

/* MakeMove function takes an integer array and a specific value as inputs
, finds the location of -1 and the specific value by using the FindTile function
, then swaps the two only when they are adjacent. */

/* Author: Subeen Ban */

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowPos, colPos, tileRow, tileCol;
    
    FindTile(board, -1, &rowPos, &colPos);
    FindTile(board, tile, &tileRow, &tileCol);
    
    if (((colPos == tileCol) && ((rowPos - tileRow == -1) || (rowPos - tileRow == 1))) || 
    ((rowPos == tileRow) && ((colPos - tileCol == -1) || (colPos - tileCol == 1))))
    {
        board[rowPos][colPos] = tile;
        board[tileRow][tileCol] = -1;
    }

}",1
sbas887,1696135063,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == tile) {
                board[i][j] = -1;
            }
        }
    } 
}
",0
sbas887,1696136356,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int temp;
    int rowPos;
    int colPos;
    
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == tile) {
                board[i][j] = -1;
                rowPos = i;
                colPos = j;
            }
        }
    }
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (i == rowPos && j == colPos) {
                continue;
            }
            else if (board[i][j] == -1) {
                board[i][j] = tile;
            }
        }
    }
}",0
sbas887,1696136462,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int rowPos;
    int colPos;
    
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == tile) {
                board[i][j] = -1;
                rowPos = i;
                colPos = j;
            }
        }
    }
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (i == rowPos && j == colPos) {
                continue;
            }
            else if (board[i][j] == -1) {
                board[i][j] = tile;
            }
        }
    }
}",0
sbas887,1696148364,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int *rowPosPointer, *colPosPointer;
    int rowTile, colTile;
    int rowNeg, colNeg;
    rowPosPointer = &rowTile;
    colPosPointer = &colTile;
    
    FindTile(board, tile, rowPosPointer, colPosPointer);
    
    rowPosPointer = &rowNeg;
    colPosPointer = &colNeg;
    
    FindTile(board, -1, rowPosPointer, colPosPointer);

    if (rowNeg+1 == rowTile && colNeg == colTile) {
        if (rowNeg+1 != NUM_ROWS) {
            board[rowTile][colTile] = -1;
            board[rowNeg][colNeg] = tile;
        }
    }
    
    if (rowNeg-1 == rowTile && colNeg == colTile) {
        if (rowNeg-1 != -1) {
            board[rowTile][colTile] = -1;
            board[rowNeg][colNeg] = tile;
        }
    }
    
    if (colNeg+1 == colTile && rowNeg == rowTile) {
        if (colNeg+1 != NUM_COLS) {
            board[rowTile][colTile] = -1;
            board[rowNeg][colNeg] = tile;
        }
    }
    
    if (colNeg-1 == colTile && rowNeg == rowTile) {
        if (colNeg-1 != -1) {
            board[rowTile][colTile] = -1;
            board[rowNeg][colNeg] = tile;
        }
    }
    
}
",1
sben564,1696131048,1,"#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLUMNS], int tile) {
    
   FindTile(board, -1, &row, &col);
   FindTile(board, tile, &newrow, &newcol);
   
   if ((col == newcol && (row == newrow + 1 || row == newrow -1)) || (row == newrow && (col == newcol + 1 || col == newcol - 1))) {
       
       board[row][col] = tile;
       board[newrow][newcol] = -1;
   }
    
    
}",0
sben564,1696131077,2,"#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLUMNS], int tile) {
    
    int row, col, newrow, newcol;    
    
   FindTile(board, -1, &row, &col);
   FindTile(board, tile, &newrow, &newcol);
   
   if ((col == newcol && (row == newrow + 1 || row == newrow -1)) || (row == newrow && (col == newcol + 1 || col == newcol - 1))) {
       
       board[row][col] = tile;
       board[newrow][newcol] = -1;
   }
    
    
}",0
sben564,1696131121,3,"#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    
    int row, col, newrow, newcol;    
    
   FindTile(board, -1, &row, &col);
   FindTile(board, tile, &newrow, &newcol);
   
   if ((col == newcol && (row == newrow + 1 || row == newrow -1)) || (row == newrow && (col == newcol + 1 || col == newcol - 1))) {
       
       board[row][col] = tile;
       board[newrow][newcol] = -1;
   }
    
    
}",1
sbha564,1696236772,1,"void PerformMove(int gameBoard[NUM_ROWS][NUM_COLS], int movingTile) {
    int emptyTileRow, emptyTileCol, movingTileRow, movingTileCol;

    FindTile(gameBoard, -1, &emptyTileRow, &emptyTileCol);

    FindTile(gameBoard, movingTile, &movingTileRow, &movingTileCol);

    if ((emptyTileRow == movingTileRow && (emptyTileCol == movingTileCol - 1 || emptyTileCol == movingTileCol + 1)) ||
        (emptyTileCol == movingTileCol && (emptyTileRow == movingTileRow - 1 || emptyTileRow == movingTileRow + 1))) {

        gameBoard[emptyTileRow][emptyTileCol] = movingTile;
        gameBoard[movingTileRow][movingTileCol] = -1;
    }
}",0
sbha564,1696236921,2,"void MakeMove(int gameBoard[NUM_ROWS][NUM_COLS], int movingTile) {
    int emptyTileRow, emptyTileCol, movingTileRow, movingTileCol;

    FindTile(gameBoard, -1, &emptyTileRow, &emptyTileCol);

    FindTile(gameBoard, movingTile, &movingTileRow, &movingTileCol);

    if ((emptyTileRow == movingTileRow && (emptyTileCol == movingTileCol - 1 || emptyTileCol == movingTileCol + 1)) ||
        (emptyTileCol == movingTileCol && (emptyTileRow == movingTileRow - 1 || emptyTileRow == movingTileRow + 1))) {

        gameBoard[emptyTileRow][emptyTileCol] = movingTile;
        gameBoard[movingTileRow][movingTileCol] = -1;
    }
}",1
sbro373,1695767662,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int emptyRow, emptyCol;
	FindTile(board, -1, &emptyRow, &emptyCol);

	int tileRow, tileCol;
	FindTile(board, tile, &tileRow, &tileCol);

	// Check above
	if (tileRow - 1 >= 0) {
		if (board[tileRow - 1][tileCol] == -1) {
			board[emptyRow][emptyCol] = tile;
			board[tileRow][tileCol] = -1;
			return;
		}
	}

	// Check below
	if (tileRow + 1 < NUM_ROWS) {
		if (board[tileRow + 1][tileCol] == -1) {
			board[emptyRow][emptyCol] = tile;
			board[tileRow][tileCol] = -1;
			return;
		}
	}

	// Check left
	if (tileCol - 1 >= 0) {
		if (board[tileRow][tileCol - 1] == -1) {
			board[emptyRow][emptyCol] = tile;
			board[tileRow][tileCol] = -1;
			return;
		}
	}

	// Check right
	if (tileCol + 1 < NUM_COLS) {
		if (board[tileRow][tileCol + 1] == -1) {
			board[emptyRow][emptyCol] = tile;
			board[tileRow][tileCol] = -1;
			return;
		}
	}
}",1
scar362,1696111575,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowPos, colPos;
    FindTile(board, tile, &rowPos, &colPos);

    if (board[rowPos][colPos + 1] == -1) {
        board[rowPos][colPos]=-1;
        board[rowPos][colPos+1]=tile;
    }
    if (board[rowPos][colPos - 1] == -1) {
        board[rowPos][colPos]=-1;
        board[rowPos][colPos-1]=tile;
    }
    if (board[rowPos+1][colPos] == -1) {
        board[rowPos][colPos]=-1;
        board[rowPos+1][colPos]=tile;
    } 
    if (board[rowPos-1][colPos] == -1) {
        board[rowPos][colPos]=-1;
        board[rowPos-1][colPos]=tile;
    } 
}",0
scar362,1696112507,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowPos, colPos;
    FindTile(board, tile, &rowPos, &colPos);

    if (colPos + 1 < NUM_COLS && board[rowPos][colPos + 1] == -1) {
        board[rowPos][colPos]=-1;
        board[rowPos][colPos+1]=tile;
    }
    if (colPos - 1 >= 0 && board[rowPos][colPos - 1] == -1) {
        board[rowPos][colPos]=-1;
        board[rowPos][colPos-1]=tile;
    }
    if (rowPos + 1 < NUM_ROWS && board[rowPos+1][colPos] == -1) {
        board[rowPos][colPos]=-1;
        board[rowPos+1][colPos]=tile;
    } 
    if (rowPos - 1 >= 0 && board[rowPos-1][colPos] == -1) {
        board[rowPos][colPos]=-1;
        board[rowPos-1][colPos]=tile;
    } 
}",1
sche525,1695637508,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    int rowPos, colPos, rowNull, colNull;
    FindTile(board, tile, &rowPos, &colPos);
    for(int i = 0; i < NUM_ROWS; i++){
        for(int j = 0; j < NUM_COLS; j++){
            if(board[i][j] == -1){
                rowNull = i;
                colNull = j;
            }
        }
    }

    if(abs(rowPos - rowNull) == 1 && colPos == colNull){
        board[rowNull][colPos] = board[rowPos][colPos];
        board[rowPos][colPos] = -1;
    }
	
    if(abs(colPos - colNull && rowPos == rowNull) == 1){
        board[rowPos][colNull] = board[rowPos][colPos];
        board[rowPos][colPos] = -1;
    }
}",1
scho575,1696205352,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRow, tileCol;
    FindTile(board, tile, &tileRow, &tileCol);

    if (tileRow == -1 || tileCol == -1) {
        printf(""Tile not found on the board.\n"");
        return;
    }

    // Check if the value is next to the empty spot
    if ((tileRow > 0 && board[tileRow - 1][tileCol] == -1) ||
        (tileRow < NUM_ROWS - 1 && board[tileRow + 1][tileCol] == -1) ||
        (tileCol > 0 && board[tileRow][tileCol - 1] == -1) ||
        (tileCol < NUM_COLS - 1 && board[tileRow][tileCol + 1] == -1)) {

        // Swap the selected value with empty square
        int emptyRow, emptyCol;
        FindTile(board, -1, &emptyRow, &emptyCol);
        
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    } else {
        printf(""Tile cannot be moved, it's not adjacent to the empty square.\n"");
    }
}",0
scho575,1696205426,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRow, tileCol;
    FindTile(board, tile, &tileRow, &tileCol);

    if (tileRow == -1 || tileCol == -1) {
        printf(""Tile not found on the board.\n"");
        return;
    }

    // Check if the value is next to the empty spot
    if ((tileRow > 0 && board[tileRow - 1][tileCol] == -1) ||
        (tileRow < NUM_ROWS - 1 && board[tileRow + 1][tileCol] == -1) ||
        (tileCol > 0 && board[tileRow][tileCol - 1] == -1) ||
        (tileCol < NUM_COLS - 1 && board[tileRow][tileCol + 1] == -1)) {

        // Swap the selected value with empty square
        int emptyRow, emptyCol;
        FindTile(board, -1, &emptyRow, &emptyCol);
        
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}",1
schu718,1695951599,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col, emptyrow, emptycol;
    
    FindTile(board, tile, &row, &col);
    FindTile(board, -1, &emptyrow, &emptycol);
    
    if((emptyrow == row && emptycol == col + 1) || (emptyrow == row && emptycol == col - 1))
    {
        int a,b;
        a = board[row][col];
        b = board[emptyrow][emptycol];
        board[row][col] = b;
        board[emptyrow][emptycol] = a;
    }
    
    if((emptyrow == row + 1 && emptycol == col) || (emptyrow == row - 1 && emptycol == col))
    {
        int a,b;
        a = board[row][col];
        b = board[emptyrow][emptycol];
        board[row][col] = b;
        board[emptyrow][emptycol] = a;
    }
    return 0;
}
",0
schu718,1695951645,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col, emptyrow, emptycol;
    
    FindTile(board, tile, &row, &col);
    FindTile(board, -1, &emptyrow, &emptycol);
    
    if((emptyrow == row && emptycol == col + 1) || (emptyrow == row && emptycol == col - 1))
    {
        int a,b;
        a = board[row][col];
        b = board[emptyrow][emptycol];
        board[row][col] = b;
        board[emptyrow][emptycol] = a;
    }
    
    if((emptyrow == row + 1 && emptycol == col) || (emptyrow == row - 1 && emptycol == col))
    {
        int a,b;
        a = board[row][col];
        b = board[emptyrow][emptycol];
        board[row][col] = b;
        board[emptyrow][emptycol] = a;
    }
    
}
",1
sdal739,1695901909,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int targetrow, targetcol;
	int currentrow, currentcol;
	int temp;
	temp = 0;

	FindTile(board, tile, &targetrow, &targetcol);
	FindTile(board, -1, &currentrow, &currentcol);

	// ((((targetrow - 1) != currentrow) || ((targetrow + 1) != currentrow)) && (((targetcol - 1) != currentcol) || ((targetcol + 1) != currentcol)))

	if  (((targetcol - 1 == currentcol) && (targetrow == currentrow)) || ((targetcol + 1 == currentcol) && (targetrow == currentrow)) || ((targetrow - 1 == currentrow) && (targetcol == currentcol)) || ((targetrow + 1 == currentrow) && (targetcol == currentcol))) {
		temp = board[currentrow][currentcol];
		board[currentrow][currentcol] = board[targetrow][targetcol];
		board[targetrow][targetcol] = temp;
	}

}",1
sden589,1696243093,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol;
    int tileRow, tileCol;

    FindTile(board, -1, &emptyRow, &emptyCol);

    FindTile(board, tile, &tileRow, &tileCol);

    if ((tileRow == emptyRow && (tileCol == emptyCol - 1 || tileCol == emptyCol + 1)) ||
        (tileCol == emptyCol && (tileRow == emptyRow - 1 || tileRow == emptyRow + 1))) {
            
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}
",1
sekb555,1695632825,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int input_r,input_c,move_r,move_c;
	FindTile(board, tile, &input_r, &input_c);
	FindTile(board, -1, &move_r, &move_c);
	
	//finds the position of the movement tile(-1) relative to the tile that the user inputed and only moves the movement tile if the input tile is adjacent to it
	if (((input_r - move_r) == 1 && input_c == move_c)|| ((input_r - move_r) == -1 && input_c == move_c)||
	((input_c - move_c) == 1 && input_r == move_r) || ((input_c - move_c) == -1 && input_r == move_r))
	{
		//moves the movement tile to the new location and the input tile to the old movement tile location
		board[move_r][move_c] = tile;
		board[input_r][input_c] = -1;
	}
	//if the tile is not adjacent no changes are made
	else
	{
		return;
	}
}",1
sgal263,1696232578,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowPos_ONE, colPos_ONE, rowPos_Switch, colPos_Switch;
    FindTile(board, -1 , &rowPos_ONE, &colPos_ONE);
    int Row_ONE = rowPos_ONE;
    int Col_ONE = colPos_ONE;

    FindTile(board, tile , &rowPos_Switch, &colPos_Switch);
    int Row_TWO = rowPos_Switch;
    int Col_TWO = colPos_Switch;

    int A = Row_TWO - Row_ONE;
    int B = Col_TWO - Col_ONE;

    if(((A == 1 || A == -1)&& B==0)||((B == 1 || B == -1) && A==0)){
        board[Row_ONE][Col_ONE] = tile;
        board[Row_TWO][Col_TWO] = -1;
return;
    }
return;
}
",1
shan333,1696225123,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, row1, col1;
	FindTile(board[NUM_ROWS][NUM_COLS], tile, &row, &col);
	FindTile(board[NUM_ROWS][NUM_COLS], -1, &row1, &col1);
	if (board[row +1][col] == -1 || board[row -1][col] == -1 || board[row][col + 1] == -1 || board[row +1][col] == -1) {
		board[row1][col1] = tile;
		board[row][col] = -1;
	}
}",0
shan333,1696225312,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, row1, col1;
	FindTile(board, tile, &row, &col);
	FindTile(board, -1, &row1, &col1);
	if (board[row +1][col] == -1 || board[row -1][col] == -1 || board[row][col + 1] == -1 || board[row +1][col] == -1) {
		board[row1][col1] = tile;
		board[row][col] = -1;
	}
}",0
shan333,1696225413,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, row1, col1;
	FindTile(board, tile, &row, &col);
	FindTile(board, -1, &row1, &col1);
	if (board[row +1][col] == -1 || board[row -1][col] == -1 || board[row][col + 1] == -1 || board[row][col - 1] == -1) {
		board[row1][col1] = tile;
		board[row][col] = -1;
	}
}",0
shan333,1696231574,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, row1, col1;
	FindTile(board, tile, &row, &col);
	FindTile(board, -1, &row1, &col1);


	if (board[row +1][col] == -1 && row +1 != 5 || board[row -1][col] == -1 && row -1 != -1 || board[row][col + 1] == -1 && col +1 != 5 || board[row][col - 1] == -1 && col - 1 != -1) {
		board[row1][col1] = tile;
		board[row][col] = -1;
	}
}",0
shan333,1696231705,5,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, row1, col1;
	FindTile(board, tile, &row, &col);
	FindTile(board, -1, &row1, &col1);


	if (((board[row +1][col] == -1) && (row +1 != 5)) || ((board[row -1][col] == -1) && (row -1 != -1)) || ((board[row][col + 1] == -1) && (col +1 != 5)) || ((board[row][col - 1] == -1) && (col - 1 != -1))) {
		board[row1][col1] = tile;
		board[row][col] = -1;
	}
}",1
shan790,1695899701,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{	
	int row, col;
	FindTile(board, -1, &row, &col);

	int left = 0, top = 0, right = 0, down = 0;

	top = board[row - 1][col];
	down = board[row + 1][col];
	left = board[row][col - 1];
	right = board[row][col + 1];

	if (row == 0) {
		top = 0;
	}
	if (row == NUM_ROWS - 1) {
		down = 0;
	}
	if (col == 0) {
		left = 0;
	}
	if (col == NUM_COLS - 1) {
		right = 0;
	}
	
	int rowTile, colTile;
	if (tile == top || tile == down || tile == left || tile == right) {
		FindTile(board, tile, &rowTile, &colTile);
		board[row][col] = board[rowTile][colTile];
		board[rowTile][colTile] = -1;
	}


}",1
she940,1695792068,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row;
	int col;
	
	FindTile(board, tile, &row, &col);

	if (row > 0) {
		if (board[row - 1][col] == -1) {
			board[row - 1][col] = board[row][col];
			board[row][col] = -1;
		}
	}

	if (col > 0) {
		if (board[row][col - 1] == -1) {
			board[row][col - 1] = board[row][col];
			board[row][col] = -1;
		}
	}

	if (row < 3) {
		if (board[row + 1][col] == -1) {
			board[row + 1][col] = board[row][col];
			board[row][col] = -1;
		}
	} 

	if (col < 3)  {
		if (board[row][col + 1] == -1) {
			board[row][col + 1] = board[row][col];
			board[row][col] = -1;
		}
	}

}",1
shsa718,1695895151,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row_empty,col_empty, element1, row_swap, col_swap, element2, placeholder;
    int* pointer1;
    int* pointer2;
    int adjacent = 0;


	// Find location of empty square
	FindTile(board, -1, &row_empty, &col_empty);
    element1 = (row_empty*4) + col_empty;


	// Find location of tile to swap
	FindTile(board, tile, &row_swap, &col_swap);
    element2 = (row_swap*4) + col_swap;

    //Check if tiles are adjacent
    if (element2==element1+4){
        if (row_empty != 3){
            adjacent = 1;
        }
    }
    else if(element2==element1-4){
        if (row_empty != 0) {
            adjacent = 1;
        }
    }
    else if(element2==element1+1){
        if(col_empty != 3){
            adjacent = 1;
        }
    }
    else if (element2==element1-1){
        if(col_empty != 0){
            adjacent = 1;
        }
    }

    // If they are adjacent, make the move!
    if (adjacent==1){
        pointer1 = &board[row_empty][col_empty]; 
        pointer2 = &board[row_swap][col_swap]; 
        placeholder = *pointer1; 
        *pointer1 = *pointer2;
        *pointer2 = placeholder; 
    }
    return;
}",1
shua365,1695687009,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    int tile_row, tile_col, none_row, none_col,temp_row,temp_col;
    FindTile(board,tile,&tile_row,&tile_col);
    FindTile(board,-1,&none_row,&none_col);
    if ((tile_row == none_row+1 )||(tile_row == none_row-1)){
        if (tile_col==none_col){
            board[none_row][none_col]=tile;
            board[tile_row][tile_col]=-1;
        }
    }

    if ((tile_col == none_col+1 )||(tile_row == none_col-1)){
        if (tile_row==none_row){
            board[none_row][none_col]=tile;
            board[tile_row][tile_col]=-1;
        };

    }
}
",0
shua365,1695687034,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    int tile_row, tile_col, none_row, none_col;
    FindTile(board,tile,&tile_row,&tile_col);
    FindTile(board,-1,&none_row,&none_col);
    if ((tile_row == none_row+1 )||(tile_row == none_row-1)){
        if (tile_col==none_col){
            board[none_row][none_col]=tile;
            board[tile_row][tile_col]=-1;
        }
    }

    if ((tile_col == none_col+1 )||(tile_row == none_col-1)){
        if (tile_row==none_row){
            board[none_row][none_col]=tile;
            board[tile_row][tile_col]=-1;
        };

    }
}
",1
shum116,1695799442,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j, row, col;
	int rtile, ctile;
	
	FindTile(board, -1, &row, &col);

	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++){
			if (board[i][j] == tile) {
				rtile = i;
				ctile = j;
			}
		}
	}

	if ((row == rtile && col == ctile - 1) || (row == rtile && col == ctile + 1) || (col == ctile && row == rtile - 1) || (col == ctile && row == rtile + 1)) {
		int temp = board[row][col];
		board[row][col] = board[rtile][ctile];
		board[rtile][ctile] = temp;
	}
	
}",1
sike083,1695885992,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row;
    int col;
    
    FindTile(board, tile, &row, &col);
    
    if (row - 1 >= 0) {
        if (board[row - 1][col] == -1) {
            board[row - 1][col] = tile;
            board[row][col] = -1;
        }
    }
    
    if (row + 1 < 4) {
        if (board[row + 1][col] == -1) {
            board[row + 1][col] = tile;
            board[row][col] = -1;
        }
    }
    
    if (col - 1 >= 0) {
        if (board[row][col - 1] == -1) {
            board[row][col - 1] = tile;
            board[row][col] = -1;
        }
    }
    
    if (col + 1 < 14) {
        if (board[row][col + 1] == -1) {
            board[row][col + 1] = tile;
            board[row][col] = -1;
        }
    }
}",1
sjaf029,1696216878,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowEmpty;
	int colEmpty;
	FindTile(board, -1, &rowEmpty, &colEmpty);

	int tileRow, tileCol;
	FindTile(board, tile, &tileRow, &tileCol);

	if ((tileRow == rowEmpty && (tileCol == colEmpty - 1 || tileCol == colEmpty + 1)) ||
		(tileCol == colEmpty && (tileRow == rowEmpty - 1 || tileRow == rowEmpty + 1))) {
		int tempVal = board[rowEmpty][colEmpty];
		board[rowEmpty][colEmpty] = board[tileRow][tileCol];
		board[tileRow][tileCol] = tempVal;
	}

}",1
sjai563,1695992816,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col;
    FindTile(board, tile, &row, &col);

	// up
    if (row > 0 && board[row - 1][col] == -1) {  
        board[row - 1][col] = tile;    
        board[row][col] = -1;          
    }
    // right
    else if (col < NUM_COLS - 1 && board[row][col + 1] == -1) {  
        board[row][col + 1] = tile;    
        board[row][col] = -1;        
    }
    // down 
    else if (row < NUM_ROWS - 1 && board[row + 1][col] == -1) {  
        board[row + 1][col] = tile;   
        board[row][col] = -1;          
    }
    // left
    else if (col > 0 && board[row][col - 1] == -1) { 
        board[row][col - 1] = tile;    
        board[row][col] = -1;         
    }
    else { 
        return;
    }
}
",1
sjam309,1695953600,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int temp;
    int emptyrowPos;
    int tilerowPos;
    int tilecolPos;
    int emptycolPos;
    
    FindTile(board, -1, &emptyrowPos, &emptycolPos);
   
    FindTile(board, tile, &tilerowPos, &tilecolPos);
  
   if(tilecolPos >= 0) {
       if (tilecolPos == emptycolPos - 1 && tilerowPos == emptyrowPos){
           board[tilerowPos][tilecolPos] = -1;
           board[emptyrowPos][emptycolPos] = tile;
       }
   }
   if (tilecolPos <= 3){
       if(tilecolPos == emptycolPos + 1 && tilerowPos == emptyrowPos){
           board[tilerowPos][tilecolPos] = -1;
           board[emptyrowPos][emptycolPos] = tile;
       }
   }
   if(tilerowPos >= 0){
       if(tilerowPos == emptyrowPos - 1 && tilecolPos == emptycolPos){
           board[tilerowPos][tilecolPos] = -1;
           board[emptyrowPos][emptycolPos] = tile;
       }
   }
   if(tilerowPos <= 3){
       if(tilerowPos == emptyrowPos + 1 && tilecolPos == emptycolPos){
           board[tilerowPos][tilecolPos] = -1;
           board[emptyrowPos][emptycolPos] = tile;
       }
   }
}",0
sjam309,1695953631,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyrowPos;
    int tilerowPos;
    int tilecolPos;
    int emptycolPos;
    
    FindTile(board, -1, &emptyrowPos, &emptycolPos);
   
    FindTile(board, tile, &tilerowPos, &tilecolPos);
  
   if(tilecolPos >= 0) {
       if (tilecolPos == emptycolPos - 1 && tilerowPos == emptyrowPos){
           board[tilerowPos][tilecolPos] = -1;
           board[emptyrowPos][emptycolPos] = tile;
       }
   }
   if (tilecolPos <= 3){
       if(tilecolPos == emptycolPos + 1 && tilerowPos == emptyrowPos){
           board[tilerowPos][tilecolPos] = -1;
           board[emptyrowPos][emptycolPos] = tile;
       }
   }
   if(tilerowPos >= 0){
       if(tilerowPos == emptyrowPos - 1 && tilecolPos == emptycolPos){
           board[tilerowPos][tilecolPos] = -1;
           board[emptyrowPos][emptycolPos] = tile;
       }
   }
   if(tilerowPos <= 3){
       if(tilerowPos == emptyrowPos + 1 && tilecolPos == emptycolPos){
           board[tilerowPos][tilecolPos] = -1;
           board[emptyrowPos][emptycolPos] = tile;
       }
   }
}",1
sjob296,1696214598,1,"void MakeMove(int board[NUM_ROWS][NUM_], int tileToMove)
{ 
    int tileRowIdx, tileColIdx;
    int emptyRowIdx, emptyColIdx; 
    
    FindTile(board, tileToMove, &tileRowIdx, &tileColIdx);
    FindTile(board, -1, &emptyRowIdx, &emptyColIdx);
    
    if((abs(tileRowIdx - emptyRowIdx) == 1 && tileColIdx == emptyColIdx) || 
    (abs(tileColIdx - emptyColIdx) == 1 && tileRowIdx == emptyRowIdx)) 
    { 
        board[emptyRowIdx][emptyColIdx] = tileToMove;
        board[tileRowIdx][tileColIdx] = -1;
    }
}",0
sjob296,1696216969,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tileToMove)
{ 
    int tileRowIdx, tileColIdx;
    int emptyRowIdx, emptyColIdx; 
    
    FindTile(board, tileToMove, &tileRowIdx, &tileColIdx);
    FindTile(board, -1, &emptyRowIdx, &emptyColIdx);
    
    if ((abs(tileRowIdx - emptyRowIdx) == 1 && tileColIdx == emptyColIdx) || (abs(tileColIdx - emptyColIdx) == 1 && tileRowIdx == emptyRowIdx)) 
    { 
        board[emptyRowIdx][emptyColIdx] = tileToMove;
        board[tileRowIdx][tileColIdx] = -1;
    }
}",1
skan221,1696220040,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row;
    int column;
    int row1;
    int column1;
    
    FindTile(board, tile, &row, &column);
    FindTile(board, -1, &row1, &column1);
    
    if ((row == row1 && abs(column - column1)== 1) || (column == column1 && abs(row - row1)==1 )) {
    
    board [row1][column1] = board [row][column];
    board [row][column] = -1 ;
    }
}",1
skea516,1695713248,1,"void MakeMove(int board[4][4], int tile)
{
    int emptyrow, emptycol;
    int row, col;
	FindTile(board, -1, &emptyrow, &emptycol);
	FindTile(board, tile, &row, &col);
	// rows 
	if ((emptyrow - row == 0 && (emptycol - col == 1 || col - emptycol == 1))|| 
	    (emptycol - col == 0 && (emptyrow - row == 1 || row - emptyrow == 1)) )
	{
		board[emptyrow][emptycol] = tile;
		board[row][col] = -1;
	}
}",1
skmu887,1696227655,1,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRow, tileCol, emptyRow, emptyCol;
    
    // Find the tile and the empty square using Findtile 
    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol); // -1 represents the empty square
    
    // Check if the tile is adjacent to the empty square either horizontally or vertically
    if ((abs(tileRow - emptyRow) == 1 && tileCol == emptyCol) ||
        (abs(tileCol - emptyCol) == 1 && tileRow == emptyRow)) {
        // Swap the tile with the empty square
        board[emptyRow][emptyCol] = tile;
        // Set the original position to empty
        board[tileRow][tileCol] = -1; 
    } else {
        // if the specified tile is not adjacent to the empty square, cannot be moved
        printf(""Invalid move! The specified tile cannot be moved.\n"");
    }
}",0
skmu887,1696227749,2,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRow, tileCol, emptyRow, emptyCol;
    
    // Find the tile and the empty square using Findtile 
    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol); // -1 represents the empty square
    
    // Check if the tile is adjacent to the empty square either horizontally or vertically
    if ((abs(tileRow - emptyRow) == 1 && tileCol == emptyCol) ||
        (abs(tileCol - emptyCol) == 1 && tileRow == emptyRow)) {
        // Swap the tile with the empty square
        board[emptyRow][emptyCol] = tile;
        // Set the original position to empty
        board[tileRow][tileCol] = -1; 
    } 
}",1
skop291,1696135975,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRow, tileCol, emptyRow, emptyCol;
    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol);

    // Checking if the tile is adjacent to the empty space
    if ((tileRow == emptyRow && abs(tileCol - emptyCol) == 1) ||
        (tileCol == emptyCol && abs(tileRow - emptyRow) == 1)) {
        // Swapping the tile and empty space
        board[tileRow][tileCol] = -1;
        board[emptyRow][emptyCol] = tile;
    }
}",1
skul970,1695701404,1,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    
    int rowPos = -1;
    int colPos = -1;
    FindTile(board, -1, &rowPos, &colPos);
    
    int adj_tiles[16];
    
    if (rowPos == 0 && colPos == 0) {
        adj_tiles[0] = board[1][2];
        adj_tiles[1] = board[2][1];
        
    } else if (rowPos == 0 && colPos == NUM_COLS - 1) {
        adj_tiles[0] = board[1][colPos - 1];
        adj_tiles[1] = board[2][colPos - 1];
        
    } else if (rowPos == NUM_ROWS - 1 && colPos == 0) {
        adj_tiles[0] = board[rowPos - 1][colPos];
        adj_tiles[1] = board[rowPos][colPos + 1];
        
    } else if (rowPos == NUM_ROWS - 1 && colPos == NUM_COLS - 1) {
        adj_tiles[0] = board[rowPos - 1][colPos];
        adj_tiles[1] = board[rowPos][colPos - 1];
        
    } else if (rowPos == 0) {
        adj_tiles[0] = board[rowPos][colPos - 1];
        adj_tiles[1] = board[rowPos][colPos + 1];
        adj_tiles[2] = board[rowPos + 1][colPos];
        
    } else if (rowPos == NUM_ROWS - 1) {
        adj_tiles[0] = board[rowPos][colPos - 1];
        adj_tiles[1] = board[rowPos][colPos + 1];
        adj_tiles[2] = board[rowPos - 1][colPos];
        
    } else if (colPos == 0) {
        adj_tiles[0] = board[rowPos + 1][colPos];
        adj_tiles[1] = board[rowPos - 1][colPos];
        adj_tiles[2] = board[rowPos][colPos + 1];
        
    } else if (colPos == NUM_COLS - 1) {
        adj_tiles[0] = board[rowPos + 1][colPos];
        adj_tiles[1] = board[rowPos - 1][colPos];
        adj_tiles[2] = board[rowPos][colPos - 1];
        
    } else {
        adj_tiles[0] = board[rowPos + 1][colPos];
        adj_tiles[1] = board[rowPos - 1][colPos];
        adj_tiles[2] = board[rowPos][colPos + 1];
        adj_tiles[3] = board[rowPos][colPos - 1];
        
    }
    
    for (int count = 0; count < 16; count++) {
        if (adj_tiles[count] == tile) {
            printf("" %d\n "", adj_tiles[count]);
            int switch_row;
            int switch_col;
            FindTile(board, tile, &switch_row, &switch_col);
            
            int temp = board[rowPos][colPos];
            board[rowPos][colPos] = board[switch_row][switch_col];
            board[switch_row][switch_col] = temp;
            
        }
    }
}
",0
skul970,1695701449,2,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    
    int rowPos = -1;
    int colPos = -1;
    FindTile(board, -1, &rowPos, &colPos);
    
    int adj_tiles[16];
    
    if (rowPos == 0 && colPos == 0) {
        adj_tiles[0] = board[1][2];
        adj_tiles[1] = board[2][1];
        
    } else if (rowPos == 0 && colPos == NUM_COLS - 1) {
        adj_tiles[0] = board[1][colPos - 1];
        adj_tiles[1] = board[2][colPos - 1];
        
    } else if (rowPos == NUM_ROWS - 1 && colPos == 0) {
        adj_tiles[0] = board[rowPos - 1][colPos];
        adj_tiles[1] = board[rowPos][colPos + 1];
        
    } else if (rowPos == NUM_ROWS - 1 && colPos == NUM_COLS - 1) {
        adj_tiles[0] = board[rowPos - 1][colPos];
        adj_tiles[1] = board[rowPos][colPos - 1];
        
    } else if (rowPos == 0) {
        adj_tiles[0] = board[rowPos][colPos - 1];
        adj_tiles[1] = board[rowPos][colPos + 1];
        adj_tiles[2] = board[rowPos + 1][colPos];
        
    } else if (rowPos == NUM_ROWS - 1) {
        adj_tiles[0] = board[rowPos][colPos - 1];
        adj_tiles[1] = board[rowPos][colPos + 1];
        adj_tiles[2] = board[rowPos - 1][colPos];
        
    } else if (colPos == 0) {
        adj_tiles[0] = board[rowPos + 1][colPos];
        adj_tiles[1] = board[rowPos - 1][colPos];
        adj_tiles[2] = board[rowPos][colPos + 1];
        
    } else if (colPos == NUM_COLS - 1) {
        adj_tiles[0] = board[rowPos + 1][colPos];
        adj_tiles[1] = board[rowPos - 1][colPos];
        adj_tiles[2] = board[rowPos][colPos - 1];
        
    } else {
        adj_tiles[0] = board[rowPos + 1][colPos];
        adj_tiles[1] = board[rowPos - 1][colPos];
        adj_tiles[2] = board[rowPos][colPos + 1];
        adj_tiles[3] = board[rowPos][colPos - 1];
        
    }
    
    for (int count = 0; count < 16; count++) {
        if (adj_tiles[count] == tile) {
            int switch_row;
            int switch_col;
            FindTile(board, tile, &switch_row, &switch_col);
            
            int temp = board[rowPos][colPos];
            board[rowPos][colPos] = board[switch_row][switch_col];
            board[switch_row][switch_col] = temp;
            
        }
    }
}
",1
slam669,1695865462,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row,col,emptyRow, emptyCol, tileRow, tileCol;
    FindTile(board, -1, &emptyRow, &emptyCol);

    FindTile(board, tile, &tileRow, &tileCol);
    
    if (abs(emptyRow - tileRow) <= 1 && abs(emptyCol - tileCol) <= 1) {
        int temp = board [tileRow][tileCol];
        board [tileRow][tileCol] = board [emptyRow][emptyCol];
        board [emptyRow][emptyCol] = temp;
    }
    

    
}",0
slam669,1695865521,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyRow, emptyCol, tileRow, tileCol;
    FindTile(board, -1, &emptyRow, &emptyCol);

    FindTile(board, tile, &tileRow, &tileCol);
    
    if (abs(emptyRow - tileRow) <= 1 && abs(emptyCol - tileCol) <= 1) {
        int temp = board [tileRow][tileCol];
        board [tileRow][tileCol] = board [emptyRow][emptyCol];
        board [emptyRow][emptyCol] = temp;
    }
    

    
}",1
slie508,1696231120,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowPos;
    int colPos;
    FindTile(board, tile, &rowPos, &colPos);
    if (rowPos>0){
        if (board[rowPos-1][colPos] == -1){
            board[rowPos-1][colPos] = tile;
            board[rowPos][colPos] = -1;
        }
    }
    if (rowPos<NUM_ROWS -1){
        if (board[rowPos+1][colPos] == -1){
            board[rowPos+1][colPos] = tile;
            board[rowPos][colPos] = -1;
        }
    } 
    if (colPos>0){
        if (board[rowPos][colPos-1] == -1){
            board[rowPos][colPos-1] = tile;
            board[rowPos][colPos] = -1;
        }
    } 
    if (colPos<NUM_COLS){
        if (board[rowPos][colPos+1] == -1){
            board[rowPos][colPos+1] = tile;
            board[rowPos][colPos] = -1;
        }
    }
}",1
sluo487,1696214822,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int tileRow, tileCol;
    int emptyRow, emptyCol;
    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol);

    int diffR, diffC;
    diffR = tileRow - emptyRow;
    diffC = tileCol - emptyCol;

    if ((diffR == -1 || diffR == 1) && diffC == 0) {
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    } else if ((diffC == -1 || diffC == 1) && diffR == 0) {
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
}
}",1
smac708,1695938085,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row; 
	int col; 

	// find the tile that is wanting to be moved by the user
	FindTile(board,tile, &row, &col);

	// compare if the tile is able to be moved 

	// check if it can go down  
	if (row < 3) {
		if (board[row + 1][col] == -1) {
			board[row + 1][col] = tile; 
			board[row][col] = -1; 
		} 
	} 

	// check if it can go up 
	if (row > 0) {
		if (board[row - 1][col] == -1) {
			board[row - 1][col] = tile; 
			board[row][col] = -1; 
		}
	} 

	// Check if it can go right 
	if (col < NUM_COLS - 1) {
		if (board[row][col + 1] == -1) { 
			board[row][col + 1] = tile; 
			board[row][col] = -1;
		} 
	} 

	// check if it can go left 
	if (col > 0) {
		if (board[row][col-1] == -1) {
			board[row][col - 1] = tile; 
			board[row][col] = -1; 
		} 
	} 

	} ",1
sman821,1695781066,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j, row_tile, col_tile, row;
	
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == tile) {
				row_tile = i;
				col_tile = j;
			}
		}
	}

	if (board[row_tile+1][col_tile] == -1) {

		board[row_tile][col_tile] = -1;
		board[row_tile+1][col_tile] = tile;

	} else if (board[row_tile-1][col_tile] == -1) {

		board[row_tile][col_tile] = -1;
		board[row_tile-1][col_tile] = tile;

	} else if (board[row_tile][col_tile+1] == -1) {

		board[row_tile][col_tile] = -1;
		board[row_tile][col_tile+1] = tile;

	} else if (board[row_tile][col_tile-1] == -1) {

		board[row_tile][col_tile] = -1;
		board[row_tile][col_tile-1] = tile;

	}



}",0
sman821,1695781089,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j, row_tile, col_tile;
	
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == tile) {
				row_tile = i;
				col_tile = j;
			}
		}
	}

	if (board[row_tile+1][col_tile] == -1) {

		board[row_tile][col_tile] = -1;
		board[row_tile+1][col_tile] = tile;

	} else if (board[row_tile-1][col_tile] == -1) {

		board[row_tile][col_tile] = -1;
		board[row_tile-1][col_tile] = tile;

	} else if (board[row_tile][col_tile+1] == -1) {

		board[row_tile][col_tile] = -1;
		board[row_tile][col_tile+1] = tile;

	} else if (board[row_tile][col_tile-1] == -1) {

		board[row_tile][col_tile] = -1;
		board[row_tile][col_tile-1] = tile;

	}



}",0
sman821,1695781419,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j;
	int row_tile = -1;
	int col_tile = -1;
	
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == tile) {
				row_tile = i;
				col_tile = j;
			}
		}
	}

	if ((row_tile != -1) && col_tile !=-1) {
		if (board[row_tile+1][col_tile] == -1) {

			board[row_tile][col_tile] = -1;
			board[row_tile+1][col_tile] = tile;

		} else if (board[row_tile-1][col_tile] == -1) {

			board[row_tile][col_tile] = -1;
			board[row_tile-1][col_tile] = tile;

		} else if (board[row_tile][col_tile+1] == -1) {

			board[row_tile][col_tile] = -1;
			board[row_tile][col_tile+1] = tile;

		} else if (board[row_tile][col_tile-1] == -1) {

			board[row_tile][col_tile] = -1;
			board[row_tile][col_tile-1] = tile;

		}
	}
}",0
sman821,1696124304,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j;
	int row_tile = -1;
	int col_tile = -1;
	
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == tile) {
				row_tile = i;
				col_tile = j;
			}
		}
	}

	if ((row_tile != -1) && col_tile !=-1) {
		if ((board[row_tile+1][col_tile] == -1) && (row_tile != NUM_ROWS-1)) {

			board[row_tile][col_tile] = -1;
			board[row_tile+1][col_tile] = tile;
			printf(""e1\n"");

		} else if ((board[row_tile-1][col_tile] == -1) && (row_tile != 0)) {

			board[row_tile][col_tile] = -1;
			board[row_tile-1][col_tile] = tile;
			printf(""e2\n"");

		} else if ((board[row_tile][col_tile+1] == -1) && (col_tile != NUM_COLS-1)) {

			board[row_tile][col_tile] = -1;
			board[row_tile][col_tile+1] = tile;
			printf(""e3\n"");

		} else if ((board[row_tile][col_tile-1] == -1) && (col_tile != 0)) {

			board[row_tile][col_tile] = -1;
			board[row_tile][col_tile-1] = tile;
			printf(""e4\n"");

		}
	}
}
",0
sman821,1696124340,5,"void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos)
{
	int i,j;

	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == tile) {
				*rowPos = i;
				*colPos = j;
			}
		}
	}
}

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j;
	int row_tile = -1;
	int col_tile = -1;
	
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == tile) {
				row_tile = i;
				col_tile = j;
			}
		}
	}

	if ((row_tile != -1) && col_tile !=-1) {
		if ((board[row_tile+1][col_tile] == -1) && (row_tile != NUM_ROWS-1)) {

			board[row_tile][col_tile] = -1;
			board[row_tile+1][col_tile] = tile;

		} else if ((board[row_tile-1][col_tile] == -1) && (row_tile != 0)) {

			board[row_tile][col_tile] = -1;
			board[row_tile-1][col_tile] = tile;

		} else if ((board[row_tile][col_tile+1] == -1) && (col_tile != NUM_COLS-1)) {

			board[row_tile][col_tile] = -1;
			board[row_tile][col_tile+1] = tile;

		} else if ((board[row_tile][col_tile-1] == -1) && (col_tile != 0)) {

			board[row_tile][col_tile] = -1;
			board[row_tile][col_tile-1] = tile;

		}
	}
}
",0
sman821,1696124363,6,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j;
	int row_tile = -1;
	int col_tile = -1;
	
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == tile) {
				row_tile = i;
				col_tile = j;
			}
		}
	}

	if ((row_tile != -1) && col_tile !=-1) {
		if ((board[row_tile+1][col_tile] == -1) && (row_tile != NUM_ROWS-1)) {

			board[row_tile][col_tile] = -1;
			board[row_tile+1][col_tile] = tile;

		} else if ((board[row_tile-1][col_tile] == -1) && (row_tile != 0)) {

			board[row_tile][col_tile] = -1;
			board[row_tile-1][col_tile] = tile;

		} else if ((board[row_tile][col_tile+1] == -1) && (col_tile != NUM_COLS-1)) {

			board[row_tile][col_tile] = -1;
			board[row_tile][col_tile+1] = tile;

		} else if ((board[row_tile][col_tile-1] == -1) && (col_tile != 0)) {

			board[row_tile][col_tile] = -1;
			board[row_tile][col_tile-1] = tile;

		}
	}
}",1
sman833,1695867866,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyRow, emptyCol;
    int tileRow, tileCol;

    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);

    if(
        (emptyRow == tileRow && (emptyCol == tileCol -1 || emptyCol == tileCol + 1)) ||
        (emptyCol == tileCol && (emptyRow == tileRow -1 || emptyRow == tileRow + 1))
    ) {
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    } else {
        printf(""Error!"")
    }
}",0
sman833,1695868406,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyRow, emptyCol;
    int tileRow, tileCol;

    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);

    if(
        (emptyRow == tileRow && (emptyCol == tileCol -1 || emptyCol == tileCol + 1)) ||
        (emptyCol == tileCol && (emptyRow == tileRow -1 || emptyRow == tileRow + 1))
    ) {
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    } else {
        printf(""Error!"");
    }
}",0
sman833,1695868596,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyRow, emptyCol;
    int tileRow, tileCol;

    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);

    if(
        (emptyRow == tileRow && (emptyCol == tileCol -1 || emptyCol == tileCol + 1)) ||
        (emptyCol == tileCol && (emptyRow == tileRow -1 || emptyRow == tileRow + 1))
    ) {
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    } else {
        return;
    }
}",1
smck855,1695812092,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol, tileRow, tileCol;

    
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);

    
    
        
    board[emptyRow][emptyCol] = tile;
    board[tileRow][tileCol] = -1;

}
",0
smck855,1695812220,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol, tileRow, tileCol;

    
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);

    
    if ((tileRow == emptyRow && (tileCol == emptyCol - 1 || tileCol == emptyCol + 1)) ||
        (tileCol == emptyCol && (tileRow == emptyRow - 1 || tileRow == emptyRow + 1))) {
        
        
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;

        
    } else {
        ;
    }
}
",1
smou122,1695782886,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row,col,empty_row,empty_col;
    int moving_row, moving_col;
    FindTile(board, -1, &row, &col);
    empty_row = row;
    empty_col = col;
    FindTile(board, tile, &row, &col);
    moving_row = row;
    moving_col = col;
    if (moving_row == empty_row + 1 || moving_row == empty_row - 1)
    {
        if (moving_col == empty_col){
            board[empty_row][empty_col] = tile;
            board[moving_row][moving_col] = -1;
            }
    }
    else if (moving_row == empty_row){
        if(moving_col == empty_col + 1 || moving_col == empty_col - 1){
            board[empty_row][empty_col] = tile;
            board[moving_row][moving_col] = -1;
        }
    }
}",1
smun623,1696237272,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyRow, emptyCol;
    int tileRow, tileCol;

    
    FindTile(board, -1, &emptyRow, &emptyCol);


    FindTile(board, tile, &tileRow, &tileCol);

    
    if (((tileRow == emptyRow) && ((tileCol == emptyCol + 1) || (tileCol == emptyCol - 1))) ||
        ((tileCol == emptyCol) && ((tileRow == emptyRow + 1) || (tileRow == emptyRow - 1)))) {
        
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    } else {
        
        printf(""Invalid move. The specified tile cannot be moved.\n"");
    }
}






",0
smun623,1696237540,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyRow, emptyCol;
    int tileRow, tileCol;

    
    FindTile(board, -1, &emptyRow, &emptyCol);


    FindTile(board, tile, &tileRow, &tileCol);

    
    if (((tileRow == emptyRow) && ((tileCol == emptyCol + 1) || (tileCol == emptyCol - 1))) ||
        ((tileCol == emptyCol) && ((tileRow == emptyRow + 1) || (tileRow == emptyRow - 1)))) {
        
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    } 






",0
smun623,1696237555,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyRow, emptyCol;
    int tileRow, tileCol;

    
    FindTile(board, -1, &emptyRow, &emptyCol);


    FindTile(board, tile, &tileRow, &tileCol);

    
    if (((tileRow == emptyRow) && ((tileCol == emptyCol + 1) || (tileCol == emptyCol - 1))) ||
        ((tileCol == emptyCol) && ((tileRow == emptyRow + 1) || (tileRow == emptyRow - 1)))) {
        
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    } 
}





",1
snas404,1696241866,1,"#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)	
{
	int i;
	int j;
	int rows = -1;
	int cols = -1;
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == -1) {
				rows = i;
				cols = j;
			}
		}
	}
	
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == tile) {
				row1 = i;
				cols1 = j;
			}
		}
	}
	
	if (rows1 == rows && cols1 == cols - 1) {
		board[rows1][cols1] = -1;
	}else if (rows1 == rows && cols1 == cols + 1) {
		board[rows1][cols1] = -1;
	}else if (rows1 == rows - 1 && cols1 == cols) {
		board[rows1][cols1] = -1;
	}else if (rows1 == rows + 1 && cols1 == cols) {
		board[rows1][cols1] = -1;
	}else {
		board[rows][cols] = -1
	}
	
	",0
snas404,1696242927,2,"#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i;
	int j;
	int rows = -1;
	int rows1 = -1;
	int cols = -1;
	int cols1 = -1;
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == -1) {
				rows = i;
				cols = j;
			}
		}
	}

	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == tile) {
				rows1 = i;
				cols1 = j;
			}
		}
	}

	if (rows1 == rows && cols1 == cols - 1) {
		board[rows][cols] = board[rows1][cols1];
		board[rows1][cols1] = -1;
	}else if (rows1 == rows && cols1 == cols + 1) {
		board[rows][cols] = board[rows1][cols1];
		board[rows1][cols1] = -1;
	}else if (rows1 == rows - 1 && cols1 == cols) {
		board[rows][cols] = board[rows1][cols1];
		board[rows1][cols1] = -1;
	}else if (rows1 == rows + 1 && cols1 == cols) {
		board[rows][cols] = board[rows1][cols1];
		board[rows1][cols1] = -1;
	}else {
		board[rows][cols] = -1;
	}

}

void PrintBoard(int board[NUM_ROWS][NUM_COLS])
{
	int i, j;
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == -1) {
				printf("" _ "");
			} else if (board[i][j] > 9) {   // align two-digit numbers
				printf("" %d"", board[i][j]);
			} else {
				printf("" %d "", board[i][j]);
			}
		}
		printf(""\n"");
	}
	printf(""\n"");
}
",0
snas404,1696242954,3,"#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i;
	int j;
	int rows = -1;
	int rows1 = -1;
	int cols = -1;
	int cols1 = -1;
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == -1) {
				rows = i;
				cols = j;
			}
		}
	}

	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == tile) {
				rows1 = i;
				cols1 = j;
			}
		}
	}

	if (rows1 == rows && cols1 == cols - 1) {
		board[rows][cols] = board[rows1][cols1];
		board[rows1][cols1] = -1;
	}else if (rows1 == rows && cols1 == cols + 1) {
		board[rows][cols] = board[rows1][cols1];
		board[rows1][cols1] = -1;
	}else if (rows1 == rows - 1 && cols1 == cols) {
		board[rows][cols] = board[rows1][cols1];
		board[rows1][cols1] = -1;
	}else if (rows1 == rows + 1 && cols1 == cols) {
		board[rows][cols] = board[rows1][cols1];
		board[rows1][cols1] = -1;
	}else {
		board[rows][cols] = -1;
	}

}

",1
span558,1695621237,1,"#include <stdio.h>
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRow, tileCol;
    int emptyRow, emptyCol;

    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol);

    if ((tileRow == emptyRow && (tileCol == emptyCol - 1 || tileCol == emptyCol + 1)) ||
        (tileCol == emptyCol && (tileRow == emptyRow - 1 || tileRow == emptyRow + 1))) {
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    } 
}",1
spar473,1695904941,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyRow, emptyCol;

    FindTile(board, -1, &emptyRow, &emptyCol);

    for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			if (i >= 0 && i <= 3 && j >= 0 && j <= 3) {
			continue;
			}

			int newRow = emptyRow + i;
			int newCol = emptyCol + j;


            if (board[newRow][newCol] == tile) {
                board[emptyRow][emptyCol] = tile;
                board[newRow][newCol] = -1;
                return;
			}
        }
    }
}",0
spar473,1695958987,2,"
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyRow, emptyCol;
	int row, col;
	int newRow, newCol;

    FindTile(board, -1, &row, &col);
	FindTile(board, tile, &emptyRow, &emptyCol);
	// left
	if (col > 0) {
		if ((emptyRow == row) && (emptyCol == col - 1)) {
			    board[emptyRow][emptyCol] = -1;
                board[row][col] = tile;
		}
	}
	// right
	if (col < 3) {
		if ((emptyRow == row) && (emptyCol == col + 1)) {
			    board[emptyRow][emptyCol] = -1;
                board[row][col] = tile;
		}
	}
	// top
	if (row > 0) {
		if ((emptyCol == col) && (emptyRow == row - 1)) {
			    board[emptyRow][emptyCol] = -1;
                board[row][col] = tile;
		} 
	}
	// down
	if (row < 3) {
		if ((emptyCol == col) && (emptyRow == row + 1)) {
			    board[emptyRow][emptyCol] = -1;
                board[row][col] = tile;
		}
	}
}",0
spar473,1695959015,3,"
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyRow, emptyCol;
	int row, col;

    FindTile(board, -1, &row, &col);
	FindTile(board, tile, &emptyRow, &emptyCol);
	// left
	if (col > 0) {
		if ((emptyRow == row) && (emptyCol == col - 1)) {
			    board[emptyRow][emptyCol] = -1;
                board[row][col] = tile;
		}
	}
	// right
	if (col < 3) {
		if ((emptyRow == row) && (emptyCol == col + 1)) {
			    board[emptyRow][emptyCol] = -1;
                board[row][col] = tile;
		}
	}
	// top
	if (row > 0) {
		if ((emptyCol == col) && (emptyRow == row - 1)) {
			    board[emptyRow][emptyCol] = -1;
                board[row][col] = tile;
		} 
	}
	// down
	if (row < 3) {
		if ((emptyCol == col) && (emptyRow == row + 1)) {
			    board[emptyRow][emptyCol] = -1;
                board[row][col] = tile;
		}
	}
}",1
spar820,1696229354,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowtile, coltile, row1, col1;
		for (int i = 0; i <= 4; i++) {
			for (int j = 0; j <= 4; j++) {
				if (board[i][j] == -1){
					row1 = i;
				    col1 = j;
				}
			}
		}

    for (int i = 0; i <= 4; i++) {
			for (int j = 0; j <= 4; j++) {
				if (board[i][j] == tile){
					rowtile = i;
				    coltile = j;
				}
			}
		}
    
    
    if (((rowtile == row1+1) && (coltile == col1)) || ((rowtile == row1-1) && (coltile == col1)) || ((coltile == col1+1) && (rowtile == row1))||((coltile == col1-1) && (rowtile == row1))){
        board[rowtile][coltile] = -1;
        board[row1][col1] = tile;
    }else{
        return;
    }
}",1
srak374,1696240367,1,"#include <stdio.h>
#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4


void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow = -1;
    int emptyCol = -1;
    int tileRow = -1;
    int tileCol = -1;

    // Find the empty square and the tile
    for (int row = 0; row < NUM_ROWS; row++) {
        for (int col = 0; col < NUM_COLS; col++) {
            if (board[row][col] == -1) {
                emptyRow = row;
                emptyCol = col;
            } else if (board[row][col] == tile) {
                tileRow = row;
                tileCol = col;
            }
        }
    }

    // Check if the tile is adjacent to the empty square
    if ((tileRow == emptyRow && (tileCol == emptyCol - 1 || tileCol == emptyCol + 1)) ||
        (tileCol == emptyCol && (tileRow == emptyRow - 1 || tileRow == emptyRow + 1))) {
        // Swap the tile and the empty square
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}
",1
sran136,1696243238,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row_tile;
    int col_tile;
    for (int row = 0; row < NUM_ROWS; row++) {

        for (int col = 0; col < NUM_COLS; col++) {

            if (board[row][col] == tile) {
                row_tile = row;
                col_tile = col;
            }
        }
    }
    int row_empty;
    int col_empty;
    for (int row = 0; row < NUM_ROWS; row++) {

        for (int col = 0; col < NUM_COLS; col++) {

            if (board[row][col] == -1) {
                row_empty = row;
                col_empty = col;

                if (col_empty == col_tile && (row_empty - 1 == row_tile)) {

                    board[row_empty][col_empty] = board[row_tile][col_empty];
                    board[row_tile][col_tile] = -1;

                }
                else if (col_empty == col_tile && (row_empty + 1 == row_tile)) {

                    board[row_empty][col_empty] = board[row_tile][col_empty];
                    board[row_tile][col_empty + 1] = -1;
                }
                else if (row_empty == row_tile && (col_empty + 1 == col_tile)) {

                    board[row_empty][col_empty] = board[row_tile][col_empty];
                    board[row_tile][col_tile] = -1;
                }
                else if (row_empty == row_tile && (col_empty - 1 == col_tile)) {

                    board[row_empty][col_empty] = board[row_tile][col_empty];
                    board[row_tile][col_tile] = -1;
                }
            }
        }
    }
}",0
sran136,1696243684,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row_tile;
    int col_tile;
    for (int row = 0; row < NUM_ROWS; row++) {

        for (int col = 0; col < NUM_COLS; col++) {

            if (board[row][col] == tile) {
                row_tile = row;
                col_tile = col;
            }
        }
    }
    int row_empty;
    int col_empty;
    for (int row = 0; row < NUM_ROWS; row++) {

        for (int col = 0; col < NUM_COLS; col++) {

            if (board[row][col] == -1) {
                row_empty = row;
                col_empty = col;

                if (col_empty == col_tile && (row_empty - 1 == row_tile)) {

                    board[row_empty][col_empty] = board[row_tile][col_empty];
                    board[row_tile][col_tile] = -1;

                }
                else if (col_empty == col_tile && (row_empty + 1 == row_tile)) {

                    board[row_empty][col_empty] = board[row_tile][col_empty];
                    board[row_tile][col_empty + 1] = -1;
                }
                else if (row_empty == row_tile && (col_empty + 1 == col_tile)) {

                    board[row_empty][col_empty] = board[row_tile][col_tile];
                    board[row_tile][col_tile] = -1;
                }
                else if (row_empty == row_tile && (col_empty - 1 == col_tile)) {

                    board[row_empty][col_empty] = board[row_tile][col_empty];
                    board[row_tile][col_tile] = -1;
                }
            }
        }
    }
}",0
sran136,1696243848,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row_tile;
    int col_tile;
    for (int row = 0; row < NUM_ROWS; row++) {

        for (int col = 0; col < NUM_COLS; col++) {

            if (board[row][col] == tile) {
                row_tile = row;
                col_tile = col;
            }
        }
    }
    int row_empty;
    int col_empty;
    for (int row = 0; row < NUM_ROWS; row++) {

        for (int col = 0; col < NUM_COLS; col++) {

            if (board[row][col] == -1) {
                row_empty = row;
                col_empty = col;

                if (col_empty == col_tile && (row_empty - 1 == row_tile)) {

                    board[row_empty][col_empty] = board[row_tile][col_empty];
                    board[row_tile][col_tile] = -1;

                }
                else if (col_empty == col_tile && (row_empty + 1 == row_tile)) {

                    board[row_empty][col_empty] = board[row_tile][col_tile];
                    board[row_tile][col_empty + 1] = -1;
                }
                else if (row_empty == row_tile && (col_empty + 1 == col_tile)) {

                    board[row_empty][col_empty] = board[row_tile][col_tile];
                    board[row_tile][col_tile] = -1;
                }
                else if (row_empty == row_tile && (col_empty - 1 == col_tile)) {

                    board[row_empty][col_empty] = board[row_tile][col_empty];
                    board[row_tile][col_tile] = -1;
                }
            }
        }
    }
}",0
sran136,1696244023,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row_tile;
    int col_tile;
    for (int row = 0; row < NUM_ROWS; row++) {

        for (int col = 0; col < NUM_COLS; col++) {

            if (board[row][col] == tile) {
                row_tile = row;
                col_tile = col;
            }
        }
    }
    int row_empty;
    int col_empty;
    for (int row = 0; row < NUM_ROWS; row++) {

        for (int col = 0; col < NUM_COLS; col++) {

            if (board[row][col] == -1) {
                row_empty = row;
                col_empty = col;

                if (col_empty == col_tile && (row_empty - 1 == row_tile)) {

                    board[row_empty][col_empty] = board[row_tile][col_empty];
                    board[row_tile][col_tile] = -1;

                }
                else if (col_empty == col_tile && (row_empty + 1 == row_tile)) {

                    board[row_empty][col_empty] = board[row_tile][col_tile];
                    board[row_tile][col_tile] = -1;
                }
                else if (row_empty == row_tile && (col_empty + 1 == col_tile)) {

                    board[row_empty][col_empty] = board[row_tile][col_empty];
                    board[row_tile][col_tile] = -1;
                }
                else if (row_empty == row_tile && (col_empty - 1 == col_tile)) {

                    board[row_empty][col_empty] = board[row_tile][col_empty];
                    board[row_tile][col_tile] = -1;
                }
            }
        }
    }
}",0
sran136,1696244168,5,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row_tile;
    int col_tile;
    for (int row = 0; row < NUM_ROWS; row++) {

        for (int col = 0; col < NUM_COLS; col++) {

            if (board[row][col] == tile) {
                row_tile = row;
                col_tile = col;
            }
        }
    }
    int row_empty;
    int col_empty;
    for (int row = 0; row < NUM_ROWS; row++) {

        for (int col = 0; col < NUM_COLS; col++) {

            if (board[row][col] == -1) {
                row_empty = row;
                col_empty = col;

                if (col_empty == col_tile && (row_empty - 1 == row_tile)) {

                    board[row_empty][col_empty] = board[row_tile][col_empty];
                    board[row_tile][col_tile] = -1;

                }
                else if (col_empty == col_tile && (row_empty + 1 == row_tile)) {

                    board[row_empty][col_empty] = board[row_tile][col_tile];
                    board[row_tile][col_tile] = -1;
                }
                else if (row_empty == row_tile && (col_empty + 1 == col_tile)) {

                    board[row_empty][col_empty] = board[row_tile][col_tile];
                    board[row_tile][col_tile] = -1;
                }
                else if (row_empty == row_tile && (col_empty - 1 == col_tile)) {

                    board[row_empty][col_empty] = board[row_tile][col_empty];
                    board[row_tile][col_tile] = -1;
                }
            }
        }
    }
}",0
sran136,1696244224,6,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row_tile;
    int col_tile;
    for (int row = 0; row < NUM_ROWS; row++) {

        for (int col = 0; col < NUM_COLS; col++) {

            if (board[row][col] == tile) {
                row_tile = row;
                col_tile = col;
            }
        }
    }
    int row_empty;
    int col_empty;
    for (int row = 0; row < NUM_ROWS; row++) {

        for (int col = 0; col < NUM_COLS; col++) {

            if (board[row][col] == -1) {
                row_empty = row;
                col_empty = col;

                if (col_empty == col_tile && (row_empty - 1 == row_tile)) {

                    board[row_empty][col_empty] = board[row_tile][col_empty];
                    board[row_tile][col_tile] = -1;

                }
                else if (col_empty == col_tile && (row_empty + 1 == row_tile)) {

                    board[row_empty][col_empty] = board[row_tile][col_tile];
                    board[row_tile][col_tile] = -1;
                }
                else if (row_empty == row_tile && (col_empty + 1 == col_tile)) {

                    board[row_empty][col_empty] = board[row_tile][col_tile];
                    board[row_tile][col_tile] = -1;
                }
                else if (row_empty == row_tile && (col_empty - 1 == col_tile)) {

                    board[row_empty][col_empty] = board[row_tile][col_tile];
                    board[row_tile][col_tile] = -1;
                }
            }
        }
    }
}",1
srou953,1695897583,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int BlankR, BlankC, TileR, TileC;

    // Find the positions of the empty square and the specified tile
    FindTile(board, -1, &BlankR, &BlankC);
    FindTile(board, tile, &TileR, &TileC);

    // Check if the specified tile is adjacent to the empty square
    if ((BlankR == TileR && abs(BlankC - TileC) == 1) ||
        (BlankC == TileC && abs(BlankR - TileR) == 1)) {
        // Swap the empty square and the specified tile
        board[BlankR][BlankC] = tile;
        board[TileR][TileC] = -1;
    }
}",1
ssan467,1696144522,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j, temp, rowPos, colPos;

	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == -1) {
				rowPos = i;
				colPos = j;
				break;
			}
		}
	}

	if (tile == board[rowPos][colPos + 1] && colPos < NUM_COLS) { 
		board[rowPos][colPos] = tile;
		board[rowPos][colPos + 1] = -1;
	}
	else if (tile == board[rowPos + 1][colPos] && rowPos < NUM_ROWS) { 
		board[rowPos][colPos] = tile;
		board[rowPos + 1][colPos] = -1;
	}
	else if (tile == board[rowPos][colPos - 1] && colPos > 0) { 
		board[rowPos][colPos] = tile;
		board[rowPos][colPos - 1] = -1;
	}
	else if (tile == board[rowPos - 1][colPos] && rowPos > 0) { 
		board[rowPos][colPos] = tile;
		board[rowPos - 1][colPos] = -1;
	}
}",0
ssan467,1696144550,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j, rowPos, colPos;

	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == -1) {
				rowPos = i;
				colPos = j;
				break;
			}
		}
	}

	if (tile == board[rowPos][colPos + 1] && colPos < NUM_COLS) { 
		board[rowPos][colPos] = tile;
		board[rowPos][colPos + 1] = -1;
	}
	else if (tile == board[rowPos + 1][colPos] && rowPos < NUM_ROWS) { 
		board[rowPos][colPos] = tile;
		board[rowPos + 1][colPos] = -1;
	}
	else if (tile == board[rowPos][colPos - 1] && colPos > 0) { 
		board[rowPos][colPos] = tile;
		board[rowPos][colPos - 1] = -1;
	}
	else if (tile == board[rowPos - 1][colPos] && rowPos > 0) { 
		board[rowPos][colPos] = tile;
		board[rowPos - 1][colPos] = -1;
	}
}",0
ssan467,1696145016,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j, rowPos, colPos;

	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == -1) {
				rowPos = i;
				colPos = j;
				break;
			}
		}
	}

	if (tile == board[rowPos][colPos + 1] && colPos < NUM_COLS - 1) { 
		board[rowPos][colPos] = tile;
		board[rowPos][colPos + 1] = -1;
	}
	else if (tile == board[rowPos + 1][colPos] && rowPos < NUM_ROWS - 1) { 
		board[rowPos][colPos] = tile;
		board[rowPos + 1][colPos] = -1;
	}
	else if (tile == board[rowPos][colPos - 1] && colPos > 0) { 
		board[rowPos][colPos] = tile;
		board[rowPos][colPos - 1] = -1;
	}
	else if (tile == board[rowPos - 1][colPos] && rowPos > 0) { 
		board[rowPos][colPos] = tile;
		board[rowPos - 1][colPos] = -1;
	}
}",1
ssco465,1695887067,1,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{    
    int rowPos, colPos;

    FindTile(board, tile, &rowPos, &colPos);

    if (rowPos >= 0 && colPos >= 0 && board[rowPos][colPos] == tile) {
        int possibleRows[] = { rowPos - 1, rowPos + 1, rowPos, rowPos };
        int possibleCols[] = { colPos, colPos, colPos - 1, colPos + 1 };

        for (int i = 0; i < 4; ++i) {
            int newRow = possibleRows[i];
            int newCol = possibleCols[i];

            if (newRow >= 0 && newRow < NUM_ROWS && newCol >= 0 && newCol < NUM_COLS) {
                if (board[newRow][newCol] == -1) 
                {
                    board[newRow][newCol] = tile;
                    board[rowPos][colPos] = -1;
                    return; 
                }
            }
        }
    }
}",1
ssey266,1696226055,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol;
    int tileRow, tileCol;

    FindTile(board, -1, &emptyRow, &emptyCol);

    FindTile(board, tile, &tileRow, &tileCol);

    if ((tileRow == emptyRow && (tileCol == emptyCol - 1 || tileCol == emptyCol + 1)) ||
        (tileCol == emptyCol && (tileRow == emptyRow - 1 || tileRow == emptyRow + 1))) {
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    } 
}
",1
ssiv093,1696239652,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol, tileRow, tileCol;
    int i, j;

    // Find the empty square and the specified tile
    for (i = 0; i < NUM_ROWS; i++) {
        for (j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == -1) {
                emptyRow = i;
                emptyCol = j;
            }
            if (board[i][j] == tile) {
                tileRow = i;
                tileCol = j;
            }
        }
    }",0
ssiv093,1696239672,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol, tileRow, tileCol;
    int i, j;

    // Find the empty square and the specified tile
    for (i = 0; i < NUM_ROWS; i++) {
        for (j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == -1) {
                emptyRow = i;
                emptyCol = j;
            }
            if (board[i][j] == tile) {
                tileRow = i;
                tileCol = j;
            }
        }
    }

    // Check if the specified tile is adjacent to the empty square
    if ((tileRow == emptyRow && (tileCol == emptyCol - 1 || tileCol == emptyCol + 1)) ||
        (tileCol == emptyCol && (tileRow == emptyRow - 1 || tileRow == emptyRow + 1))) {
        // Swap the specified tile with the empty square
        int temp = board[emptyRow][emptyCol];
        board[emptyRow][emptyCol] = board[tileRow][tileCol];
        board[tileRow][tileCol] = temp;
    }
}",1
sspa275,1695713903,1,"void MakeMove(int *board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowPos;
    int colPos;
    FindTile(board, tile, rowPos, colPos);
    int moveTile[2] = {rowPos, colPos};
    FindTile(board, -1, rowPos, colPos);
    int emptyTile[2] = {rowPos, colPos};
    int rowDifference = moveTile[1] - emptyTile[1];
    int colDifference = moveTile[2] - emptyTile[2];
    if (rowDifference == 1 && moveTile[1] != 0){
        if(colDifference == 1 && moveTile[2] != 0){
            board[emptyTile[1]][emptyTile[2]] = board[moveTile[1]][moveTile[2]];
            board[moveTile[1]][moveTile[2]] = -1;
        }
        else{
            if(colDifference == -1 && moveTile[2] != 3){
                board[emptyTile[1]][emptyTile[2]] = board[moveTile[1]][moveTile[2]];
                board[moveTile[1]][moveTile[2]] = -1;
            }
            else{
                return;
            }
        }
    }
    else{
        if(rowDifference == -1 && moveTile[1] != 3){
            if(colDifference == 1 && moveTile[2] != 0){
                board[emptyTile[1]][emptyTile[2]] = board[moveTile[1]][moveTile[2]];
                board[moveTile[1]][moveTile[2]] = -1;
            }
            else{
                if(colDifference == -1 && moveTile[2] != 3){
                    board[emptyTile[1]][emptyTile[2]] = board[moveTile[1]][moveTile[2]];
                    board[moveTile[1]][moveTile[2]] = -1;
                }
                else{
                    return;
                }
            }
        }
    }
}",0
ssri357,1695717852,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int chosenRow, chosenCol;
	int emptyRow, emptyCol;
	int temp;

	FindTile(board, tile, &chosenRow, &chosenCol);
	FindTile(board, -1, &emptyRow, &emptyCol);

	if (board[chosenRow + 1][chosenCol] != -1 && board[chosenRow - 1][chosenCol] != -1 && board[chosenRow][chosenCol + 1] != -1 && board[chosenRow][chosenCol - 1] != -1)
	{
		return;
	}

	else
	{
		temp = board[chosenRow][chosenCol];
		board[chosenRow][chosenCol] = board[emptyRow][emptyCol];
		board[emptyRow][emptyCol] = temp;
	}",0
ssri357,1695764838,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int chosenRow, chosenCol;
	int emptyRow, emptyCol;
	int temp;

	FindTile(board, tile, &chosenRow, &chosenCol);
	FindTile(board, -1, &emptyRow, &emptyCol);

	if (chosenRow == 0 && emptyRow == 3 || chosenRow == 3 && emptyRow == 0)
	{
		return;
	}

	else if (chosenCol == 0 && emptyCol == 3 || chosenCol == 3 && emptyCol == 0)
	{
		return;
	}

	else if (board[chosenRow + 1][chosenCol] != -1 && board[chosenRow - 1][chosenCol] != -1 && board[chosenRow][chosenCol + 1] != -1 && board[chosenRow][chosenCol - 1] != -1)
	{
		return;
	}	

	else
	{
		temp = board[chosenRow][chosenCol];
		board[chosenRow][chosenCol] = board[emptyRow][emptyCol];
		board[emptyRow][emptyCol] = temp;
	}


}
",0
ssri357,1695871231,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
int chosenRow, chosenCol;
	int emptyRow, emptyCol;
	int temp;

	FindTile(board, tile, &chosenRow, &chosenCol);
	FindTile(board, -1, &emptyRow, &emptyCol);

	if ((chosenRow == 0 && emptyRow == 3) || (chosenRow == 3 && emptyRow == 0))
	{
		return;
	}

	else if ((chosenCol == 0 && emptyCol == 3) || (chosenCol == 3 && emptyCol == 0))
	{
		return;
	}

	else if ((board[chosenRow + 1][chosenCol] != -1) && (board[chosenRow - 1][chosenCol] != -1) && (board[chosenRow][chosenCol + 1] != -1) && (board[chosenRow][chosenCol - 1] != -1))
	{
		return;
	}	

	else
	{
		temp = board[chosenRow][chosenCol];
		board[chosenRow][chosenCol] = board[emptyRow][emptyCol];
		board[emptyRow][emptyCol] = temp;
	}

}",1
steb012,1695715663,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    
    int top, left, right, bottom, row, col;
    
    FindTile(board, -1, &row, &col);
    //top
    if (row > 0 && board[row - 1][col] == tile){
        board[row - 1][col] = -1;
        board[row][col] = tile;
    }
    //left
    else if (col > 0 && board[row][col - 1]  == tile){
        board[row][col -1] = -1;
        board[row][col] = tile;
    }
    //bottom
     else if (row < NUM_ROWS - 1 && board[row + 1][col] == tile){
        board[row + 1][col] = -1;
        board[row][col] = tile;
    }
    //right
     else if (col < NUM_COLS - 1 && board[row][col + 1] == tile){
        board[row][col + 1] = -1;
        board[row][col] = tile;
    }
    else{
        tile = board[row][col];
    } 
}",0
steb012,1695715704,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    
    int row, col;
    
    FindTile(board, -1, &row, &col);
    //top
    if (row > 0 && board[row - 1][col] == tile){
        board[row - 1][col] = -1;
        board[row][col] = tile;
    }
    //left
    else if (col > 0 && board[row][col - 1]  == tile){
        board[row][col -1] = -1;
        board[row][col] = tile;
    }
    //bottom
     else if (row < NUM_ROWS - 1 && board[row + 1][col] == tile){
        board[row + 1][col] = -1;
        board[row][col] = tile;
    }
    //right
     else if (col < NUM_COLS - 1 && board[row][col + 1] == tile){
        board[row][col + 1] = -1;
        board[row][col] = tile;
    }
    else{
        tile = board[row][col];
    } 
}",1
stia357,1695879765,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int emptyRow;
	int emptyCol; 
	int tileRow; 
	int tileCol;

	FindTile(board, -1, &emptyRow, &emptyCol);
	FindTile(board, tile, &tileRow, &tileCol);

	if (((emptyRow - tileRow == 1 || emptyRow - tileRow == -1) && emptyCol == tileCol) ||
		((emptyCol - tileCol == 1 || emptyCol - tileCol == -1) && emptyRow == tileRow)) {

		
		board[emptyRow][emptyCol] = tile;
		board[tileRow][tileCol] = -1;
	}
	else {
		printf(""Invalid move. Please choose a tile adjacent to the empty space.\n"");
	}
}",0
stia357,1695881503,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyRow; 
    int emptyCol; 
    int tileRow; 
    int tileCol;
    
    
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);
    
    if ((emptyRow == tileRow && abs(emptyCol - tileCol) == 1) ||
        (emptyCol == tileCol && abs(emptyRow - tileRow) == 1)) {
        
        // Swap the empty tile and the tile to be moved
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    } else {
        printf(""Invalid move. Please choose a tile adjacent to the empty space.\n"");
    }
}",0
stia357,1695881824,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyRow; 
    int emptyCol; 
    int tileRow; 
    int tileCol;
    
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);
    
    if ((emptyRow == tileRow && (emptyCol - tileCol == 1 || emptyCol - tileCol == -1)) ||
        (emptyCol == tileCol && (emptyRow - tileRow == 1 || emptyRow - tileRow == -1))) {
        
       
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    } else {
        printf(""Invalid move. Please choose a tile adjacent to the empty space.\n"");
    }
}",0
sum778,1695980447,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowPosEmpty, colPosEmpty, rowPosTiles, colPosTiles;
	
	// tile that i want to move (tile)
	FindTile(board, tile, &rowPosTiles, &colPosTiles);

	// tile that is empty (-1)
	FindTile(board, -1, &rowPosEmpty, &colPosEmpty);

	if ((rowPosEmpty == rowPosTiles - 1) || (rowPosEmpty == rowPosTiles + 1) && (colPosEmpty == colPosTiles)) {
		board[rowPosEmpty][colPosEmpty] = tile;
		board[rowPosTiles][colPosTiles] = -1;
	}

	else if ((colPosEmpty == colPosTiles - 1) || (colPosEmpty == colPosTiles + 1) && (rowPosEmpty == rowPosTiles)) {
		board[rowPosEmpty][colPosEmpty] = tile;
		board[rowPosTiles][colPosTiles] = -1;
	}

}",0
sum778,1695980720,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowPosEmpty, colPosEmpty, rowPosTiles, colPosTiles;
	
	// tile that i want to move (tile)
	FindTile(board, tile, &rowPosTiles, &colPosTiles);

	// tile that is empty (-1)
	FindTile(board, -1, &rowPosEmpty, &colPosEmpty);

	if ((rowPosEmpty == rowPosTiles - 1 || rowPosEmpty == rowPosTiles + 1) && (colPosEmpty == colPosTiles)) {
		board[rowPosEmpty][colPosEmpty] = tile;
		board[rowPosTiles][colPosTiles] = -1;
	}

	else if ((colPosEmpty == colPosTiles - 1 || colPosEmpty == colPosTiles + 1) && (rowPosEmpty == rowPosTiles)) {
		board[rowPosEmpty][colPosEmpty] = tile;
		board[rowPosTiles][colPosTiles] = -1;
	}

}",1
sval918,1696224209,1,"#include <stdio.h>
#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int title){
    for (int i = 0; i < NUM_ROWS; i++){
        for (int j = 0; i < NUM_COLS; j++){
            
            if (board[i][j] == -1){
                printf(""_ "");
            } else {
                printf(""%2d "", board[i][j]);
            }
        }
        printf(""\n"");
    }
}",0
sval918,1696235371,2,"#include <stdio.h>
#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int title){
    for (int i = 0; i < NUM_ROWS; i++){
        for (int j = 0; j < NUM_COLS; j++){
            
            if (board[i][j] == -1){
                printf(""_ "");
            } else {
                printf(""%d "", board[i][j]);
            }
        }
        printf(""\n"");
    }
}",0
swan472,1695940361,1,"#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>

#define NUM_ROWS 4
#define NUM_COLS 4

// Function to print the board
void PrintBoard(int board[NUM_ROWS][NUM_COLS]) 
{
    for (int i = 0; i < NUM_ROWS; i++) 
    {
        for (int j = 0; j < NUM_COLS; j++) 
        {
            if (board[i][j] == -1) 
            {
                printf("" _ "");
            } else {
                printf("" %2d"", board[i][j]);
            }
        }
        printf(""\n"");
    }
    printf(""\n"");
}

// Function to find the position of a tile on the board
void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *row, int *col) 
{
    for (int i = 0; i < NUM_ROWS; i++) 
    {
        for (int j = 0; j < NUM_COLS; j++) 
        {
            if (board[i][j] == tile) 
            {
                *row = i;
                *col = j;
                return;
            }
        }
    }
}

// Function to make a move
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) 

{
    int emptyRow, emptyCol, tileRow, tileCol;

    // Find the position of the empty square (-1)
    FindTile(board, -1, &emptyRow, &emptyCol);

    // Find the position of the specified tile
    FindTile(board, tile, &tileRow, &tileCol);

    // Check if the specified tile is adjacent to the empty square
    if ((abs(emptyRow - tileRow) == 1 && emptyCol == tileCol) ||
        (abs(emptyCol - tileCol) == 1 && emptyRow == tileRow)) 
        
        {
        // Swap the tile and the empty square
        int temp = board[emptyRow][emptyCol];
        board[emptyRow][emptyCol] = board[tileRow][tileCol];
        board[tileRow][tileCol] = temp;
    }
}

",0
swan472,1695940425,2,"#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>

#define NUM_ROWS 4
#define NUM_COLS 4

// Function to print the board
void PrintBoard(int board[NUM_ROWS][NUM_COLS]) {
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == -1) {
                printf("" _ "");
            } else {
                printf("" %2d"", board[i][j]);
            }
        }
        printf(""\n"");
    }
    printf(""\n"");
}

// Function to find the position of a tile on the board
void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos) {
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == tile) {
                *rowPos = i;
                *colPos = j;
                return;
            }
        }
    }
}

// Function to make a move
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol, tileRow, tileCol;

    // Find the position of the empty square (-1)
    FindTile(board, -1, &emptyRow, &emptyCol);

    // Find the position of the specified tile
    FindTile(board, tile, &tileRow, &tileCol);

    // Check if the specified tile is adjacent to the empty square
    if ((abs(emptyRow - tileRow) == 1 && emptyCol == tileCol) ||
        (abs(emptyCol - tileCol) == 1 && emptyRow == tileRow)) {
        // Swap the tile and the empty square
        int temp = board[emptyRow][emptyCol];
        board[emptyRow][emptyCol] = board[tileRow][tileCol];
        board[tileRow][tileCol] = temp;
    }
}",0
swan472,1695940749,3,"#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>

#define NUM_ROWS 4
#define NUM_COLS 4

// Function to declare, to be defined later
void PrintBoard(int board[NUM_ROWS][NUM_COLS]);
void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos);

// Function to make a move
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol, tileRow, tileCol;

    // Find the position of the empty square (-1)
    FindTile(board, -1, &emptyRow, &emptyCol);

    // Find the position of the specified tile
    FindTile(board, tile, &tileRow, &tileCol);

    // Check if the specified tile is adjacent to the empty square
    if ((abs(emptyRow - tileRow) == 1 && emptyCol == tileCol) ||
        (abs(emptyCol - tileCol) == 1 && emptyRow == tileRow)) {
        // Swap the tile and the empty square
        int temp = board[emptyRow][emptyCol];
        board[emptyRow][emptyCol] = board[tileRow][tileCol];
        board[tileRow][tileCol] = temp;
    }
}

// Function to print the board
void PrintBoard(int board[NUM_ROWS][NUM_COLS]) {
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == -1) {
                printf("" _ "");
            } else {
                printf("" %2d"", board[i][j]);
            }
        }
        printf(""\n"");
    }
    printf(""\n"");
}

// Function to find the position of a tile on the board
void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos) {
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == tile) {
                *rowPos = i;
                *colPos = j;
                return;
            }
        }
    }
}",0
swan472,1695941507,4,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

// Function to find the row and column of a tile in the board
void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *row, int *col) {
    for (*row = 0; *row < NUM_ROWS; (*row)++) {
        for (*col = 0; *col < NUM_COLS; (*col)++) {
            if (board[*row][*col] == tile) {
                return;
            }
        }
    }
}

// Function to print the board
void PrintBoard(int board[NUM_ROWS][NUM_COLS]) {
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == -1) {
                printf("" _ "");
            } else {
                printf(""%2d "", board[i][j]);
            }
        }
        printf(""\n"");
    }
}

// Function to make a move by swapping the specified tile with the empty square
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol, tileRow, tileCol;
    
    // Find the row and column of the empty square (-1)
    FindTile(board, -1, &emptyRow, &emptyCol);
    
    // Find the row and column of the specified tile
    FindTile(board, tile, &tileRow, &tileCol);
    
    // Check if the specified tile is adjacent to the empty square
    if ((abs(emptyRow - tileRow) == 1 && emptyCol == tileCol) ||
        (abs(emptyCol - tileCol) == 1 && emptyRow == tileRow)) {
        // Swap the specified tile and the empty square
        int temp = board[emptyRow][emptyCol];
        board[emptyRow][emptyCol] = board[tileRow][tileCol];
        board[tileRow][tileCol] = temp;
    }
}",0
swan472,1696232901,5,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

int FindTile(int board[NUM_ROWS][NUM_COLS], int tile) {
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == tile) {
                return i * NUM_COLS + j;
            }
        }
    }
    return -1;
}

void PrintBoard(int board[NUM_ROWS][NUM_COLS]) {
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == -1) {
                printf(""_  "");
            } else {
                printf(""%2d "", board[i][j]);
            }
        }
        printf(""\n"");
    }
}

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    // Find the positions of the tile and the empty square
    int tilePos = FindTile(board, tile);
    int emptyPos = FindTile(board, -1);

    // Calculate row and column indices of the tile and empty square
    int tileRow = tilePos / NUM_COLS;
    int tileCol = tilePos % NUM_COLS;
    int emptyRow = emptyPos / NUM_COLS;
    int emptyCol = emptyPos % NUM_COLS;

    // Check if the tile and empty square are adjacent
    if ((abs(tileRow - emptyRow) == 1 && tileCol == emptyCol) ||
        (abs(tileCol - emptyCol) == 1 && tileRow == emptyRow)) {
        // Swap the tile and the empty square
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}

",0
swan472,1696233029,6,"#include <stdio.h>
#include <stdlib.h>

#define NUM_ROWS 4
#define NUM_COLS 4

int FindTilePosition(int board[NUM_ROWS][NUM_COLS], int tile) {
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == tile) {
                return i * NUM_COLS + j;
            }
        }
    }
    return -1;
}

void DisplayBoard(int board[NUM_ROWS][NUM_COLS]) {
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == -1) {
                printf(""_  "");
            } else {
                printf(""%2d "", board[i][j]);
            }
        }
        printf(""\n"");
    }
}

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    // Find the positions of the tile and the empty square
    int tilePos = FindTilePosition(board, tile);
    int emptyPos = FindTilePosition(board, -1);

    // Calculate row and column indices of the tile and empty square
    int tileRow = tilePos / NUM_COLS;
    int tileCol = tilePos % NUM_COLS;
    int emptyRow = emptyPos / NUM_COLS;
    int emptyCol = emptyPos % NUM_COLS;

    // Check if the tile and empty square are adjacent
    if ((abs(tileRow - emptyRow) == 1 && tileCol == emptyCol) ||
        (abs(tileCol - emptyCol) == 1 && tileRow == emptyRow)) {
        // Swap the tile and the empty square
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}",1
sweb390,1695700603,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowEmpty;
	int colEmpty;
	int rowPiece;
	int colPiece;
	int rowAdjacent;
	int colAdjacent;

	FindTile(board, -1, &rowEmpty, &colEmpty);
	FindTile(board, tile, &rowPiece, &colPiece);

	rowAdjacent = rowEmpty - rowPiece;
	if ((rowAdjacent == 0) || (rowAdjacent == -1) || (rowAdjacent == 1)) {
		rowAdjacent = 1;
	}
	colAdjacent = colEmpty - colPiece;
	if ((colAdjacent == 0) || (colAdjacent == -1) || (colAdjacent == 1)) {
		colAdjacent = 1;
	}


	if ((rowAdjacent == 1) && (colAdjacent == 1)) {
		board[rowEmpty][colEmpty] = tile;
		board[rowPiece][colPiece] = -1;
	}

	return;

}",1
swil676,1696243104,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int tilePosRow,tilePosCol,emptyPosRow,emptyPosCol;

    //find tile you want to swap with 
    FindTile(board,tile,&tilePosRow,&tilePosCol);
    //find empty tile 
    FindTile(board,-1,&emptyPosRow,&emptyPosCol);

    //if the tiles are adjacent 
    if (((tilePosRow - emptyPosRow == 1 || tilePosRow - emptyPosRow == -1) && tilePosCol == emptyPosCol) || 
    (tilePosRow == emptyPosRow && (tilePosCol - emptyPosCol == 1 || tilePosCol - emptyPosCol == -1))) {
        //set tile to empty
        board[tilePosRow][tilePosCol]=-1;
        //set empty tile to value of tile 
        board[emptyPosRow][emptyPosCol]=tile;
    }
}",1
syok443,1695707212,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col;
    FindTile(board, tile, &row, &col);

    int selectorRow, selectorCol;
    FindTile(board, -1, &selectorRow, &selectorCol);

    //position indicator
    int n = 0;

    if(row == selectorRow && (col == selectorCol + 1 || col == selectorCol - 1)){
        n++;
    } else if(col == selectorCol && (row == selectorRow + 1 || row == selectorRow - 1)) {
        n++;
    }
    
    if(n > 0){

        //points to -1 or the empty tile
        int *empty;
        // points to the value getting moved
        int *moveTile;
        
        empty = &board[selectorRow][selectorCol];
        moveTile = &board[row][col];

        *empty = *moveTile;
        *moveTile = -1;
    }

}",1
syua841,1696223827,1,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRow;
    int tileCol;
    int emptyRow;
    int emptyCol;

    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol);

    if ((abs(tileRow - emptyRow) == 1 && tileCol == emptyCol) || (tileRow == emptyRow == 1 && abs(tileCol - emptyCol))) {
        int position = board[tileRow][tileCol];
        board[tileRow][tileCol] = board[emptyRow][emptyCol];
        board[emptyRow][emptyCol] = position;
    } else {
        PrintBoard(board)
    }
}
",0
syua841,1696223891,2,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRow;
    int tileCol;
    int emptyRow;
    int emptyCol;

    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol);

    if ((abs(tileRow - emptyRow) == 1 && (tileCol) == emptyCol) || (tileRow == emptyRow) == 1 && abs(tileCol - emptyCol))) {
        int position = board[tileRow][tileCol];
        board[tileRow][tileCol] = board[emptyRow][emptyCol];
        board[emptyRow][emptyCol] = position;
    } else {
        PrintBoard(board);
    }
}
",0
syua841,1696224147,3,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRow;
    int tileCol;
    int emptyRow;
    int emptyCol;

    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol);

    if ((abs(tileRow - emptyRow) == 1 && tileCol == emptyCol) || tileRow == emptyRow == 1 && (abs(tileCol - emptyCol))) {
        int position = board[tileRow][tileCol];
        board[tileRow][tileCol] = board[emptyRow][emptyCol];
        board[emptyRow][emptyCol] = position;
    } else {
        PrintBoard(board);
    }
}
",0
syua841,1696224308,4,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRow;
    int tileCol;
    int emptyRow;
    int emptyCol;

    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol);

    if ((abs(tileRow - emptyRow) == 1 && tileCol == emptyCol) || (tileRow == emptyRow == 1 && (abs(tileCol - emptyCol))) {
        int position = board[tileRow][tileCol];
        board[tileRow][tileCol] = board[emptyRow][emptyCol];
        board[emptyRow][emptyCol] = position;
    } else {
        PrintBoard(board);
    }
}
",0
syua841,1696224423,5,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRow;
    int tileCol;
    int emptyRow;
    int emptyCol;

    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol);

    if ((abs(tileRow - emptyRow) == 1 && tileCol == emptyCol) || (tileRow == emptyRow == 1 && (abs(tileCol - emptyCol)))) {
        int position = board[tileRow][tileCol];
        board[tileRow][tileCol] = board[emptyRow][emptyCol];
        board[emptyRow][emptyCol] = position;
    } else {
        PrintBoard(board);
    }
}
",0
syua841,1696224483,6,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRow;
    int tileCol;
    int emptyRow;
    int emptyCol;

    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol);

    if ((abs(tileRow - emptyRow) == 1 && tileCol == emptyCol) || (tileRow == emptyRow && (abs(tileCol - emptyCol) == 1))) {
        int position = board[tileRow][tileCol];
        board[tileRow][tileCol] = board[emptyRow][emptyCol];
        board[emptyRow][emptyCol] = position;
    } else {
        PrintBoard(board);
    }
}
",0
syua841,1696224517,7,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRow;
    int tileCol;
    int emptyRow;
    int emptyCol;

    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol);

    if ((abs(tileRow - emptyRow) == 1 && tileCol == emptyCol) || (tileRow == emptyRow && (abs(tileCol - emptyCol) == 1))) {
        int position = board[tileRow][tileCol];
        board[tileRow][tileCol] = board[emptyRow][emptyCol];
        board[emptyRow][emptyCol] = position;
    } else {
        return 0
    }
}
",0
syua841,1696224525,8,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRow;
    int tileCol;
    int emptyRow;
    int emptyCol;

    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol);

    if ((abs(tileRow - emptyRow) == 1 && tileCol == emptyCol) || (tileRow == emptyRow && (abs(tileCol - emptyCol) == 1))) {
        int position = board[tileRow][tileCol];
        board[tileRow][tileCol] = board[emptyRow][emptyCol];
        board[emptyRow][emptyCol] = position;
    } else {
        return 0;
    }
}
",0
syua841,1696224542,9,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRow;
    int tileCol;
    int emptyRow;
    int emptyCol;

    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol);

    if ((abs(tileRow - emptyRow) == 1 && tileCol == emptyCol) || (tileRow == emptyRow && (abs(tileCol - emptyCol) == 1))) {
        int position = board[tileRow][tileCol];
        board[tileRow][tileCol] = board[emptyRow][emptyCol];
        board[emptyRow][emptyCol] = position;

    }
}
",1
szen566,1695805226,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowinput, colinput, rowempty, colempty;

	FindTile(board, tile, &rowinput, &colinput);
	FindTile(board, -1, &rowempty, &colempty);

	// Swap places:
	int temp = board[rowinput][colinput];

	// See if inputed tile is adjacent to the -1 tile
	// If diagonal, dont do anything
	if (((rowempty == rowinput - 1) || (rowempty == rowinput + 1)) && ((colempty == colinput - 1) || (colempty == colinput + 1))) {
		return;
	}

	// If above or below, swap
	// Do not swap if input and empty slot aren't on the same column
	if (((rowempty == rowinput - 1) || (rowempty == rowinput + 1)) && (colempty == colinput)) {
		board[rowinput][colinput] = board[rowempty][colempty];
		board[rowempty][colempty] = temp;
	}

	// If input is to the right  of the empty slot, swap:
	// but DON'T swap if input and empty slot aren't on the same row
	if ((colempty == colinput - 1) && (rowempty == rowinput)) {
		board[rowinput][colinput] = board[rowempty][colempty];
		board[rowempty][colempty] = temp;
	}

	// If input is to the left of the empty slot, swap:
	// but DON'T swap if input and empty aren't on the same row
	if ((colempty == colinput + 1) && (rowempty == rowinput)) {
		board[rowinput][colinput] = board[rowempty][colempty];
		board[rowempty][colempty] = temp;
	}
}",1
szho466,1696241165,1,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    int i,j;
    int *rowPos;
    int *colPos;

    for (i=0; i< NUM_ROWS; i++) {
        for (j=0; j< NUM_COLS; j++) {
            if (board[i][j]==tile){
                if (i>0 && i<NUM_ROWS-1 && j>0 && j<NUM_COLS-1){
                    if (board[i-1][j]== *rowPos|| board[i+1][j]== *rowPos || board[i][j-1]==*colPos||board[i][j]+1== *colPos){
                    *rowPos=i;
                    *colPos=j;
                     board[i][j]=-1;
                    return;
                    }
                }
            
                    else{
                      if (i==0||i==NUM_ROWS-1||j==0||j==NUM_COLS-1){
                        if(board[i-1][j]== *rowPos|| board[i+1][j]== *rowPos || board[i][j-1]==*colPos||board[i][j+1]== *colPos){
                        *rowPos=i;
                        *colPos=j;
                        board[i][j]=-1;
                        return;
                        }
                    }
                }
            }
        }
    }
}  ",0
szho466,1696241314,2,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile,  int *rowPos, int *colPos){
    int i,j;

    for (i=0; i< NUM_ROWS; i++) {
        for (j=0; j< NUM_COLS; j++) {
            if (board[i][j]==tile){
                if (i>0 && i<NUM_ROWS-1 && j>0 && j<NUM_COLS-1){
                    if (board[i-1][j]== *rowPos|| board[i+1][j]== *rowPos || board[i][j-1]==*colPos||board[i][j]+1== *colPos){
                    *rowPos=i;
                    *colPos=j;
                     board[i][j]=-1;
                    return;
                    }
                }
            
                    else{
                      if (i==0||i==NUM_ROWS-1||j==0||j==NUM_COLS-1){
                        if(board[i-1][j]== *rowPos|| board[i+1][j]== *rowPos || board[i][j-1]==*colPos||board[i][j+1]== *colPos){
                        *rowPos=i;
                        *colPos=j;
                        board[i][j]=-1;
                        return;
                        }
                    }
                }
            }
        }
    }
}  ",0
szho466,1696244231,3,"#include <stdio.h>
void MakeMove(int board[NUM_ROWS][NUM_ COLS], int tile, int *rowPos, int *colPos) {
int i, j;
int tileRoW =-1; 
int tileCol = -1;
    for (i=0; i< NUM ROWS; i++) {
        for (j= 0; j < NUM COLS; j++) {
            if (boardlillil== tile){
            tileRow=i;
            tileCol=i;
            break;
            }
        }
        
    }
    
    if (tileRow != -1 && tileCol != -1) {
        if ((tileRow > 0 && board[tileRow - 1][tileCol] ==-1) ||
            (tileRow < NUM ROWS - 1 && board[tileRow + 1][tileCol] ==-1) ||
            (tileCol > 0 && board[tileRow][tileCol-1]==-1) ||
            (tilleCol < NUM COLS - 1 && board[tileRow][tileCol+ 1] == -1)) {
            board[tileRow][tileCol]=-1;
            board[*rowPos][*colPos] = tile;
            *roWPos = tileRow;
            *colPos = tileCol;
        }
            
    }

}",0
tais804,1695697115,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, new_row, new_col;
 	FindTile(board, -1, &row, &col);
	FindTile(board, tile, &new_row, &new_col);
	if (new_row - row == 1) {
		if (new_col - col == 1) {
			board[new_row][new_col] = -1;
			board[row][col] = tile;
		} else if (col - new_col == 1){
			board[new_row][new_col] = -1;
			board[row][col] = tile;
		} else if (col == new_col) {
			board[new_row][new_col] = -1;
			board[row][col] = tile;
		} else if (col == new_col){
			board[new_row][new_col] = -1;
			board[row][col] = tile;
		}

	} else if (row - new_row == 1) {
		if (new_col - col == 1) {
			board[new_row][new_col] = -1;
			board[row][col] = tile;
		} else if (col - new_col == 1){
			board[new_row][new_col] = -1;
			board[row][col] = tile;
		} else if (col == new_col){
			board[new_row][new_col] = -1;
			board[row][col] = tile;
		}
		
	} else if ( row == new_row) {
		if (new_col - col == 1) {
			board[new_row][new_col] = -1;
			board[row][col] = tile;
		} else if (col - new_col == 1){
			board[new_row][new_col] = -1;
			board[row][col] = tile;
		} else if (col == new_col){
			board[new_row][new_col] = -1;
			board[row][col] = tile;
		}
	}	
	
}",1
tbad483,1695854519,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    int e_row, e_col, num_row, num_col;
    FindTile(board, -1, &e_row, &e_col);
    FindTile(board, tile, &num_row, &num_col);
    if (((e_row == num_row - 1)&&(e_col == num_col)) || ((e_row == num_row)&&(e_col == num_col - 1)) || ((e_row == num_row + 1)&&(e_col == num_col)) || ((e_row == num_row)&&(e_col == num_col + 1))){
        board[e_row][e_col] = tile;
        board[num_row][num_col] = -1;
    }
}",1
tbar968,1695875580,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i;
	int j;
	int newRow;
	int newCol;
	int oldRow;
	int oldCol;
	int temp;
	int a;
	int b;
	a = 0;
	b = 0;

	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == tile) {
				newRow = i;
				newCol = j;
			}
			else if (board[i][j] == -1) {
				oldRow = i;
				oldCol = j;
			}
		}
	}

	if (oldRow - newRow> 1 || newRow - oldRow> 1) {
		return;
	}
	if (oldRow - newRow == 1 || newRow - oldRow == 1) {
		a=1;
	}

	if (oldCol - newCol> 1 || newCol - oldCol> 1) {
		return;
	}
	if (oldCol - newCol == 1 || newCol - oldCol == 1) {
		b=1;
	}

	if (a == 1 && b == 1) {
		return;
	}

	temp = board[oldRow][oldCol];
	board[oldRow][oldCol] = board[newRow][newCol];
	board[newRow][newCol] = temp;
	return board;
}",0
tbar968,1695875908,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i;
	int j;
	int newRow;
	int newCol;
	newRow = -1;
	newCol = -1;
	int oldRow;
	int oldCol;
	int temp;
	int a;
	int b;
	a = 0;
	b = 0;

	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == tile) {
				newRow = i;
				newCol = j;
			}
			else if (board[i][j] == -1) {
				oldRow = i;
				oldCol = j;
			}
		}
	}

	if (newRow == -1 && newCol == -1) {
		return;
	}

	if (oldRow - newRow> 1 || newRow - oldRow> 1) {
		return;
	}
	if (oldRow - newRow == 1 || newRow - oldRow == 1) {
		a=1;
	}

	if (oldCol - newCol> 1 || newCol - oldCol> 1) {
		return;
	}
	if (oldCol - newCol == 1 || newCol - oldCol == 1) {
		b=1;
	}

	if (a == 1 && b == 1) {
		return;
	}

	temp = board[oldRow][oldCol];
	board[oldRow][oldCol] = board[newRow][newCol];
	board[newRow][newCol] = temp;
}",1
tbar971,1695697060,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowPosTile;
	int colPosTile;

	FindTile(board, tile, &rowPosTile, &colPosTile);

	int rowPosBlank;
	int colPosBlank;

	FindTile(board, -1, &rowPosBlank, &colPosBlank);

	// case if blank is on left edge
	if (colPosBlank == 0) {
		if (rowPosTile == rowPosBlank - 1) {
			board[rowPosBlank][colPosBlank] = tile;
			board[rowPosTile][colPosTile] = -1;
		} else if(rowPosTile == rowPosBlank + 1) {
			board[rowPosBlank][colPosBlank] = tile;
			board[rowPosTile][colPosTile] = -1;
		} else if (colPosTile == colPosBlank + 1) {
			board[rowPosBlank][colPosBlank] = tile;
			board[rowPosTile][colPosTile] = -1;
		}
	}

	// case if blank is on right edge
	if (colPosBlank == NUM_COLS) {
		if (rowPosTile == rowPosBlank - 1) {
			board[rowPosBlank][colPosBlank] = tile;
			board[rowPosTile][colPosTile] = -1;
		}
		else if (rowPosTile == rowPosBlank + 1) {
			board[rowPosBlank][colPosBlank] = tile;
			board[rowPosTile][colPosTile] = -1;
		}
		else if (colPosTile == colPosBlank - 1) {
			board[rowPosBlank][colPosBlank] = tile;
			board[rowPosTile][colPosTile] = -1;
		}
	}
	if ((colPosBlank > 0) && (colPosBlank < NUM_COLS)) {
		if ((rowPosTile == rowPosBlank - 1) && (colPosBlank == colPosTile)) {
			board[rowPosBlank][colPosBlank] = tile;
			board[rowPosTile][colPosTile] = -1;
		}
		else if ((rowPosTile == rowPosBlank + 1) && (colPosBlank == colPosTile)) {
			board[rowPosBlank][colPosBlank] = tile;
			board[rowPosTile][colPosTile] = -1;
		}
		else if ((colPosTile == colPosBlank - 1) && (rowPosBlank == rowPosTile)) {
			board[rowPosBlank][colPosBlank] = tile;
			board[rowPosTile][colPosTile] = -1;
		}
		else if ((colPosTile == colPosBlank + 1) && (rowPosBlank == rowPosTile)) {
			board[rowPosBlank][colPosBlank] = tile;
			board[rowPosTile][colPosTile] = -1;
		}
	}
	else {
		board = board;
		return;
	}
}",1
tbas606,1696228052,1,"#include <stdio.h>
/* This Function MakeMove should call the FindTile functionand be able to swap the specified tile with the empty square. 
If the specified tile is not next to the empty square then it cannot be moved
Author: Taha Basar
*/
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol;
    int tileRow, tileCol;
    
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);
    
    if ((abs(emptyRow - tileRow) == 1 && emptyCol == tileCol) || 
        (abs(emptyCol - tileCol) == 1 && emptyRow == tileRow)) {
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}",1
tbed601,1696203473,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;
	FindTile(board, -1, &row, &col);

			if (tile == board[row + 1][col]) {
				board[row][col] = tile;
				board[row + 1][col] = -1;
				return;
			}

			else if (tile == board[row - 1][col]) {
				board[row][col] = tile;
				board[row - 1][col] = -1;
				return;
			}

			else if (tile == board[row][col + 1]) {
				board[row][col] = tile;
				board[row][col + 1] = -1;
				return;
			}

			else if (tile == board[row][col - 1]) {
				board[row][col] = tile;
				board[row][col - 1] = -1;
				return;
			}
}",0
tbed601,1696204405,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;
	FindTile(board, -1, &row, &col);

	if (row > 0) {

	if (tile == board[row + 1][col]) {
		board[row][col] = tile;
		board[row + 1][col] = -1;
		return;
	}

	else if (tile == board[row - 1][col]) {
		board[row][col] = tile;
		board[row - 1][col] = -1;
		return;
	}
}

	else if (col > 0) {
		if (tile == board[row][col + 1]) {
			board[row][col] = tile;
			board[row][col + 1] = -1;
			return;
		}

		else if (tile == board[row][col - 1]) {
			board[row][col] = tile;
			board[row][col - 1] = -1;
			return;
		}
	}
}",0
tbed601,1696205027,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;
	FindTile(board, -1, &row, &col);


	if (tile == board[row + 1][col]) {
		board[row][col] = tile;
		board[row + 1][col] = -1;
		return;
	}
	 
	if (row > 0) {

	if (tile == board[row - 1][col]) {
		board[row][col] = tile;
		board[row - 1][col] = -1;
		return;
	}
}

		if (tile == board[row][col + 1]) {
			board[row][col] = tile;
			board[row][col + 1] = -1;
			return;
		}

	 else if (col > 0) {

	 if (tile == board[row][col - 1]) {
			board[row][col] = tile;
			board[row][col - 1] = -1;
			return;
		   }
		} 
	}",0
tbed601,1696206222,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;
	FindTile(board, -1, &row, &col);


	if (tile == board[row + 1][col] && row < NUM_ROWS) {
		board[row][col] = tile;
		board[row + 1][col] = -1;
		return;
	}
	 


	else if (tile == board[row - 1][col] && row > 0) {
		board[row][col] = tile;
		board[row - 1][col] = -1;
		return;
	}


	else if (tile == board[row][col + 1] && col < NUM_COLS && col != 3) {
			board[row][col] = tile;
			board[row][col + 1] = -1;
			return;
		}


	else if (tile == board[row][col - 1] && col > 0) {
			board[row][col] = tile;
			board[row][col - 1] = -1;
			return;
		   }
		} ",1
tbri557,1696241557,1,"void MakeMove(int board[4][4], int tile){
    int tilerowPos, tilecolPos;
    FindTile(board, tile, &tilerowPos, &tilecolPos);
    printf(""%d, %d\n"", tilerowPos, tilecolPos);
    
    int blankrowPos, blankcolPos;
    FindTile(board, -1, &blankrowPos, &blankcolPos);
    printf(""%d, %d\n"", blankrowPos, blankcolPos);
    
    if (tilerowPos+1 == blankrowPos || tilerowPos-1 == blankrowPos || tilerowPos == blankrowPos){
        printf(""youre good1\n"");
        if (tilecolPos+1 == blankcolPos || tilecolPos-1 == blankcolPos || tilecolPos == blankcolPos){
            int tempvar;
            board[blankrowPos][blankcolPos] = tile;
            board[tilerowPos][tilecolPos] = -1;
            printf(""youre good2\n"");
            
        }
    }
    
    PrintBoard(board);
    

    
}",0
tbri557,1696241742,2,"void MakeMove(int board[4][4], int tile){
    int tilerowPos, tilecolPos;
    FindTile(board, tile, &tilerowPos, &tilecolPos);

    int blankrowPos, blankcolPos;
    FindTile(board, -1, &blankrowPos, &blankcolPos);

    if (tilerowPos+1 == blankrowPos || tilerowPos-1 == blankrowPos || tilerowPos == blankrowPos){
        if (tilecolPos+1 == blankcolPos || tilecolPos-1 == blankcolPos || tilecolPos == blankcolPos){
            board[blankrowPos][blankcolPos] = tile;
            board[tilerowPos][tilecolPos] = -1;

        }
    }
    
}",1
tche867,1695975760,1,"
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row1, col1;
	int row2, col2;
	int medium;
	FindTile(board, -1, &row1, &col1);
	FindTile(board, tile, &row2, &col2);
	if ((row1 == row2) && (col1 - col2 == 1 || col1 - col2 == -1))
	{
		//swap
		medium = board[row1][col1];
		board[row1][col1] = board[row2][col2];
		board[row2][col2] = medium;
	}
	if ((col1 == col2) && (row1 - row2 == 1 || row1 - row2 == -1))
	{
		medium = board[row1][col1];
		board[row1][col1] = board[row2][col2];
		board[row2][col2] = medium;
	}
}",1
tcoo725,1696214630,1,"#include <stdio.h>
 
void MakeMove(int board[4][4], int tile){
    
int row = 4; 
int col = 4;
int i;
int j;
int t;
int a;
int b;

a = -1;
b = -1;

    for(i=0; i < row; i++)
    {
        for(j=0; j < col; j++)
        {
            if(board[i][j] == -1)
            {
                a = i;
                b = j;
            }
            else if(board[i][j] == tile)
            {
                t = board[a][b];
                board[a][b] = board[i][j];
                board[i][j] = t;
            }
        }
    }
}",0
tcoo725,1696226387,2,"#include <stdio.h>
#include <stdlib.h>

void MakeMove(int board[4][4], int tile)
{
    int row = 4;
    int col = 4;
    int emptyRow; 
    int emptyCol; 
    int t;
    int found = 0; 
    int i; 
    int j;
    
    for(i = 0; i < row; i++)
    {
        for(j=0; j < col; i++)
        {
            if(board[i][j] == tile)
            {
                found = 1;
                break;
            }
        }
        if(found == 1){
            break;
        }
    }
    
    found = 0;
    for(i = 0; i < row; i++){
        for(j = 0; j < col; j++){
            if(board[i][j] == -1){
                emptyRow = i;
                emptyCol = j;
                found = 1;
                break;
            }
        }  
        if(found == 1){
            break;
        }     
    }
    
    if((abs(i - emptyRow) == 1 && j == emptyCol) || (abs(j - emptyCol) == 1 && i == emptyRow)){
        t = board[i][j];
        board[i][j] = board[emptyRow][emptyCol];
        board[emptyRow][emptyCol] = t;
    }
}
",0
tden200,1696243669,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {

	int  i, j,rows,cols;
	FindTile(board, tile, &rows, &cols);

	int a, b;

	for (i = 0; i < NUM_ROWS; i++) {
	for (j = 0; j < NUM_COLS; j++) {

		if (board[i][j] == -1) {
			a = i;
			b = j;
		}
	}
}
	if ((board[a][b] == board[rows + 1][cols] | board[rows][cols+1])| (board[rows][cols - 1]) | (board[rows-1][cols])){
		board[a][b] = tile;
		board[rows][cols] = -1;
	}



}",0
tden200,1696243813,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {

	int  i, j,rows,cols;
	FindTile(board, tile, &rows, &cols);

	int a, b;

	for (i = 0; i < NUM_ROWS; i++) {
	for (j = 0; j < NUM_COLS; j++) {

		if (board[i][j] == -1) {
			a = i;
			b = j;
		}
	}
}
	if (board[a][b] == (board[rows + 1][cols] | board[rows][cols+1]| board[rows][cols - 1] | board[rows-1][cols])){
		board[a][b] = tile;
		board[rows][cols] = -1;
	}



}",0
tdha392,1695900437,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos);
int tileRow = int row;
int tileCol = int col;


FindTile(int board[NUM_ROWS][NUM_COLS], -1, int *rowPos, int *colPos)
int emptyRow = int row;
int emptyCol = int col;

if ((tileRow == emptyRow) && ((tileCol == (emptyCol + 1)) || (tileCol == (emptyCol - 1))) || (tileCol == emptyCol) && ((tileRow == (emptyRow + 1)) || (tileRow == (emptyRow - 1)))) {
    board[emptyRow][emptyCol] = tile;
    board[tileRow][tileCol] = -1;
}",0
tdha392,1695900987,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
int tileRow, tileCol, emptyRow, emptyCol;

FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos);


FindTile(int board[NUM_ROWS][NUM_COLS], -1, int *rowPos, int *colPos)

if ((tileRow == emptyRow) && ((tileCol == (emptyCol + 1)) || (tileCol == (emptyCol - 1))) || (tileCol == emptyCol) && ((tileRow == (emptyRow + 1)) || (tileRow == (emptyRow - 1)))) {
    board[emptyRow][emptyCol] = tile;
    board[tileRow][tileCol] = -1;
}
}",0
tdha392,1695901303,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
int tileRow, tileCol, emptyRow, emptyCol;

FindTile(board, tile, &tileRow, &tileCol);
FindTile(board, -1, &emptyRow, &emptyCol);

if ((tileRow == emptyRow) && ((tileCol == (emptyCol + 1)) || (tileCol == (emptyCol - 1))) || (tileCol == emptyCol) && ((tileRow == (emptyRow + 1)) || (tileRow == (emptyRow - 1)))) {
    board[emptyRow][emptyCol] = tile;
    board[tileRow][tileCol] = -1;
}
}",0
tdha392,1695901421,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
int tileRow, tileCol, emptyRow, emptyCol;

FindTile(board, tile, &tileRow, &tileCol);
FindTile(board, -1, &emptyRow, &emptyCol);

if ((tileRow == emptyRow) && ((tileCol == (emptyCol + 1)) || (tileCol == (emptyCol - 1))) || (tileCol == emptyCol) && ((tileRow == (emptyRow + 1)) || (tileRow == (emptyRow - 1))))((tileRow == emptyRow && (tileCol == emptyCol + 1 || tileCol == emptyCol - 1)) || (tileCol == emptyCol && (tileRow == emptyRow + 1 || tileRow == emptyRow - 1))) {
    board[emptyRow][emptyCol] = tile;
    board[tileRow][tileCol] = -1;
}
}",0
tdha392,1695901595,5,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
int tileRow, tileCol, emptyRow, emptyCol;

FindTile(board, tile, &tileRow, &tileCol);
FindTile(board, -1, &emptyRow, &emptyCol);

    if ((tileRow == emptyRow && (tileCol == emptyCol + 1 || tileCol == emptyCol - 1)) ||
        (tileCol == emptyCol && (tileRow == emptyRow + 1 || tileRow == emptyRow - 1))) {
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
}
}",1
tdic873,1695684635,1,"
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	/* iterate over all of the tiles */
	for (int i = 0; i < NUM_ROWS; i++)
	{
		for (int j = 0; j < NUM_COLS; j++)
		{
			/* if the tile is the blank one */
			if (board[i][j] == -1)
			{	
				/* swap the target tile with the blank if it is next to blank visually  */
				if (board[i - 1][j] == tile && i - 1 >= 0) {
					board[i][j] = board[i - 1][j];
					board[i - 1][j] = -1;
				} else if (board[i + 1][j] == tile && i + 1 < NUM_ROWS) {
					board[i][j] = board[i + 1][j];
					board[i + 1][j] = -1;
				} else if (board[i][j - 1] == tile && j - 1 >= 0) {
					board[i][j] = board[i][j - 1];
					board[i][j - 1] = -1;
				} else if (board[i][j + 1] == tile && j + 1 < NUM_ROWS) {
					board[i][j] = board[i][j + 1];
					board[i][j + 1] = -1;
				}

				/* return so that if we find the blank tile later in the iteration,
				   we don't swap it back */
				return;
			}
		}
	}
}",1
tdon950,1695886617,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    
    int rowPos;
    int colPos;
       
    FindTile(board, tile, &rowPos, &colPos);
    
    if (board[rowPos][colPos + 1] == -1) {
        board[rowPos][colPos] = board[rowPos][colPos + 1];
        board[rowPos][colPos + 1] = -1;
    }
    
    if (board[rowPos][colPos - 1] == -1) {
        board[rowPos][colPos] = board[rowPos][colPos - 1];
        board[rowPos][colPos - 1] = -1;
    }
    
    if (board[rowPos + 1][colPos] == -1) {
        board[rowPos][colPos] = board[rowPos + 1][colPos];
        board[rowPos + 1][colPos] = -1;
    }
    
    if (board[rowPos - 1][colPos] == -1) {
        board[rowPos][colPos] = board[rowPos - 1][colPos];
        board[rowPos - 1][colPos] = -1;
    }
    
    return;
}",0
tdon950,1695887257,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    
    int rowPos;
    int colPos;
       
    FindTile(board, tile, &rowPos, &colPos);
    
    if (board[rowPos][colPos + 1] == -1) {
        board[rowPos][colPos + 1] = board[rowPos][colPos];
        board[rowPos][colPos] = -1;
    }
    
    if (board[rowPos][colPos - 1] == -1) {
        board[rowPos][colPos - 1] = board[rowPos][colPos];
        board[rowPos][colPos] = -1;
    }
    
    if (board[rowPos + 1][colPos] == -1) {
        board[rowPos + 1][colPos] = board[rowPos][colPos];
        board[rowPos][colPos] = -1;
    }
    
    if (board[rowPos - 1][colPos] == -1) {
        board[rowPos - 1][colPos] = board[rowPos][colPos];
        board[rowPos][colPos] = -1;
    }
    
    return;
}",0
tdon950,1695888751,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    
    int rowPos;
    int colPos;
       
    FindTile(board, tile, &rowPos, &colPos);
    
    if ((board[rowPos][colPos + 1] == -1) && (col < 3)) {
        board[rowPos][colPos + 1] = board[rowPos][colPos];
        board[rowPos][colPos] = -1;
    }
    
    if ((board[rowPos][colPos - 1] == -1) && (col > 0)) {
        board[rowPos][colPos - 1] = board[rowPos][colPos];
        board[rowPos][colPos] = -1;
    }
    
    if ((board[rowPos + 1][colPos] == -1) && (row > 0)) {
        board[rowPos + 1][colPos] = board[rowPos][colPos];
        board[rowPos][colPos] = -1;
    }
    
    if ((board[rowPos - 1][colPos] == -1) && (row < 3)) {
        board[rowPos - 1][colPos] = board[rowPos][colPos];
        board[rowPos][colPos] = -1;
    }
    
    return;
}",0
tdon950,1695888791,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    
    int rowPos;
    int colPos;
       
    FindTile(board, tile, &rowPos, &colPos);
    
    if ((board[rowPos][colPos + 1] == -1) && (colPos < 3)) {
        board[rowPos][colPos + 1] = board[rowPos][colPos];
        board[rowPos][colPos] = -1;
    }
    
    if ((board[rowPos][colPos - 1] == -1) && (colPos > 0)) {
        board[rowPos][colPos - 1] = board[rowPos][colPos];
        board[rowPos][colPos] = -1;
    }
    
    if ((board[rowPos + 1][colPos] == -1) && (rowPos > 0)) {
        board[rowPos + 1][colPos] = board[rowPos][colPos];
        board[rowPos][colPos] = -1;
    }
    
    if ((board[rowPos - 1][colPos] == -1) && (rowPos < 3)) {
        board[rowPos - 1][colPos] = board[rowPos][colPos];
        board[rowPos][colPos] = -1;
    }
    
    return;
}",0
tdon950,1695951707,5,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    
    int rowPos;
    int colPos;
       
    FindTile(board, tile, &rowPos, &colPos);
    
    if ((board[rowPos][colPos + 1] == -1) && (colPos <= 3)) {
        board[rowPos][colPos + 1] = board[rowPos][colPos];
        board[rowPos][colPos] = -1;
    }
    
    if ((board[rowPos][colPos - 1] == -1) && (colPos >= 0)) {
        board[rowPos][colPos - 1] = board[rowPos][colPos];
        board[rowPos][colPos] = -1;
    }
    
    if ((board[rowPos + 1][colPos] == -1) && (rowPos >= 0)) {
        board[rowPos + 1][colPos] = board[rowPos][colPos];
        board[rowPos][colPos] = -1;
    }
    
    if ((board[rowPos - 1][colPos] == -1) && (rowPos <= 3)) {
        board[rowPos - 1][colPos] = board[rowPos][colPos];
        board[rowPos][colPos] = -1;
    }
    return;
}",0
tdon950,1696237154,6,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    
    int r, c;
    int rows, cols;
    int distRow, discCol
    
    FindTile(board, tile, &rows, &cols);
    FindTile(board, -1, &r, &c);
    
    distCol = cols - c;
    distRow = rows - r;
    
    if ((distRow >= -1 && distRow <= 1) && (distCol >= -1 && distCol <= -1)) {
        int temp = board[rows][cols];
        board[rows][cols] = board[r][c];
        board[r][c] = temp;
        
    } else {
    
    return;
    }
}",0
tdon950,1696237202,7,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    
    int r, c;
    int rows, cols;
    int distRow, distCol
    
    FindTile(board, tile, &rows, &cols);
    FindTile(board, -1, &r, &c);
    
    distCol = cols - c;
    distRow = rows - r;
    
    if ((distRow >= -1 && distRow <= 1) && (distCol >= -1 && distCol <= -1)) {
        int temp = board[rows][cols];
        board[rows][cols] = board[r][c];
        board[r][c] = temp;
        
    } else {
    
    return;
    }
}",0
tdon950,1696237226,8,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    
    int r, c;
    int rows, cols;
    int distRow, distCol;
    
    FindTile(board, tile, &rows, &cols);
    FindTile(board, -1, &r, &c);
    
    distCol = cols - c;
    distRow = rows - r;
    
    if ((distRow >= -1 && distRow <= 1) && (distCol >= -1 && distCol <= -1)) {
        int temp = board[rows][cols];
        board[rows][cols] = board[r][c];
        board[r][c] = temp;
        
    } else {
    
    return;
    }
}",0
tdon950,1696239273,9,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int r;
    int c;
    int Row;
    int Col;
    
    FindTile(board, -1, &r, &c);
    FindTile(board, tile, &Row, &Col);
    
    if (c - Col < 3) {
        if(board[r][c] == board[Row][Col - 1]) {
        board[r][c] = board[Row][Row];
        board[Row][Col] = -1;
        }
        
        if(board[r][c] == board[Row][Col + 1]) {
        board[r][c] = board[Row][Row];
        board[Row][Col] = -1;
        }
    }
    
    if(board[r][c] == board[Row - 1][Col]) {
        board[r][c] = board[Row][Row];
        board[Row][Col] = -1;
    }
    
    if(board[r][c] == board[Row + 1][Col]) {
        board[r][c] = board[Row][Row];
        board[Row][Col] = -1;
    }
    
}",0
tdon950,1696239551,10,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int r;
    int c;
    int Row;
    int Col;
    
    FindTile(board, -1, &r, &c);
    FindTile(board, tile, &Row, &Col);
    
    
    if(board[r][c] == board[Row - 1][Col]) {
        board[r][c] = board[Row][Col];
        board[Row][Col] = -1;
    }
    
    if(board[r][c] == board[Row + 1][Col]) {
        board[r][c] = board[Row][Col];
        board[Row][Col] = -1;
    }
    
    if (c - Col < 3) {
        if(board[r][c] == board[Row][Col - 1]) {
        board[r][c] = board[Row][Col];
        board[Row][Col] = -1;
        }
        
        if(board[r][c] == board[Row][Col + 1]) {
        board[r][c] = board[Row][Col];
        board[Row][Col] = -1;
        }
    }
}",1
tdu824,1696238647,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowEmpty, columnEmpty, rowTile, columnTile;

    FindTile(board, -1, &rowEmpty, &columnEmpty); 
    FindTile(board, tile, &rowTile, &columnTile);

    if (columnEmpty==columnTile && rowEmpty==rowTile+1 && rowTile+1<NUM_ROWS) {
        board[rowEmpty][columnEmpty] = board[rowTile][columnTile];
        board[rowTile][columnTile] = -1;
    } else if (columnEmpty==columnTile && rowEmpty==rowTile-1 && rowTile>0) {
        board[rowEmpty][columnEmpty] = board[rowTile][columnTile];
        board[rowTile][columnTile] = -1;
    } else if (rowEmpty==rowTile && columnEmpty==columnTile+1 && columnTile+1<NUM_COLS) {
        board[rowEmpty][columnEmpty] = board[rowTile][columnTile];
        board[rowTile][columnTile] = -1;
    } else if (rowEmpty==rowTile && columnEmpty==columnTile-1 && columnTile>0) {
        board[rowEmpty][columnEmpty] = board[rowTile][columnTile];
        board[rowTile][columnTile] = -1;
    }
}",1
tfai092,1695945121,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    
    int row, col, rowTile, colTile;
    
    FindTile(board, -1, &row, &col); 
    FindTile(board, tile, &rowTile, &colTile); 
    
    
    if (rowTile==row&&colTile==col-1||colTile==col+1||colTile==col&&rowTile==row-1||rowTile==row+1) {
        board[row][col] = tile;
        board[rowTile][colTile] = -1;
    }
    else {
        return; 
    }
}",0
tfai092,1695945281,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    
    int row, col, rowTile, colTile;
    
    FindTile(board, -1, &row, &col);
    FindTile(board, tile, &rowTile, &colTile);
    
    if ((rowTile == row && (colTile == col - 1 || colTile == col + 1)) ||
        (colTile == col && (rowTile == row - 1 || rowTile == row + 1))) {
        
        board[row][col] = tile;
        board[rowTile][colTile] = -1;
    }
    else {
        return;
    }
}",1
tfai653,1695698121,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	// Define variables.
	int i, j, row1, col1, row2, col2, val1, val2;
	
	// Find the position of the empty tile and the designated tile.
	FindTile(board, -1, &row1, &col1);
	FindTile(board, tile, &row2, &col2);

// Move tile below empty space.
if (row1 - row2 == 1) {
	if (col1 - col2 == 0) {
		val1 = board[row1][col1];
		val2 = board[row2][col2];
		board[row1][col1] = val2;
		board[row2][col2] = val1;
	}
}
// Move tile above empty space.
if (row1 - row2 == -1) {
	if (col1- col2 == 0) {
		val1 = board[row1][col1];
		val2 = board[row2][col2];
		board[row1][col1] = val2;
		board[row2][col2] = val1;
	}
}
// Move tile to the left of empty space.
if (col1 - col2 == 1) {
	if (row1 - row2 == 0) {
		val1 = board[row1][col1];
		val2 = board[row2][col2];
		board[row1][col1] = val2;
		board[row2][col2] = val1;
	}
}
// Move tile to the right of empty space.
if (col1 - col2 == -1) {
	if (row1 - row2 == 0) {
		val1 = board[row1][col1];
		val2 = board[row2][col2];
		board[row1][col1] = val2;
		board[row2][col2] = val1;
	}
}
}",0
tfai653,1695698405,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	// Define variables.
	int row1, col1, row2, col2, val1, val2;
	
	// Find the position of the empty tile and the designated tile.
	FindTile(board, -1, &row1, &col1);
	FindTile(board, tile, &row2, &col2);

// Move tile below empty space.
if (row1 - row2 == 1) {
	if (col1 - col2 == 0) {
		val1 = board[row1][col1];
		val2 = board[row2][col2];
		board[row1][col1] = val2;
		board[row2][col2] = val1;
	}
}
// Move tile above empty space.
if (row1 - row2 == -1) {
	if (col1- col2 == 0) {
		val1 = board[row1][col1];
		val2 = board[row2][col2];
		board[row1][col1] = val2;
		board[row2][col2] = val1;
	}
}
// Move tile to the left of empty space.
if (col1 - col2 == 1) {
	if (row1 - row2 == 0) {
		val1 = board[row1][col1];
		val2 = board[row2][col2];
		board[row1][col1] = val2;
		board[row2][col2] = val1;
	}
}
// Move tile to the right of empty space.
if (col1 - col2 == -1) {
	if (row1 - row2 == 0) {
		val1 = board[row1][col1];
		val2 = board[row2][col2];
		board[row1][col1] = val2;
		board[row2][col2] = val1;
	}
}
}",1
thal182,1695614328,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;
	FindTile(board, tile, &row, &col);
	int emptyRow, emptyCol;
	FindTile(board, -1, &emptyRow, &emptyCol);
	if ((row == emptyRow && (col == emptyCol - 1 || col == emptyCol + 1)) || (col == emptyCol && (row == emptyRow - 1 || row == emptyRow + 1))) {
		board[emptyRow][emptyCol] = tile;
		board[row][col] = -1;
	}
}",1
thar970,1695654284,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    int row, col,row2,col2;
    FindTile(board, tile , &row, &col);
    FindTile(board, -1 , &row2, &col2);
    board[row2][col2]=board[row][col];
    board[row][col]=-1;
}
",0
thar970,1695656344,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    int row, col,row2,col2;
    FindTile(board, tile , &row, &col);
    FindTile(board, -1 , &row2, &col2);
    // printf(""%d,%d\n"",abs(row-row2),abs(col-col2));
    if((row==row2||col==col2)){
        if(abs(row-row2)==1&&abs(col-col2)==1){
            board[row2][col2]=board[row][col];
            board[row][col]=-1;
        }

    }
}
",0
thar970,1695656414,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    int row, col,row2,col2;
    FindTile(board, tile , &row, &col);
    FindTile(board, -1 , &row2, &col2);
    // printf(""%d,%d\n"",abs(row-row2),abs(col-col2));
    if((row==row2||col==col2)){
        if(abs(row-row2)==1||abs(col-col2)==1){
            board[row2][col2]=board[row][col];
            board[row][col]=-1;
        }

    }
}
",1
thid924,1696073272,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	//initialize variables
	int emptyRow, emptyCol;
	int tileRow, tileCol;
	int rowValid, colValid;

	//find the position of the empty tile
	FindTile(board, -1, &emptyRow, &emptyCol);

	//find the position of the tile the player wants to move
	for (int i = 0; i < NUM_ROWS; i++) {
		for (int j = 0; j < NUM_COLS; j++) {

			if (board[i][j] == tile) {
				tileRow = i;
				tileCol = j;
			}

		}

	}

	if ((tile < 0) || (tile > 15)) {
		rowValid = 0;
		colValid = 0;
		tileRow = 20;
		tileCol = 20;
	}

	//check if the tile row is a valid move
	if (emptyRow == 0) {
		//check row is 1
		if (tileRow == 1 || tileRow == 0) {
			rowValid = 1;
		}
		else {
			rowValid = 0;
		}
	}

	else if (emptyRow == 1) {
		//row can be up or down
		if (tileRow == 0 || tileRow == 1 || tileRow == 2) {
			rowValid = 1;
		}
		else {
			rowValid = 0;
		}
	}

	else if (emptyRow == 2) {
		//row can be up or down
		if ((tileRow == 1 || tileRow == 2 || tileRow == 3)) {
			rowValid = 1;
		}
		else {
			rowValid = 0;
		}
	}

	else if (emptyRow = 3) {
		//row must be up
		if ((tileRow == 2) || (tileRow == 3)) {
			rowValid = 1;
		}
		else {
			rowValid = 0;
		}

	}


	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//check if the tile col is a valid move
	if ((emptyCol) == 0) {
		//check col is 1
		if (tileCol == 0 || tileCol == 1) {
			colValid = 1;
		}
		else {
			colValid = 0;
		}
	}

	else if (emptyCol == 1) {
		//col can be up or down or next to it
		if ((tileCol == 0 || tileCol == 1 || tileCol == 2)) {
			colValid = 1;
		}
		else {
			colValid = 0;
		}
	}

	else if (emptyCol == 2) {
		//col can be up or down
		if ((tileCol == 1 || tileCol == 2 || tileCol == 3)) {
			colValid = 1;
		}
		else {
			colValid = 0;
		}
	}
	else if (emptyCol = 3) {
		//col must be up
		if (tileCol == 2 || tileCol == 3) {
			colValid = 1;
		}
		else {
			colValid = 0;
		}

	}

	//4 cases to check if that shit is diagonal cus then it aint gonna work

	//top right
	if ((tileRow == emptyRow - 1) && (tileCol == emptyCol + 1)) {
		rowValid = 0;
	}

	//bottom right
	if ((tileRow == emptyRow + 1) && (tileCol == emptyCol + 1)) {
		rowValid = 0;
	}

	//bottom left
	if ((tileRow == emptyRow + 1) && (tileCol == emptyCol - 1)) {
		rowValid = 0;
	}

	//top left
	if ((tileRow == emptyRow - 1) && (tileCol == emptyCol - 1)) {
		rowValid = 0;
	}
	


	if ((rowValid == 1) && (colValid == 1)) {
		int temp = board[tileRow][tileCol];
		board[emptyRow][emptyCol] = temp;
		board[tileRow][tileCol] = -1;

	}

	else {

	}


}",0
thid924,1696074340,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	//initialize variables
	int emptyRow, emptyCol;
	int tileRow, tileCol;
	int rowValid, colValid;

	//find the position of the empty tile
	FindTile(board, -1, &emptyRow, &emptyCol);

	//find the position of the tile the player wants to move
	for (int i = 0; i < NUM_ROWS; i++) {
		for (int j = 0; j < NUM_COLS; j++) {

			if (board[i][j] == tile) {
				tileRow = i;
				tileCol = j;
			}

		}

	}

	if ((tile < 0) || (tile > 15)) {
		rowValid = 0;
		colValid = 0;
		tileRow = 20;
		tileCol = 20;
	}

	//check if the tile row is a valid move
	if (emptyRow == 0) {
		//check row is 1
		if (tileRow == 1 || tileRow == 0) {
			rowValid = 1;
		}
		else {
			rowValid = 0;
		}
	}

	else if (emptyRow == 1) {
		//row can be up or down
		if (tileRow == 0 || tileRow == 1 || tileRow == 2) {
			rowValid = 1;
		}
		else {
			rowValid = 0;
		}
	}

	else if (emptyRow == 2) {
		//row can be up or down
		if ((tileRow == 1 || tileRow == 2 || tileRow == 3)) {
			rowValid = 1;
		}
		else {
			rowValid = 0;
		}
	}

	else if (emptyRow == 3) {
		//row must be up
		if ((tileRow == 2) || (tileRow == 3)) {
			rowValid = 1;
		}
		else {
			rowValid = 0;
		}

	}


	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//check if the tile col is a valid move
	if ((emptyCol) == 0) {
		//check col is 1
		if (tileCol == 0 || tileCol == 1) {
			colValid = 1;
		}
		else {
			colValid = 0;
		}
	}

	else if (emptyCol == 1) {
		//col can be up or down or next to it
		if ((tileCol == 0 || tileCol == 1 || tileCol == 2)) {
			colValid = 1;
		}
		else {
			colValid = 0;
		}
	}

	else if (emptyCol == 2) {
		//col can be up or down
		if ((tileCol == 1 || tileCol == 2 || tileCol == 3)) {
			colValid = 1;
		}
		else {
			colValid = 0;
		}
	}
	else if (emptyCol == 3) {
		//col must be up
		if (tileCol == 2 || tileCol == 3) {
			colValid = 1;
		}
		else {
			colValid = 0;
		}

	}

	//4 cases to check if that shit is diagonal cus then it aint gonna work

	//top right
	if ((tileRow == emptyRow - 1) && (tileCol == emptyCol + 1)) {
		rowValid = 0;
	}

	//bottom right
	if ((tileRow == emptyRow + 1) && (tileCol == emptyCol + 1)) {
		rowValid = 0;
	}

	//bottom left
	if ((tileRow == emptyRow + 1) && (tileCol == emptyCol - 1)) {
		rowValid = 0;
	}

	//top left
	if ((tileRow == emptyRow - 1) && (tileCol == emptyCol - 1)) {
		rowValid = 0;
	}
	


	if ((rowValid == 1) && (colValid == 1)) {
		int temp = board[tileRow][tileCol];
		board[emptyRow][emptyCol] = temp;
		board[tileRow][tileCol] = -1;

	}

	else {

	}


}",1
thua238,1695884896,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	//find indices of tile to move and empty space
	int tile_row, tile_col, empty_row, empty_col;
	FindTile(board, tile, &tile_row, &tile_col);
	FindTile(board, -1, &empty_row, &empty_col);

	//if tile is adjacent to empty space, move tile
	if ((((tile_row == empty_row+1) || (tile_row == empty_row-1)) && tile_col == empty_col)
	|| (((tile_col == empty_col+1) || (tile_col == empty_col-1)) && tile_row == empty_row)) {
		board[empty_row][empty_col] = tile;
		board[tile_row][tile_col] = -1;
	}
}",1
thut580,1696129149,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowTile, colTile;

	FindTile(board, tile, &rowTile, &colTile);

	if (board[rowTile + 1][colTile] == -1) {
		board[rowTile + 1][colTile] = tile;
		board[rowTile][colTile] = -1;
	}
	if (board[rowTile - 1][colTile] == -1) {
		board[rowTile - 1][colTile] = tile;
		board[rowTile][colTile] = -1;
	}

	if (board[rowTile][colTile + 1] == -1) {
		if (colTile < (NUM_COLS - 1)) {
			board[rowTile][colTile + 1] = tile;
			board[rowTile][colTile] = -1;
		}
	}
	if (board[rowTile][colTile - 1] == -1) {
		if (colTile > 0) {
			board[rowTile][colTile - 1] = tile;
			board[rowTile][colTile] = -1;
		}
	}
}",1
tkan918,1695871171,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	//Find the row and column of the tile to be moved
	int rowPos, colPos;
	FindTile(board, tile, &rowPos, &colPos);

	//Find the row and column of the empty tile
	int EmptyRow, EmptyCol;
	FindTile(board, -1, &EmptyRow, &EmptyCol);

	/*Check if the empty tile and the tile to be moved are adjacent
	If they are adjacent, swap the empty tile position and the tile position to be moved
	If not then return*/

	//When the empty tile is in the center
	if ((EmptyRow == 1 || EmptyRow == 2) && (EmptyCol == 1|| EmptyCol == 2) && (
	 	(rowPos+1 == EmptyRow || rowPos-1 == EmptyRow) && colPos == EmptyCol || 
		(colPos+1 == EmptyCol || colPos-1 == EmptyCol) && rowPos == EmptyRow)) {
		board[EmptyRow][EmptyCol] = tile;
		board[rowPos][colPos] = -1;
		
	//When the empty tile is in the corners
	} else if (EmptyRow == 0 && EmptyCol == 0 && rowPos == 1 && colPos == 0 || rowPos == 0 && colPos == 1){
		board[EmptyRow][EmptyCol] = tile;
		board[rowPos][colPos] = -1;

	} else if (EmptyRow == 3 && EmptyCol == 3 && rowPos == 3 && colPos == 2 || rowPos == 2 && colPos == 3){
		board[EmptyRow][EmptyCol] = tile;
		board[rowPos][colPos] = -1;	

	} else if (EmptyRow == 0 && EmptyCol == 3 && rowPos == 0 && colPos == 2 || rowPos == 1 && colPos == 3){
		board[EmptyRow][EmptyCol] = tile;
		board[rowPos][colPos] = -1;	

	} else if (EmptyRow == 3 && EmptyCol == 0 && rowPos == 2 && colPos == 0 || rowPos == 3 && colPos == 1){
		board[EmptyRow][EmptyCol] = tile;
		board[rowPos][colPos] = -1;

	//When the empty tile is on the edges but not the corners
	} else if (EmptyRow == 0 && (EmptyCol == 1 || EmptyCol == 2) && 
	(EmptyRow == rowPos && (colPos+1 == EmptyCol || colPos-1 == EmptyCol)) || EmptyCol == colPos && rowPos-1 == EmptyRow){
		board[EmptyRow][EmptyCol] = tile;
		board[rowPos][colPos] = -1;

	} else if (EmptyRow == 3 && (EmptyCol == 1 || EmptyCol == 2) && 
	(EmptyRow == rowPos && (colPos+1 == EmptyCol || colPos-1 == EmptyCol)) || EmptyCol == colPos && rowPos+1 == EmptyRow){
		board[EmptyRow][EmptyCol] = tile;
		board[rowPos][colPos] = -1;

	} else if (EmptyCol == 0 && (EmptyRow == 1 || EmptyRow == 2) &&
	(EmptyCol == colPos && (rowPos+1 == EmptyRow || rowPos-1 == EmptyRow )) || EmptyRow == rowPos && colPos-1 == EmptyCol){
		board[EmptyRow][EmptyCol] = tile;
		board[rowPos][colPos] = -1;

	} else if (EmptyCol == 3 && (EmptyRow == 1 || EmptyRow == 2) && 
	(EmptyCol == colPos && (rowPos+1 == EmptyRow || rowPos-1 == EmptyRow )) || EmptyRow == rowPos && colPos+1 == EmptyCol){
		board[EmptyRow][EmptyCol] = tile;
		board[rowPos][colPos] = -1;		

	} else {return;}
}",0
tkan918,1695872797,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	//Find the row and column of the tile to be moved
	int rowPos, colPos;
	FindTile(board, tile, &rowPos, &colPos);

	//Find the row and column of the empty tile
	int EmptyRow, EmptyCol;
	FindTile(board, -1, &EmptyRow, &EmptyCol);

	/*Check if the empty tile and the tile to be moved are adjacent
	If they are adjacent, swap the empty tile position and the tile position to be moved
	If not then return*/

	//When the empty tile is in the center
	if (((EmptyRow == 1 || EmptyRow == 2) && (EmptyCol == 1 || EmptyCol == 2)) &&
	(((rowPos+1 == EmptyRow || rowPos-1 == EmptyRow) && (colPos == EmptyCol)) ||
	 ((colPos+1 == EmptyCol || colPos-1 == EmptyCol) && (rowPos == EmptyRow)))) {

		board[EmptyRow][EmptyCol] = tile;
		board[rowPos][colPos] = -1;
		
	//When the empty tile is in the corners
	} else if ((EmptyRow == 0 && EmptyCol == 0) && 
	((rowPos == 1 && colPos == 0) || (rowPos == 0 && colPos == 1))){

		board[EmptyRow][EmptyCol] = tile;
		board[rowPos][colPos] = -1;

	} else if ((EmptyRow == 3 && EmptyCol == 3) && 
	((rowPos == 3 && colPos == 2) || (rowPos == 2 && colPos == 3))){

		board[EmptyRow][EmptyCol] = tile;
		board[rowPos][colPos] = -1;	

	} else if ((EmptyRow == 0 && EmptyCol == 3) && 
	((rowPos == 0 && colPos == 2) || (rowPos == 1 && colPos == 3))) {

		board[EmptyRow][EmptyCol] = tile;
		board[rowPos][colPos] = -1;	

	} else if ((EmptyRow == 3 && EmptyCol == 0) && 
	((rowPos == 2 && colPos == 0) || (rowPos == 3 && colPos == 1))){

		board[EmptyRow][EmptyCol] = tile;
		board[rowPos][colPos] = -1;

	//When the empty tile is on the edges but not the corners
	} else if (((EmptyRow == 0) && (EmptyCol == 1 || EmptyCol == 2)) && 
	(((EmptyRow == rowPos) && (colPos+1 == EmptyCol || colPos-1 == EmptyCol)) || 
	(EmptyCol == colPos && rowPos-1 == EmptyRow))){
		
		board[EmptyRow][EmptyCol] = tile;
		board[rowPos][colPos] = -1;

	} else if (((EmptyRow == 3) && (EmptyCol == 1 || EmptyCol == 2)) && 
	(((EmptyRow == rowPos) && (colPos+1 == EmptyCol || colPos-1 == EmptyCol)) || 
	(EmptyCol == colPos && rowPos+1 == EmptyRow))){

		board[EmptyRow][EmptyCol] = tile;
		board[rowPos][colPos] = -1;

	} else if (((EmptyCol == 0) && (EmptyRow == 1 || EmptyRow == 2)) &&
	(((EmptyCol == colPos) && (rowPos+1 == EmptyRow || rowPos-1 == EmptyRow)) || 
	(EmptyRow == rowPos && colPos-1 == EmptyCol))){

		board[EmptyRow][EmptyCol] = tile;
		board[rowPos][colPos] = -1;

	} else if (((EmptyCol == 3) && (EmptyRow == 1 || EmptyRow == 2)) && 
	(((EmptyCol == colPos) && (rowPos+1 == EmptyRow || rowPos-1 == EmptyRow)) || 
	(EmptyRow == rowPos && colPos+1 == EmptyCol))){

		board[EmptyRow][EmptyCol] = tile;
		board[rowPos][colPos] = -1;		

	} else {return;}
}",1
tlal352,1696230846,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int emptyRowPos, emptyColPos;
    int moveRowPos, moveColPos;
    
    FindTile(board, -1, &emptyRowPos, &emptyColPos);
    FindTile(board, tile, &moveRowPos, &moveColPos);
    
   if ((moveRowPos == emptyRowPos && (moveColPos == emptyColPos + 1 || moveColPos == emptyColPos - 1)) ||
      (moveColPos == emptyColPos && (moveRowPos == emptyRowPos + 1 || moveRowPos == emptyRowPos - 1)))   {
            board[emptyRowPos][emptyColPos] = tile;
            board[moveRowPos][moveColPos] = -1;
      }
}",1
tlin438,1696037252,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tilerow, tilecol, emptyrow, emptycol;

	FindTile(board, tile, &tilerow, &tilecol);
	FindTile(board, -1, &emptyrow, &emptycol);

	if ((tilerow == emptyrow && (tilecol == emptycol - 1 || tilecol == emptycol + 1)) ||
		(tilecol == emptycol && (tilerow == emptyrow - 1 || tilerow == emptyrow + 1))) {

		board[emptyrow][emptycol] = tile;
		board[tilerow][tilecol] = -1;
		return 1;
	}
	else {
		return 0;
	}
}",0
tlin438,1696037830,2,"int MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tilerow, tilecol, emptyrow, emptycol;

	FindTile(board, tile, &tilerow, &tilecol);
	FindTile(board, -1, &emptyrow, &emptycol);

	if ((tilerow == emptyrow && (tilecol == emptycol - 1 || tilecol == emptycol + 1)) ||
		(tilecol == emptycol && (tilerow == emptyrow - 1 || tilerow == emptyrow + 1))) {

		board[emptyrow][emptycol] = tile;
		board[tilerow][tilecol] = -1;
		return 1;
	}
	else {
		return 0;
	}
}",1
tlu253,1695805630,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int empRow, empCol;
	int movRow, movCol;
	int isAdj = 0;

	// find location of empty tile
	FindTile(board, -1, &empRow, &empCol);

	// find locating of tile user wants to move
	FindTile(board, tile, &movRow, &movCol);

	// if empty tile at bottom row
	// make sure the moving tile is next to empty tile
	if (empRow == 3) {

		// bottom left corner
		if (empCol == 0) { 
			if ((movRow == empRow) && (movCol == 1)) { 
				isAdj = 1;
			} else if ((movCol == empCol) && (movRow == 2)) {
				isAdj = 1;
			}

		// bottom right corner
		} else if (empCol == 3) { 
			if ((movRow == 3) && (movCol == 2)) {
				isAdj = 1;
			} else if ((movRow == 2) && (movCol == 3)) {
				isAdj = 1;
			}

		// middle 2 tiles of bottom row
		} else if ((movRow == empRow) && ((movCol == (empCol+1)) || (movCol == (empCol-1)))) { 
			isAdj = 1;
		} else if ((movRow == (empRow-1)) && (movCol == empCol)) {
			isAdj = 1;
		}

	// if empty tile is at top row
	} else if (empRow == 0) { 

		// top left corner
		if (empCol == 0) { 
			if ((empRow == movRow) && (movCol == (empCol+1))) {
				isAdj = 1;
			} else if ((movRow == (empRow+1)) && (movCol == empCol)) {
				isAdj = 1;
			}

		// top right corner
		} else if (empCol == 3) { 
			if ((movRow == empRow) && (movCol == (empCol-1))) { 
				isAdj = 1;
			} else if ((movRow == (empRow+1)) && (movCol == empCol)) {
				isAdj = 1;
			}

		// middle 2 tiles of top row
		} else if ((movRow == empRow) && ((movCol == (empCol+1)) || (movCol == (empCol-1)))) {
			isAdj = 1;
		} else if ((movRow == (empRow+1)) && ((movCol == empCol))) {
			isAdj = 1;
		}

	// Tile in left column (excl corners)
	} else if (empCol == 0) {
		if ((movCol == empCol) && ((movRow == (empRow+1)) || (movRow == (empRow-1)))) {
			isAdj = 1;
		} else if ((movRow == empRow) && (movCol == 1)) {
			isAdj = 1;
		}

	
	// Tile in right column (excl corners)
	} else if (empCol == 3) {
		if ((movCol == empCol) && ((movRow == (empRow+1)) || (movRow == (empRow-1)))) {
			isAdj = 1;
		} else if ((movRow == empRow) && (movCol == 2)) {
			isAdj = 1;		
		}

	// Middle 4 tiles
	} else if ((movRow == empRow) && ((movCol == (empCol+1)) || (movCol == (empCol-1)))) {
		isAdj = 1;
	} else if ((movCol == empCol) && ((movRow == (empRow+1)) || (movRow == (empRow-1)))) {
		isAdj = 1;

	} else return;

	if (isAdj == 1) {
		board[empRow][empCol] = tile;
		board[movRow][movCol] = -1;
	}


}",1
tluu816,1695847509,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, row2, col2;
	// finds the position of the empty tile
	FindTile(board, -1, &row, &col);
	// finds the position of the desired tile it supposed to swap with
	FindTile(board, tile, &row2, &col2);

	// tests if tiles are adjacent to eachother
	if ((row - row2 == 1) || ((row - row2) == -1)) {
		if ((col - col2) == 0) {
			board[row][col] = tile;
			board[row2][col2] = -1;
		}
	}

	else if ((col - col2 == 1) || ((col - col2) == -1)) {
		if ((row - row2) == 0) {
			board[row][col] = tile;
			board[row2][col2] = -1;

		}
	}


}",1
tmcl219,1696115045,1,"/*This function swaps the position of an inputed tile with the position of the
blank square, but only if the two tiles are adjacent to eachother.*/
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    int row, col;
    /*Call the FindTile function to find the location of the blank tile.*/
    FindTile(board, -1, &row, &col);
    /*Check if the blank tile is adjacent with the input tile (up, down, left, 
    right respectively), then swap it with the blank tile if true.*/
     if (row > 0 && board[row - 1][col] == tile) {
        board[row][col] = tile;
        board[row - 1][col] = -1;
            
	} else if (row < NUM_ROWS - 1 && board[row + 1][col] == tile) {
	    board[row][col] = tile;
	    board[row + 1][col] = -1;
	            
	} else if (col > 0 && board[row][col - 1] == tile) {
	    board[row][col] = tile;
	    board[row][col - 1] = -1;
	            
	} else if (col < NUM_COLS - 1 && board[row][col + 1] == tile) {
	    board[row][col] = tile;
	    board[row][col + 1] = -1;

	}
}
",1
tmen190,1695629605,1,"/* Move tile to empty slot if possible */
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int tileRow, tileCol, emptyRow, emptyCol;
	FindTile(board, tile, &tileRow, &tileCol);
	FindTile(board, -1, &emptyRow, &emptyCol);

	if ((tileRow == emptyRow && (tileCol + 1 == emptyCol || tileCol - 1 == emptyCol)) || ((tileCol == emptyCol && (tileRow + 1 == emptyRow || tileRow - 1 == emptyRow))))
	{
		board[emptyRow][emptyCol] = board[tileRow][tileCol];
		board[tileRow][tileCol] = -1;
	}

}",1
tmir110,1696225415,1,"#include <stdio.h>
#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row;
    int col;

    
    FindTile(board, tile, &row, &col);
    
    
    if (row > 0) {
        if (board[row - 1][col] == - 1 || board[row + 1][col] == -1)
        {
            int spaceRow;
            int spaceCol;
            
            FindTile(board, -1, &spaceRow, &spaceCol);
            
            board[spaceRow][spaceCol] == tile;
            
            board[row][col] == -1;
            
        }

    if (col > 0) {
        if (board[row][col - 1] == -1 || board[row][col + 1] == -1) {
                    {
            int spaceRow;
            int spaceCol;
            
            FindTile(board, -1, &spaceRow, &spaceCol);
            
            board[spaceRow][spaceCol] == tile;
            
            board[row][col] == -1;
            
        }
        }
    }
    }
    
}",0
tmir110,1696225483,2,"#include <stdio.h>
#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row;
    int col;

    
    FindTile(board, tile, &row, &col);
    
    
    if (row > 0) {
        if (board[row - 1][col] == - 1 || board[row + 1][col] == -1)
        {
            int spaceRow;
            int spaceCol;
            
            FindTile(board, -1, &spaceRow, &spaceCol);
            
            board[spaceRow][spaceCol] == tile;
            
            board[row][col] == -1;
            
        }

    if (col > 0) {
        if (board[row][col - 1] == -1 || board[row][col + 1] == -1) {
                    {
            int spaceRow;
            int spaceCol;
            
            FindTile(board, -1, &spaceRow, &spaceCol);
            
            board[spaceRow][spaceCol] == &tile;
            
            board[row][col] == &-1;
            
        }
        }
    }
    }
    
}",0
tmir110,1696226090,3,"#include <stdio.h>
#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row;
    int col;

    
    FindTile(board, tile, &row, &col);
    
    
    if (row > 0) {
        if (board[row - 1][col] == - 1 || board[row + 1][col] == -1)
        {
            board[row - 1][col] = tile;
            board[row][col] = -1;
            
        }
        if (board[row + 1][col] == -1)
        {
            board[row + 1][col] = tile;
            board[row][col] = -1;
        }
    }

    if (col > 0) {
        if (board[row][col - 1] == -1 || board[row][col + 1] == -1)
        {
            board[row][col - 1] = tile;
            board[row][col] = -1;
            
        }
        if (board[row][col + 1] == -1)
        {
            board[row][col + 1] = tile;
            board[row][col] = -1;
        }
    }
    
}
",0
tmir110,1696226516,4,"#include <stdio.h>
#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row;
    int col;

    
    FindTile(board, tile, &row, &col);
    
    
    if (row > 0 && col > 0) {
        if (board[row - 1][col] == - 1)
        {
            board[row - 1][col] = tile;
            board[row][col] = -1;
            return;
        }
        if (board[row + 1][col] == -1)
        {
            board[row + 1][col] = tile;
            board[row][col] = -1;
            return;
        }
        
        if (board[row][col - 1] == -1 ||)
        {
            board[row][col - 1] = tile;
            board[row][col] = -1;
            return;
            
        }
        if (board[row][col + 1] == -1)
        {
            board[row][col + 1] = tile;
            board[row][col] = -1;
            return;
        }
    
}
",0
tmir110,1696226525,5,"#include <stdio.h>
#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row;
    int col;

    
    FindTile(board, tile, &row, &col);
    
    
    if (row > 0 && col > 0) {
        if (board[row - 1][col] == - 1)
        {
            board[row - 1][col] = tile;
            board[row][col] = -1;
            return;
        }
        if (board[row + 1][col] == -1)
        {
            board[row + 1][col] = tile;
            board[row][col] = -1;
            return;
        }
        
        if (board[row][col - 1] == -1)
        {
            board[row][col - 1] = tile;
            board[row][col] = -1;
            return;
            
        }
        if (board[row][col + 1] == -1)
        {
            board[row][col + 1] = tile;
            board[row][col] = -1;
            return;
        }
    
}
",0
tmir110,1696226566,6,"#include <stdio.h>
#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row;
    int col;

    
    FindTile(board, tile, &row, &col);
    
    
    if (row > 0 && col > 0) {
        if (board[row - 1][col] == - 1)
        {
            board[row - 1][col] = tile;
            board[row][col] = -1;
            return;
        }
        if (board[row + 1][col] == -1)
        {
            board[row + 1][col] = tile;
            board[row][col] = -1;
            return;
        }
        
        if (board[row][col - 1] == -1)
        {
            board[row][col - 1] = tile;
            board[row][col] = -1;
            return;
            
        }
        if (board[row][col + 1] == -1)
        {
            board[row][col + 1] = tile;
            board[row][col] = -1;
            return;
        }
    }
}
    

",0
tmir110,1696227008,7,"#include <stdio.h>
#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row;
    int col;

    
    FindTile(board, tile, &row, &col);
    
    
        if (row > 0 && board[row - 1][col] == - 1)
        {
            board[row - 1][col] = tile;
            board[row][col] = -1;
            return;
        }
        if (row < NUM_ROWS - 1 && board[row + 1][col] == -1)
        {
            board[row + 1][col] = tile;
            board[row][col] = -1;
            return;
        }
        
        if (col > 0 && board[row][col - 1] == -1)
        {
            board[row][col - 1] = tile;
            board[row][col] = -1;
            return;
            
        }
        if (col < NUM_COLS - 1 && board[row][col + 1] == -1)
        {
            board[row][col + 1] = tile;
            board[row][col] = -1;
            return;
        }
    }
}
    

",0
tmir110,1696227016,8,"#include <stdio.h>
#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row;
    int col;

    
    FindTile(board, tile, &row, &col);
    
    
        if (row > 0 && board[row - 1][col] == - 1)
        {
            board[row - 1][col] = tile;
            board[row][col] = -1;
            return;
        }
        if (row < NUM_ROWS - 1 && board[row + 1][col] == -1)
        {
            board[row + 1][col] = tile;
            board[row][col] = -1;
            return;
        }
        
        if (col > 0 && board[row][col - 1] == -1)
        {
            board[row][col - 1] = tile;
            board[row][col] = -1;
            return;
            
        }
        if (col < NUM_COLS - 1 && board[row][col + 1] == -1)
        {
            board[row][col + 1] = tile;
            board[row][col] = -1;
            return;
        }
    }
    

",1
tmun974,1695975952,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{ int EmptyRow, EmptyCol, TileRow, TileCol, i, j;

	for (int i =0; i<NUM_ROWS; i++){
		for (int j=0; j< NUM_COLS; j++)
		if (board[i][j]==-1){
			EmptyRow=i;
			EmptyCol=j;
		}
		if (board[i][j]==tile){
			TileRow=i;
			TileCol=j;
		}
		}
	
if (((abs(TileRow - EmptyRow)== 1 && TileCol == EmptyCol)||
   (abs(TileCol - EmptyCol) == 1 && TileRow == EmptyRow)){

    int x= board[TileRow][TileCol];
	board[TileRow][TileCol]= board[EmptyRow][EmptyCol];
	board[EmptyRow][EmptyCol]=x;
	return;
}
return;
}
",0
tmun974,1695976200,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{ int EmptyRow, EmptyCol, TileRow, TileCol, i, j;

	for (int i =0; i<NUM_ROWS; i++){
		for (int j=0; j< NUM_COLS; j++)
		if (board[i][j]==-1){
			EmptyRow=i;
			EmptyCol=j;
		}
		if (board[i][j]==tile){
			TileRow=i;
			TileCol=j;
		}
		}
	
if ((abs(TileRow - EmptyRow)== 1 && TileCol == EmptyCol)||
   (abs(TileCol - EmptyCol) == 1 && TileRow == EmptyRow)) {

    int x= board[TileRow][TileCol];
	board[TileRow][TileCol]= board[EmptyRow][EmptyCol];
	board[EmptyRow][EmptyCol]=x;
	return;
}
return;
}
",0
tmun974,1695976260,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{ int EmptyRow, EmptyCol, TileRow, TileCol;

	for (int i =0; i<NUM_ROWS; i++){
		for (int j=0; j< NUM_COLS; j++)
		if (board[i][j]==-1){
			EmptyRow=i;
			EmptyCol=j;
		}
		if (board[i][j]==tile){
			TileRow=i;
			TileCol=j;
		}
		}
	
if ((abs(TileRow - EmptyRow)== 1 && TileCol == EmptyCol)||
   (abs(TileCol - EmptyCol) == 1 && TileRow == EmptyRow)) {

    int x= board[TileRow][TileCol];
	board[TileRow][TileCol]= board[EmptyRow][EmptyCol];
	board[EmptyRow][EmptyCol]=x;
	return;
}
return;
}
",0
tmun974,1695976279,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{ int EmptyRow, EmptyCol, TileRow, TileCol;
   int j;
	for (int i =0; i<NUM_ROWS; i++){
		for (int j=0; j< NUM_COLS; j++)
		if (board[i][j]==-1){
			EmptyRow=i;
			EmptyCol=j;
		}
		if (board[i][j]==tile){
			TileRow=i;
			TileCol=j;
		}
		}
	
if ((abs(TileRow - EmptyRow)== 1 && TileCol == EmptyCol)||
   (abs(TileCol - EmptyCol) == 1 && TileRow == EmptyRow)) {

    int x= board[TileRow][TileCol];
	board[TileRow][TileCol]= board[EmptyRow][EmptyCol];
	board[EmptyRow][EmptyCol]=x;
	return;
}
return;
}
",0
tpan328,1695784228,1,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    FindTile(board, tile, &row, &col);

    if (board[row - 1][col] == -1) {
        board[row][col] = -1;
        board[row - 1][col] = tile;
    } else if (board[row][col + 1] == -1) {
        board[row][col] = -1;
        board[row][col + 1] = tile;
    } else if (board[row + 1][col] == -1) {
        board[row][col] = -1;
        board[row + 1][col] = tile;
    } else if (board[row][col - 1] == -1) {
        board[row][col] = -1;
        board[row][col - 1] = tile;
    } else ;
}",0
tpan328,1695784297,2,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

int row, col, tile;

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    FindTile(board, tile, &row, &col);

    if (board[row - 1][col] == -1) {
        board[row][col] = -1;
        board[row - 1][col] = tile;
    } else if (board[row][col + 1] == -1) {
        board[row][col] = -1;
        board[row][col + 1] = tile;
    } else if (board[row + 1][col] == -1) {
        board[row][col] = -1;
        board[row + 1][col] = tile;
    } else if (board[row][col - 1] == -1) {
        board[row][col] = -1;
        board[row][col - 1] = tile;
    } else ;
}",0
tpan328,1695807754,3,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

int row, col, tile;

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    FindTile(board, tile, &row, &col);

    if (row > 0) { // checking above
        if (board[row - 1][col] == -1) {
            board[row][col] = -1;
            board[row - 1][col] = tile;
        }
    } 
    if (col < 3) { // checking right
        if (board[row][col + 1] == -1) {
            board[row][col] = -1;
            board[row][col + 1] = tile;
        }
    } 
    if (row < 3) { // checking below
        if (board[row + 1][col] == -1) {
            board[row][col] = -1;
            board[row + 1][col] = tile;
        }
    } 
    if (col > 0) { // checking left
        if (board[row][col - 1] == -1) {
            board[row][col] = -1;
            board[row][col - 1] = tile;
        }
    }
}",1
tpat456,1695693203,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
  int row, col;
  FindTile(board, tile, &row, &col);
  
   if ((board[row + 1][col] == -1 ) && ((row + 1) < 4)) {
     board[row + 1][col] = tile;
     board[row][col] = -1;
   }
  if ((board[row - 1][col] == -1 ) && ((row - 1) > -1)) {
     board[row - 1][col] = tile;
     board[row][col] = -1;
   }
   if ((board[row][col + 1] == -1 ) && ((col + 1) < 4)) {
     board[row][col + 1] = tile;
     board[row][col] = -1;
   }
   if ((board[row][col - 1] == -1 ) && ((col - 1) > -1)) {
     board[row][col - 1] = tile;
     board[row][col] = -1;
   }

}",1
tpil529,1695796050,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int tile_row, tile_col,row, col;
    FindTile(board, -1, &row, &col);
    FindTile(board, tile, &tile_row, &tile_col);

    board[row][col] = tile;
    board[tile_row][tile_col] = -1;

    return;
}",0
tpil529,1695804955,2,"void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos)
{
    for (int i = 0; i < NUM_ROWS; i++){
        for (int j = 0; j < NUM_COLS; j++){

            if (board[i][j] == tile){

            *rowPos = i;
            *colPos = j;

            }
        }
    }

return;

}

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int tile_row, tile_col,row, col;
    FindTile(board, -1, &row, &col);
    FindTile(board, tile, &tile_row, &tile_col);

if (tile_row == 1 || tile_row == 2) {

        if (tile_col == 1 || tile_col == 2) {

            if ((tile_row == row && (tile_col == col + 1 || tile_col == col -1)) || (tile_col == col && (tile_row == row - 1 || tile_row == row + 1))){

                board[row][col] = tile;
                board[tile_row][tile_col] = -1;

            }
        }

        else if (tile_col ==  0){

            if ((tile_row == row && tile_col == col + 1) || (tile_col == col && (tile_row == row - 1 || tile_row == row + 1))){

                board[row][col] = tile;
                board[tile_row][tile_col] = -1;

            }
        }

        else if (tile_col == 3) {

            if ((tile_row == row && tile_col == col - 1) || (tile_col == col && (tile_row == row - 1 || tile_row == row + 1))){

                board[row][col] = tile;
                board[tile_row][tile_col] = -1;

            }


        }

}

else if (tile_row == 0) {

        if (tile_col == 1 || tile_col == 2) {

            if ((tile_row == row && (tile_col == col + 1 || tile_col == col -1)) || (tile_col == col && tile_row == row - 1)){

            board[row][col] = tile;
            board[tile_row][tile_col] = -1;

        }
        }

        else if (tile_col == 0) {

            if ((tile_row == row && tile_col == col + 1) || (tile_col == col && tile_row == row + 1)){

            board[row][col] = tile;
            board[tile_row][tile_col] = -1;

            }
        }

        else if (tile_col == 3) {

            if ((tile_row == row && tile_col == col -1) || (tile_col == col &&tile_row == row + 1)){

            board[row][col] = tile;
            board[tile_row][tile_col] = -1;

            }
        }

}
else if (tile_row == 3) {

        if (tile_col == 1 || tile_col == 2) {

            if ((tile_row == row && (tile_col == col + 1 || tile_col == col -1)) || (tile_col == col && tile_row == row - 1)){

            board[row][col] = tile;
            board[tile_row][tile_col] = -1;

        }
        }

        else if (tile_col == 0) {

            if ((tile_row == row && tile_col == col + 1) || (tile_col == col && tile_row == row - 1)){

            board[row][col] = tile;
            board[tile_row][tile_col] = -1;

            }
        }

        else if (tile_col == 3) {

            if ((tile_row == row && tile_col == col -1) || (tile_col == col && tile_row == row - 1)){

            board[row][col] = tile;
            board[tile_row][tile_col] = -1;

            }
        }

}

    return;
}",0
tpil529,1695804998,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int tile_row, tile_col,row, col;
    FindTile(board, -1, &row, &col);
    FindTile(board, tile, &tile_row, &tile_col);

if (tile_row == 1 || tile_row == 2) {

        if (tile_col == 1 || tile_col == 2) {

            if ((tile_row == row && (tile_col == col + 1 || tile_col == col -1)) || (tile_col == col && (tile_row == row - 1 || tile_row == row + 1))){

                board[row][col] = tile;
                board[tile_row][tile_col] = -1;

            }
        }

        else if (tile_col ==  0){

            if ((tile_row == row && tile_col == col + 1) || (tile_col == col && (tile_row == row - 1 || tile_row == row + 1))){

                board[row][col] = tile;
                board[tile_row][tile_col] = -1;

            }
        }

        else if (tile_col == 3) {

            if ((tile_row == row && tile_col == col - 1) || (tile_col == col && (tile_row == row - 1 || tile_row == row + 1))){

                board[row][col] = tile;
                board[tile_row][tile_col] = -1;

            }


        }

}

else if (tile_row == 0) {

        if (tile_col == 1 || tile_col == 2) {

            if ((tile_row == row && (tile_col == col + 1 || tile_col == col -1)) || (tile_col == col && tile_row == row - 1)){

            board[row][col] = tile;
            board[tile_row][tile_col] = -1;

        }
        }

        else if (tile_col == 0) {

            if ((tile_row == row && tile_col == col + 1) || (tile_col == col && tile_row == row + 1)){

            board[row][col] = tile;
            board[tile_row][tile_col] = -1;

            }
        }

        else if (tile_col == 3) {

            if ((tile_row == row && tile_col == col -1) || (tile_col == col &&tile_row == row + 1)){

            board[row][col] = tile;
            board[tile_row][tile_col] = -1;

            }
        }

}
else if (tile_row == 3) {

        if (tile_col == 1 || tile_col == 2) {

            if ((tile_row == row && (tile_col == col + 1 || tile_col == col -1)) || (tile_col == col && tile_row == row - 1)){

            board[row][col] = tile;
            board[tile_row][tile_col] = -1;

        }
        }

        else if (tile_col == 0) {

            if ((tile_row == row && tile_col == col + 1) || (tile_col == col && tile_row == row - 1)){

            board[row][col] = tile;
            board[tile_row][tile_col] = -1;

            }
        }

        else if (tile_col == 3) {

            if ((tile_row == row && tile_col == col -1) || (tile_col == col && tile_row == row - 1)){

            board[row][col] = tile;
            board[tile_row][tile_col] = -1;

            }
        }

}

    return;
}",0
tpil529,1695805624,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int tile_row, tile_col,row, col;
    FindTile(board, -1, &row, &col);
    FindTile(board, tile, &tile_row, &tile_col);


    if (tile_row == row) {

        if (tile_col == col + 1 || tile_col == col - 1) {

        board[row][col] = tile;
        board[tile_row][tile_col] = -1;

        }
    }

    if (tile_col == col) {

        if (tile_row == row + 1 || tile_row == row - 1) {

            board[row][col] = tile;
            board[tile_row][tile_col] = -1;
        }

    }

return;
}",1
tpra228,1696236452,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int emptyRow, emptyCol, tileRow, tileCol;

	FindTile(board, -1, &emptyRow, &emptyCol);
	FindTile(board, tile, &tileRow, &tileCol);

	if (((emptyRow - tileRow == 1 || tileRow - emptyRow == 1) && emptyCol == tileCol) ||
		((emptyCol - tileCol == 1 || tileCol - emptyCol == 1) && emptyRow == tileRow)) {
		board[emptyRow][emptyCol] = tile;
		board[tileRow][tileCol] = -1;
	}
}",1
tpur744,1695795659,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int emptyRow;
	int emptyCol;
	int valueRow;
	int valueCol;

	FindTile(board, -1, &emptyRow, &emptyCol);
	FindTile(board, tile, &valueRow, &valueCol);

	if ((emptyRow == valueRow && (valueCol == emptyCol + 1 || valueCol == emptyCol - 1)) || (emptyCol == valueCol && (valueRow == emptyRow + 1 || valueRow == emptyRow - 1))){
		int emptyPosition = board[emptyRow][emptyCol];
		board[emptyRow][emptyCol] = board[valueRow][valueCol];
		board[valueRow][valueCol] = emptyPosition;
	
	}
	


}",1
tqhu735,1695629537,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowTile, colTile, rowBlank, colBlank;
	FindTile(board, tile, &rowTile, &colTile);
	FindTile(board, -1, &rowBlank, &colBlank);

	if (abs(rowTile - rowBlank) == 1 && colTile == colBlank) {
		board[rowBlank][colBlank] = tile;
		board[rowTile][colTile] = -1;
	}
	else if (abs(colTile - colBlank) == 1 && rowTile == rowBlank) {
		board[rowBlank][colBlank] = tile;
		board[rowTile][colTile] = -1;
	}
}",1
tron042,1695715928,1,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
int emptyRow, emptyCol;
int Rowtile, Coltile;
int emptytile = -1; 

FindTile(board, emptytile, &emptyRow, &emptyCol);
FindTile(board, tile, &Rowtile, &Coltile);

if ((Rowtile == emptyRow && (Coltile == emptyCol + 1 || Coltile == emptyCol - 1)) ||
    (Coltile == emptyCol && (Rowtile == emptyRow + 1 || Rowtile == emptyRow - 1))) {

    board[emptyRow][emptyCol] = tile;
    board[Rowtile][Coltile] = emptytile;
    }
}",1
tron042,1695716443,2,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
int emptyRow, emptyCol;
int Rowtile, Coltile;
int emptytile = -1; 

FindTile(board, emptytile, &emptyRow, &emptyCol);
FindTile(board, tile, &Rowtile, &Coltile);

int tile_Cols = (Coltile == emptyCol + 1 || Coltile == emptyCol - 1); 
int tile_Rows = (Rowtile == emptyRow + 1 || Rowtile == emptyRow - 1)

if ((Rowtile == emptyRow && tile_Cols) ||
    (Coltile == emptyCol && tile_Rows)) {
        board[emptyRow][emptyCol] = tile;
        board[Rowtile][Coltile] = emptytile;
    }
}",0
tron042,1695716544,3,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
int emptyRow, emptyCol;
int Rowtile, Coltile;
int emptytile = -1; 

FindTile(board, emptytile, &emptyRow, &emptyCol);
FindTile(board, tile, &Rowtile, &Coltile);

int tile_Cols = (Coltile == emptyCol + 1 || Coltile == emptyCol - 1); 
int tile_Rows = (Rowtile == emptyRow + 1 || Rowtile == emptyRow - 1);

if ((Rowtile == emptyRow && tile_Cols) ||
    (Coltile == emptyCol && tile_Rows)) {
        board[emptyRow][emptyCol] = tile;
        board[Rowtile][Coltile] = emptytile;
    }
}",1
tsan986,1695958199,1,"#define NUM_ROWS 4
#define NUM_COLS 4
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row,col;
    
    row = 0;
    col = 0;
    int left,right,above,below;
    FindTile(board, tile, &row, &col);
    //printf(""found tile %d at %d, %d \n"", tile, row, col);
    
    left,right,above,below = 0;
    if (col < 3) {
        int A = board[row][col+1];
        //printf(""The tile to the right is %d \n"", A);
        if (A == -1){
            int temp = board[row][col];
            board[row][col] = board[row][col+1];
            board[row][col+1] = temp;
        }
    }
    
    if (col > 0) {
        int A = board[row][col-1];
        //printf(""The tile to the left is is %d \n"", A);
        if (A == -1){
            int temp = board[row][col];
            board[row][col] = board[row][col-1];
            board[row][col-1] = temp;
        }
    }
    
     if (row > 0) {
        int A = board[row-1][col];
        //printf(""The tile above is %d \n"", A);
        if (A == -1){
            int temp = board[row][col];
            board[row][col] = board[row-1][col];
            board[row-1][col] = temp;
        }
    }",0
tsan986,1695958662,2,"#define NUM_ROWS 4
#define NUM_COLS 4
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row,col;
    
    row = 0;
    col = 0;
    FindTile(board, tile, &row, &col);
    //printf(""found tile %d at %d, %d \n"", tile, row, col);
    
    if (col < 3) {
        int A = board[row][col+1];
        //printf(""The tile to the right is %d \n"", A);
        if (A == -1){
            int temp = board[row][col];
            board[row][col] = board[row][col+1];
            board[row][col+1] = temp;
        }
    }
    
    if (col > 0) {
        int A = board[row][col-1];
        //printf(""The tile to the left is is %d \n"", A);
        if (A == -1){
            int temp = board[row][col];
            board[row][col] = board[row][col-1];
            board[row][col-1] = temp;
        }
    }
    
     if (row > 0) {
        int A = board[row-1][col];
        //printf(""The tile above is %d \n"", A);
        if (A == -1){
            int temp = board[row][col];
            board[row][col] = board[row-1][col];
            board[row-1][col] = temp;
        }
    }
    
    if (row < 3) {
        int A = board[row+1][col];
        //printf(""The tile Below is %d \n"", A);
         if (A == -1){
            int temp = board[row][col];
            board[row][col] = board[row+1][col];
            board[row+1][col] = temp;
        }
    }
}
",1
tsin304,1696234271,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    
    int emptyrow, emptycol, tilerow, tilecol;
    
    
    
    //finding empty tile and chosen tile
    for (int i = 0; i <= 3; i++)
    {
        for (int j = 0; j <= 3; j++)
        {
            if (board[i][j]==-1)
            {
                emptyrow = i;
                emptycol = j;
                //printf(""Empty Tile is at: %d %d\n"", emptyrow, emptycol);
            }    
            if (board[i][j]==tile)
            {
                tilerow = i;
                tilecol = j;
                //printf(""Chosen tile is at: %d %d\n"", tilerow, tilecol);
            }
        }
    }
    
    //finding if move is possible
    //same row:
    if (emptyrow == tilerow)
    {
        if (emptycol - tilecol == -1 || emptycol - tilecol == 1)
        {   //make move
            //printf(""horizontal move is possible\n"");
            
            int temptile = board[tilerow][tilecol];
            int tempempty = board[emptyrow][emptycol];
            
            board[emptyrow][emptycol] = temptile;
            board[tilerow][tilecol] = tempempty;
            
        } //else{printf(""horizontal move impossible!\n"");}
        
    }
    
    
    //same column:
    if (emptycol == tilecol)
    {
       if (emptyrow - tilerow == -1 || emptyrow - tilerow == 1)
       {    //make move
            //printf(""vertical move is possible\n"");
            
            int temptile = board[tilerow][tilecol];
            int tempempty = board[emptyrow][emptycol];
            
            board[emptyrow][emptycol] = temptile;
            board[tilerow][tilecol] = tempempty;
            
            
       } //else{printf(""vertical move impossible!\n"");}
    
    }
    
    //end
    
}",1
ttho505,1695804950,1,"#include <stdio.h>
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int erow, ecol, row, col;
	int temp;



	FindTile(board, tile, &row, &col);
	FindTile(board, -1, &erow, &ecol);

	if ((row == erow && (col == ecol + 1 || col == ecol - 1)) ||
		(col == ecol && (row == erow + 1 || row == erow - 1))) {
		if (row >= 0 && row < NUM_ROWS && col >= 0 && col < NUM_COLS) {
			temp = board[erow][ecol];
			board[erow][ecol] = board[row][col];
			board[row][col] = temp;
		}

	}
}",1
ttho743,1695868913,1,"#include <stdio.h>
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col;
    FindTile(board, -1, &row, &col);
    if(col != 0){
    if (tile == board[row][col -1]){
            board[row][col] = tile;
            board[row][col-1] = -1;
        }
    }
    if(col != NUM_COLS - 1){
   if (tile == board[row][col+1]){
            board[row][col] = tile;
            board[row][col+1] = -1;
        }
    }
    if(col != NUM_ROWS - 1){
    if (tile == board[row+1][col]){
            board[row][col] = tile;
            board[row + 1][col] = -1;
        }
    }
    if(row != 0){
     if (tile == board[row-1][col]){
            board[row][col] = tile;
            board[row - 1][col] = -1;
        }
    }
}",0
ttho743,1695869264,2,"#include <stdio.h>
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col;
    FindTile(board, -1, &row, &col);
    if(col != 0){
    if (tile == board[row][col -1]){
            board[row][col] = tile;
            board[row][col-1] = -1;
        }
    }
    if(col != NUM_COLS - 1){
   if (tile == board[row][col+1]){
            board[row][col] = tile;
            board[row][col+1] = -1;
        }
    }
    if(row != NUM_ROWS - 1){
    if (tile == board[row+1][col]){
            board[row][col] = tile;
            board[row + 1][col] = -1;
        }
    }
    if(row != 0){
     if (tile == board[row-1][col]){
            board[row][col] = tile;
            board[row - 1][col] = -1;
        }
    }
}",1
twol698,1695802776,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowSpace,colSpace,row,col; 
	FindTile(board, -1, &rowSpace, &colSpace);
	FindTile(board, tile, &row, &col);
	if (((row-rowSpace == 0) & (-1<=col-colSpace<=1))|(col-colSpace == 0)&(-1<=(row-rowSpace)<=1)){
		board[rowSpace][colSpace] = tile;
		board[row][col] = -1; 
	}
}",0
twol698,1695803062,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowSpace,colSpace,row,col; 
	FindTile(board, -1, &rowSpace, &colSpace);
	FindTile(board, tile, &row, &col);
	if (((row-rowSpace == 0) & ((-1<=col-colSpace)&(col-colSpace<=1)))|((col-colSpace == 0)&((-1<=row-rowSpace)&(row-rowSpace<=1)))){
		board[rowSpace][colSpace] = tile;
		board[row][col] = -1; 
	}
}",1
tyou333,1695629440,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int moveTileRow, moveTileCol, emptyTileRow, emptyTileCol;

    FindTile(board, -1, &emptyTileRow, &emptyTileCol);

    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == tile) {
                moveTileRow = i;
                moveTileCol = j;
            }
        }
    }

    int startRow = emptyTileRow - 1;
    int endRow = emptyTileRow + 1;
    int startCol = emptyTileCol - 1;
    int endCol = emptyTileCol + 1;

    printf(""%d %d %d\n"", startCol, endCol, moveTileCol);

    if (((emptyTileRow == moveTileRow) && (startCol <= moveTileCol && moveTileCol <= endCol)) ||
    ((emptyTileCol == moveTileCol) && (startRow <= moveTileRow && moveTileRow <= endRow))) {
        int temp = board[emptyTileRow][emptyTileCol];
        board[emptyTileRow][emptyTileCol] = board[moveTileRow][moveTileCol];
        board[moveTileRow][moveTileCol] = temp;
    }
}",0
tyou333,1695629457,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int moveTileRow, moveTileCol, emptyTileRow, emptyTileCol;

    FindTile(board, -1, &emptyTileRow, &emptyTileCol);

    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == tile) {
                moveTileRow = i;
                moveTileCol = j;
            }
        }
    }

    int startRow = emptyTileRow - 1;
    int endRow = emptyTileRow + 1;
    int startCol = emptyTileCol - 1;
    int endCol = emptyTileCol + 1;

    if (((emptyTileRow == moveTileRow) && (startCol <= moveTileCol && moveTileCol <= endCol)) ||
    ((emptyTileCol == moveTileCol) && (startRow <= moveTileRow && moveTileRow <= endRow))) {
        int temp = board[emptyTileRow][emptyTileCol];
        board[emptyTileRow][emptyTileCol] = board[moveTileRow][moveTileCol];
        board[moveTileRow][moveTileCol] = temp;
    }
}",1
tyou421,1695972399,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	/*This function searches for the empty tile and the tile to be moved,
	  then checks if they are adjacent. If they are, the tile can be
	  slid into the empty space.

	 Inputs:
			board: A 4-by-4 2D array representing the board of tiles.
			tile: An integer indicating which tile the user wishes to move.
	 Outputs:
			None.

	Author: Toma Yousif*/

	// Declare the indexers and storing variables.
	int i;
	int j;
	int rowValue;
	int colValue;
	int iRow;
	int iCol;

	// Iterate through the 2D array and look for the specified tile (second
	// input), then store its position.
	for (i = 0; i < NUM_ROWS; i++)
	{
		for (j = 0; j < NUM_COLS; j++)
		{
			if (board[i][j] == tile)
			{
				rowValue = i;
				colValue = j;
			}
		}
	}

	// Iterate through the 2D array and look for the empty tile (-1), then
	// store its position.
	for (i = 0; i < NUM_ROWS; i++)
	{
		for (j = 0; j < NUM_COLS; j++)
		{
			if (board[i][j] == -1)
			{
				iRow = i;
				iCol = j;
			}
		}
	}

	if ((colValue == iCol - 1 || colValue == iCol + 1) && iRow == rowValue)
	{
		board[rowValue][colValue] = -1;
		board[iRow][iCol] = tile;
	}
	else if ((rowValue == iRow - 1 || rowValue == iRow + 1) && iCol == colValue)
	{
		board[rowValue][colValue] = -1;
		board[iRow][iCol] = tile;
	}
}",1
tzha578,1695615182,1,"#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#define NUM_ROWS 4
#define NUM_COLS 4
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    int rownegativeone = 0,colnegativeone = 0,rowtile = 0,coltile = 0;
    for (int i = 0;i<NUM_ROWS;++i){
        for (int j = 0;j<NUM_COLS;++j){
            if(board[i][j] == -1){
                rownegativeone = i;
                colnegativeone = j;
                
            }
            if(board[i][j] == tile){
                rowtile = i;
                coltile = j;
            }
            
            }
        }
    if((rownegativeone == rowtile && (colnegativeone == coltile + 1 || colnegativeone == coltile - 1)) 
    ||(colnegativeone == coltile && (rownegativeone == rowtile + 1 || rownegativeone == rowtile - 1))){
        board[rownegativeone][colnegativeone] = tile;
        board[rowtile][coltile] = -1;
    }
}",1
tzho903,1696225844,1,"#include <stdio.h>

void
MakeMove (int board[NUM_ROWS][NUM_COLS], int tile)
{
  FindTile (board, -1, &row, &col);

  for (int i = 0; i < 4; i++)
    {
      for (int j = 0; j < 4; j++)
	{
	  if (board[i][j] == tile)
	    {
	      int row1 = i;
	      int col1 = j;
	    }
	}
    }
  if (row1 + 1 <= 4 && row1 - 1 >= 0 && col1 + 1 <= 4 && col1 - 1 >= 0)
    {
      if (row1 + 1 == row || row1 - 1 == row || col1 + 1 == col
	  || col1 - 1 == col)
	{
	  board[row][col] = board[row1][col1];
	  board[row1][col1] = 0;
	}
    }
  return board;
}
",0
tzho903,1696235838,2,"void MakeMove (int board[NUM_ROWS][NUM_COLS], int tile)
{
  int row;
  int col;
  int row1;
  int col1;
  FindTile(board, -1, &row, &col);
  FindTile(board, tile, &row1, &col1);
  
  if (row == row1 || col == col1) {
        board[row][col] = board[row1][col1];
        board[row1][col1] = -1;
  } 
    
    
} 
",0
tzho903,1696236241,3,"void MakeMove (int board[NUM_ROWS][NUM_COLS], int tile)
{
  int row;
  int col;
  int row1;
  int col1;
  FindTile(board, -1, &row, &col);
  FindTile(board, tile, &row1, &col1);
  
  if (row + 1 == row1 || row - 1 == row1 || col + 1 == col1 || col - 1 == col1) {
      if (row == row1 || col == col1) {
        board[row][col] = board[row1][col1];
        board[row1][col1] = -1;
             
      } 
  } 

} 
",1
uali517,1695782911,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;
	int temp;
	scanf(""%d"", &tile);
	FindTile(board, tile, &row, &col);

	if (board[row + 1][col] == -1) {
		temp = board[row][col];
		board[row][col] = board[row + 1][col];
		board[row + 1][col] = temp;
	}
	if (board[row - 1][col] == -1) {
		temp = board[row][col];
		board[row][col] = board[row - 1][col];
		board[row - 1][col] = temp;
	}
	if (board[row][col + 1] == -1) {
		temp = board[row][col];
		board[row][col] = board[row][col + 1];
		board[row][col + 1] = temp;
	}
	if (board[row][col - 1] == -1) {
		temp = board[row][col];
		board[row][col] = board[row][col - 1];
		board[row][col - 1] = temp;
	}

}",0
uali517,1695784528,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;
	int temp;
	scanf(""%d"", &tile);
	FindTile(board, tile, &row, &col);
	if (row < 4 && row > -1) {
		if (board[row + 1][col] == -1) {
			temp = board[row][col];
			board[row][col] = board[row + 1][col];
			board[row + 1][col] = temp;
		}
		if (board[row - 1][col] == -1) {
			temp = board[row][col];
			board[row][col] = board[row - 1][col];
			board[row - 1][col] = temp;
		}
	}
	if((col + 1) < 4 && (col - 1) >= 0) {
		if (board[row][col + 1] == -1) {
			temp = board[row][col];
			board[row][col] = board[row][col + 1];
			board[row][col + 1] = temp;
		}
		if (board[row][col - 1] == -1) {
			temp = board[row][col];
			board[row][col] = board[row][col - 1];
			board[row][col - 1] = temp;
		}
	}

}",0
uali517,1695784853,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;
	int temp;
	scanf(""%d"", &tile);
	FindTile(board, tile, &row, &col);
	if (row < 4 && row > -1) {
		if (board[row + 1][col] == -1) {
			temp = board[row][col];
			board[row][col] = board[row + 1][col];
			board[row + 1][col] = temp;
		}
		if (board[row - 1][col] == -1) {
			temp = board[row][col];
			board[row][col] = board[row - 1][col];
			board[row - 1][col] = temp;
		}
	}
	if ((col + 1) < 4) {
		if (board[row][col + 1] == -1) {
			temp = board[row][col];
			board[row][col] = board[row][col + 1];
			board[row][col + 1] = temp;
		}
	}
	if((col - 1) >= 0) {
		if (board[row][col - 1] == -1) {
			temp = board[row][col];
			board[row][col] = board[row][col - 1];
			board[row][col - 1] = temp;
		}
	}

}",1
ujai264,1695791531,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
	int row, col, row1, col1;
	FindTile(board, tile, &row, &col);
	FindTile(board, -1, &row1, &col1);
	
	if (row1 - row == 1 || row1 - row == -1) {
		if(col - col1 == 0){
			board[row][col] = -1;
			board[row1][col] = tile;
		}
	}
	if (col1 - col == 1 || col1 - col == -1){
		if(row1 - row == 0){
			board[row][col] = -1;
			board[row][col1] = tile;
		}
	}

}",1
vbar374,1696224634,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRow, tileCol;
    int emptyRow, emptyCol;
    int foundTile = 0;
    
    for (int row = 0; row < NUM_ROWS; row++) {
        for (int col = 0; col < NUM_COLS; col++) {
            if (board[row][col] == tile) {
                tileRow = row;
                tileCol = col;
                foundTile = 1;
                break; 
            }
        }
        if (foundTile) {
            break; 
        }
    }
    
    for (int row = 0; row < NUM_ROWS; row++) {
        for (int col = 0; col < NUM_COLS; col++) {
            if (board[row][col] == -1 && ((abs(tileRow - row) == 1 && tileCol == col) || (abs(tileCol - col) == 1 && tileRow == row))) {
                board[emptyRow][emptyCol] = tile;
                board[tileRow][tileCol] = -1;
                return; 
            }
        }
    }
}

    
    
",0
vbar374,1696224700,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRow, tileCol;
    int foundTile = 0;
    
    for (int row = 0; row < NUM_ROWS; row++) {
        for (int col = 0; col < NUM_COLS; col++) {
            if (board[row][col] == tile) {
                tileRow = row;
                tileCol = col;
                foundTile = 1;
                break; /
            }
        }
        if (foundTile) {
            break; 
        }
    }
    
    for (int row = 0; row < NUM_ROWS; row++) {
        for (int col = 0; col < NUM_COLS; col++) {
            if (board[row][col] == -1 && ((abs(tileRow - row) == 1 && tileCol == col) || (abs(tileCol - col) == 1 && tileRow == row))) {
                board[row][col] = tile;
                board[tileRow][tileCol] = -1;
                return; 
            }
        }
    }
}
",0
vbar374,1696224726,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRow, tileCol;
    int foundTile = 0;
    
    for (int row = 0; row < NUM_ROWS; row++) {
        for (int col = 0; col < NUM_COLS; col++) {
            if (board[row][col] == tile) {
                tileRow = row;
                tileCol = col;
                foundTile = 1;
                break; 
            }
        }
        if (foundTile) {
            break; 
        }
    }
    
    for (int row = 0; row < NUM_ROWS; row++) {
        for (int col = 0; col < NUM_COLS; col++) {
            if (board[row][col] == -1 && ((abs(tileRow - row) == 1 && tileCol == col) || (abs(tileCol - col) == 1 && tileRow == row))) {
                board[row][col] = tile;
                board[tileRow][tileCol] = -1;
                return; 
            }
        }
    }
}
",1
vkap589,1695790453,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{

int PositionRowNum;
int PositionColNum;
FindTile(board, tile, &PositionRowNum, &PositionColNum);

if (PositionColNum == 0) {
    if (board[PositionRowNum-1][PositionColNum] == -1) {
        board[PositionRowNum-1][PositionColNum] = board[PositionRowNum][PositionColNum];
        board[PositionRowNum][PositionColNum] = -1;
    }
    else if (board[PositionRowNum+1][PositionColNum] == -1) {
        board[PositionRowNum+1][PositionColNum] = board[PositionRowNum][PositionColNum];
        board[PositionRowNum][PositionColNum] = -1;
    }
    else if (board[PositionRowNum][PositionColNum+1] == -1) {
        board[PositionRowNum][PositionColNum+1] = board[PositionRowNum][PositionColNum];
        board[PositionRowNum][PositionColNum] = -1;
    }
}
else if (PositionColNum == 3) {
        if (board[PositionRowNum-1][PositionColNum] == -1) {
        board[PositionRowNum-1][PositionColNum] = board[PositionRowNum][PositionColNum];
        board[PositionRowNum][PositionColNum] = -1;
    }
    else if (board[PositionRowNum+1][PositionColNum] == -1) {
        board[PositionRowNum+1][PositionColNum] = board[PositionRowNum][PositionColNum];
        board[PositionRowNum][PositionColNum] = -1;
    }
    else if (board[PositionRowNum][PositionColNum-1] == -1) {
        board[PositionRowNum][PositionColNum-1] = board[PositionRowNum][PositionColNum];
        board[PositionRowNum][PositionColNum] = -1;
    }
}
else if (PositionColNum == 1 | PositionColNum == 2) {
        if (board[PositionRowNum-1][PositionColNum] == -1) {
        board[PositionRowNum-1][PositionColNum] = board[PositionRowNum][PositionColNum];
        board[PositionRowNum][PositionColNum] = -1;
    }
    else if (board[PositionRowNum+1][PositionColNum] == -1) {
        board[PositionRowNum+1][PositionColNum] = board[PositionRowNum][PositionColNum];
        board[PositionRowNum][PositionColNum] = -1;
    }
    else if (board[PositionRowNum][PositionColNum+1] == -1) {
        board[PositionRowNum][PositionColNum+1] = board[PositionRowNum][PositionColNum];
        board[PositionRowNum][PositionColNum] = -1;
    }
    else if (board[PositionRowNum][PositionColNum-1] == -1) {
        board[PositionRowNum][PositionColNum-1] = board[PositionRowNum][PositionColNum];
        board[PositionRowNum][PositionColNum] = -1;
    }
}
else {
}
}",0
vkap589,1695790683,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{

int PositionRowNum;
int PositionColNum;
FindTile(board, tile, &PositionRowNum, &PositionColNum);

if (PositionColNum == 0) {
    if (board[PositionRowNum-1][PositionColNum] == -1) {
        board[PositionRowNum-1][PositionColNum] = board[PositionRowNum][PositionColNum];
        board[PositionRowNum][PositionColNum] = -1;
    }
    else if (board[PositionRowNum+1][PositionColNum] == -1) {
        board[PositionRowNum+1][PositionColNum] = board[PositionRowNum][PositionColNum];
        board[PositionRowNum][PositionColNum] = -1;
    }
    else if (board[PositionRowNum][PositionColNum+1] == -1) {
        board[PositionRowNum][PositionColNum+1] = board[PositionRowNum][PositionColNum];
        board[PositionRowNum][PositionColNum] = -1;
    }
}
else if (PositionColNum == 3) {
        if (board[PositionRowNum-1][PositionColNum] == -1) {
        board[PositionRowNum-1][PositionColNum] = board[PositionRowNum][PositionColNum];
        board[PositionRowNum][PositionColNum] = -1;
    }
    else if (board[PositionRowNum+1][PositionColNum] == -1) {
        board[PositionRowNum+1][PositionColNum] = board[PositionRowNum][PositionColNum];
        board[PositionRowNum][PositionColNum] = -1;
    }
    else if (board[PositionRowNum][PositionColNum-1] == -1) {
        board[PositionRowNum][PositionColNum-1] = board[PositionRowNum][PositionColNum];
        board[PositionRowNum][PositionColNum] = -1;
    }
}
else if ((PositionColNum == 1) || (PositionColNum == 2)) {
        if (board[PositionRowNum-1][PositionColNum] == -1) {
        board[PositionRowNum-1][PositionColNum] = board[PositionRowNum][PositionColNum];
        board[PositionRowNum][PositionColNum] = -1;
    }
    else if (board[PositionRowNum+1][PositionColNum] == -1) {
        board[PositionRowNum+1][PositionColNum] = board[PositionRowNum][PositionColNum];
        board[PositionRowNum][PositionColNum] = -1;
    }
    else if (board[PositionRowNum][PositionColNum+1] == -1) {
        board[PositionRowNum][PositionColNum+1] = board[PositionRowNum][PositionColNum];
        board[PositionRowNum][PositionColNum] = -1;
    }
    else if (board[PositionRowNum][PositionColNum-1] == -1) {
        board[PositionRowNum][PositionColNum-1] = board[PositionRowNum][PositionColNum];
        board[PositionRowNum][PositionColNum] = -1;
    }
}
else {
}
}",1
vlai276,1696243357,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int RowTile;
    int ColTile;
    int RowEmpty;
    int ColEmpty;
    
    FindTile(board, -1, &RowEmpty, &ColEmpty);
    FindTile(board, -1, &RowTile, &ColTile);
    
    if ((RowTile == RowEmpty + 1 && ColTile == ColEmpty) || 
    (RowTile == RowEmpty - 1 && ColTile == ColEmpty) || 
    (RowTile == RowEmpty && ColTile == ColEmpty + 1) || 
    (RowTile == RowEmpty && ColTile == ColEmpty - 1)){
        board[RowTile][ColTile] = -1;
        board[RowEmpty][ColEmpty] = tile;
    }
    
    
    
}",0
vlai276,1696243419,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int RowTile;
    int ColTile;
    int RowEmpty;
    int ColEmpty;
    
    FindTile(board, -1, &RowEmpty, &ColEmpty);
    FindTile(board, tile, &RowTile, &ColTile);
    
    if ((RowTile == RowEmpty + 1 && ColTile == ColEmpty) || 
    (RowTile == RowEmpty - 1 && ColTile == ColEmpty) || 
    (RowTile == RowEmpty && ColTile == ColEmpty + 1) || 
    (RowTile == RowEmpty && ColTile == ColEmpty - 1)){
        board[RowTile][ColTile] = -1;
        board[RowEmpty][ColEmpty] = tile;
    }
    
    
    
}",1
vpat188,1696117827,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{

    int row1, col1, MainR, MainC, HoldOn;
    
    
    FindTile(board, -1, &MainR, &MainC);
    FindTile(board, tile, &row1, &col1);
    
    
    if (row1 == MainR + 1 && col1 == MainC){
        
        HoldOn = board[row1][col1];
        
        board[row1][col1] = board[MainR][MainC];
        board[MainR][MainC] = HoldOn;

    } else if (row1 == MainR - 1 && col1 == MainC) {
        
        HoldOn = board[row1][col1];
        
        board[row1][col1] = board[MainR][MainC];
        board[MainR][MainC] = HoldOn;
        
        
    } else if (row1 == MainR && col1 == MainC - 1) {
        
        HoldOn = board[row1][col1];
        
        board[row1][col1] = board[MainR][MainC];
        board[MainR][MainC] = HoldOn;
        
        
    } else if (row1 == MainR && col1 == MainC + 1) {
        
        HoldOn = board[row1][col1];
        
        board[row1][col1] = board[MainR][MainC];
        board[MainR][MainC] = HoldOn;
    }

}",1
vwon573,1696235779,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int rowPos, colPos;
    FindTile(board, tile, &rowPos, &colPos); 

    int emptyRow, emptyCol;
    FindTile(board, -1, &emptyRow, &emptyCol); 

    // Check if the specified tile and empty square are adjacent
    if ((abs(rowPos - emptyRow) == 1 && colPos == emptyCol) ||
        (rowPos == emptyRow && abs(colPos - emptyCol) == 1)) {
        // Swap the specified tile with the empty square
        board[emptyRow][emptyCol] = tile;
        board[rowPos][colPos] = -1;
    }
}
",1
vwu693,1696224956,1,"#define _CRT_SECURE_NO_WARNINGS_
#include <stdio.h>
#define NUM_ROWS 4
#define NUM_COLS 4
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, tilerow, tilecol, i, j;
	FindTile(board, -1, &row, &col);
	for (int i = 0; i < NUM_ROWS; i++) {
		for (int j = 0; j < NUM_ROWS; j++) {
			if (board[i][j] == tile) {
				tilerow = i;
				tilecol = j;
			}
		}
	}
	if (((tilerow == row + 1) && (tilecol == col)) || ((tilerow == row - 1) && (tilecol == col)) || ((tilerow == row) && (tilecol == col + 1)) || ((tilerow == row) && (tilecol == col - 1)) && ((row-1 != -1) || (col-1 != -1) || (row + 1 != 5) || (col + 1 != 5))) {
		board[row][col] = tile;
		board[tilerow][tilecol] = -1;
	}
}",0
vwu693,1696225341,2,"#define _CRT_SECURE_NO_WARNINGS_
#include <stdio.h>
#define NUM_ROWS 4
#define NUM_COLS 4
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, tilerow, tilecol, i, j;
	FindTile(board, -1, &row, &col);
	for (int i = 0; i < NUM_ROWS; i++) {
		for (int j = 0; j < NUM_ROWS; j++) {
			if (board[i][j] == tile) {
				tilerow = i;
				tilecol = j;
			}
		}
	}
	if (((tilerow == row + 1) && (tilecol == col)) || ((tilerow == row - 1) && (tilecol == col)) || ((tilerow == row) && (tilecol == col + 1)) || ((tilerow == row) && (tilecol == col - 1))) {
		board[row][col] = tile;
		board[tilerow][tilecol] = -1;
	}
}",0
vwu693,1696225389,3,"#define _CRT_SECURE_NO_WARNINGS_
#include <stdio.h>
#define NUM_ROWS 4
#define NUM_COLS 4
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, tilerow, tilecol;
	FindTile(board, -1, &row, &col);
	for (int i = 0; i < NUM_ROWS; i++) {
		for (int j = 0; j < NUM_ROWS; j++) {
			if (board[i][j] == tile) {
				tilerow = i;
				tilecol = j;
			}
		}
	}
	if (((tilerow == row + 1) && (tilecol == col)) || ((tilerow == row - 1) && (tilecol == col)) || ((tilerow == row) && (tilecol == col + 1)) || ((tilerow == row) && (tilecol == col - 1))) {
		board[row][col] = tile;
		board[tilerow][tilecol] = -1;
	}
}",1
vxie208,1695852382,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowTile, colTile, rowBlank, colBlank, temp;
	FindTile(board, tile, &rowTile, &colTile);
	FindTile(board, -1, &rowBlank, &colBlank);
	// checking if the blank and tile is in the same row
	if (rowBlank == rowTile) {
		if (colBlank + 1 == colTile || colBlank - 1 == colTile) {
			temp = board[rowTile][colTile];
			board[rowTile][colTile] = board[rowBlank][colBlank];
			board[rowBlank][colBlank] = temp;
		}
	}
	// checking if blank and tile are in the same column
	if (rowBlank + 1 == rowTile || rowBlank - 1 == rowTile) {
		if (colBlank == colTile) {
			temp = board[rowTile][colTile];
			board[rowTile][colTile] = board[rowBlank][colBlank];
			board[rowBlank][colBlank] = temp;
		}
	}

	
}",1
wany079,1695905912,1,"#include <stdio.h>
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i;
	int j;

	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_ROWS; j++) {
			if (board[i][j] == -1) {
				if (board[i + 1][j] == tile) {
					board[i][j] = tile;
					board[i + 1][j] = -1;
					return;
				}
				else if (board[i - 1][j] == tile) {
					board[i][j] = tile;
					board[i - 1][j] = -1;
					return;
				}
				else if (board[i][j + 1] == tile && j + 1 != 4) {
					board[i][j] = tile;
					board[i][j + 1] = -1;
					return;
				}
				else if (board[i][j - 1] == tile && j - 1 != -1) {
					board[i][j] = tile;
					board[i][j - 1] = -1;
					return;
				}
			}
		}
	}
}",1
wany722,1695698332,1,"#include<stdio.h>
#define NUM_ROWS 4
#define NUM_COLS 4
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    int i,j, posi_, posj_, postilei, postilej;
    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if(board[i][j] == -1){
                posi_ = i;
                posj_ = j;
                
            }
            if(board[i][j] == tile){
                postilei = i;
                postilej = j;
            }
        }
    }
    if(posi_ == postilei){
        if ((posj_ - postilej == 1)||(posj_ - postilej == -1)){
            board[posi_][posj_] = board[posi_][postilej];
            board[posi_][postilej] = -1;
        }
    }
    if(posj_ == postilej){
        if ((posi_ - postilei == 1)||(posi_ - postilei == -1)){
            board[posi_][posj_] = board[postilei][postilej];
            board[postilei][postilej] = -1;
    }
}",0
wany722,1695698994,2,"#include<stdio.h>
#define NUM_ROWS 4
#define NUM_COLS 4
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    int i,j, posi_, posj_, postilei, postilej;
    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if(board[i][j] == -1){
                posi_ = i;
                posj_ = j;
                
            }
            if(board[i][j] == tile){
                postilei = i;
                postilej = j;
            }
        }
    }
    if(posi_ == postilei){
        if ((posj_ - postilej == 1)||(posj_ - postilej == -1)){
            board[posi_][posj_] = board[posi_][postilej];
            board[posi_][postilej] = -1;
        }
    }
    if(posj_ == postilej){
        if ((posi_ - postilei == 1)||(posi_ - postilei == -1)){
            board[posi_][posj_] = board[postilei][postilej];
            board[postilei][postilej] = -1;
    }
}
}",1
wany843,1695699323,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) 
{
    int tileRow, tileCol, emptyRow, emptyCol;
    
    // tile
    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol);

    // tile
    if (((tileRow == emptyRow) && (tileCol == emptyCol + 1 || tileCol == emptyCol - 1)) ||
        ((tileCol == emptyCol) && (tileRow == emptyRow + 1 || tileRow == emptyRow - 1))) 
    {
        // 
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}
",1
wany897,1695863495,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowempty, colempty, rowtile,coltile;
	FindTile(board, -1, &rowempty, &colempty);
	FindTile(board, tile, &rowtile, &coltile);
	if ((colempty == coltile && (rowempty == rowtile - 1 || rowempty == rowtile + 1))|| rowempty == rowtile && (colempty == coltile - 1|| colempty == coltile + 1))
	{
		board[rowempty][colempty] = tile;
		board[rowtile][coltile] = -1;
	}
}",0
wany897,1695864213,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowempty, colempty, rowtile,coltile;
	FindTile(board, -1, &rowempty, &colempty);
	FindTile(board, tile, &rowtile, &coltile);
	if ((colempty == coltile && (rowempty == rowtile - 1 || rowempty == rowtile + 1)) || (rowempty == rowtile && (colempty == coltile - 1|| colempty == coltile + 1)))
	{
		board[rowempty][colempty] = tile;
		board[rowtile][coltile] = -1;
	}
}",1
wany932,1696212185,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRow, tileCol, emptyRow, emptyCol;

    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol);

    if ((tileRow == emptyRow && abs(tileCol - emptyCol) == 1) ||
        (tileCol == emptyCol && abs(tileRow - emptyRow) == 1)) {
        
        board[tileRow][tileCol] = -1;
        board[emptyRow][emptyCol] = tile;
    }
}
",1
wany932,1696216338,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRow, tileCol;
    FindTile(board, tile, &tileRow, &tileCol);

    int emptyRow, emptyCol;
    FindTile(board, -1, &emptyRow, &emptyCol);

    if ((tileRow == emptyRow && abs(tileCol - emptyCol) == 1) || (tileCol == emptyCol && abs(tileRow - emptyRow) == 1)) {
        board[tileRow][tileCol] = -1;
        board[emptyRow][emptyCol] = tile;
    }
}
",1
wkev690,1695852099,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	// Find pos of -1
	int colOrigin;
	int rowOrigin;
	int temp = 0;
	
	FindTile(board, -1, &rowOrigin, &colOrigin);
	
	// up movement
	if (board[rowOrigin-1][colOrigin] == tile && rowOrigin != 0){
	
		temp = board[rowOrigin-1][colOrigin];
		board[rowOrigin][colOrigin] = temp;
		board[rowOrigin-1][colOrigin] = -1;	
	
	// down movement
	}else if(board[rowOrigin+1][colOrigin] == tile && rowOrigin != (NUM_ROWS-1)){
		
		temp = board[rowOrigin+1][colOrigin];
		board[rowOrigin][colOrigin] = temp;
		board[rowOrigin+1][colOrigin] = -1;
		
	// right movement
	}else if(board[rowOrigin][colOrigin+1] == tile && colOrigin != (NUM_COLS-1)){
		
		temp = board[rowOrigin][colOrigin+1];
		board[rowOrigin][colOrigin] = temp;
		board[rowOrigin][colOrigin+1] = -1;
		
	// left movement
	}else if (board[rowOrigin][colOrigin-1] == tile && colOrigin != 0)
	{

		temp = board[rowOrigin][colOrigin-1];
		board[rowOrigin][colOrigin] = temp;
		board[rowOrigin][colOrigin-1] = -1;		
		
	}
}",1
wli798,1696217832,1,"#include <stdio.h> 
#include <stdlib.h>
#define NUM_ROWS 4 
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{

    int rows1, col1, rows2, col2;
    FindTile(board, -1, &rows1, &col1);
    FindTile(board, tile, &rows2, &col2);

    int i, j, rowdiff, coldiff;
    int temp;
    
    rowdiff = abs(rows2-rows1);
    coldiff = abs(col2-col1);
    
    for (i = 0; i < NUM_ROWS; i++) {
        for (j = 0; j < NUM_COLS; j++) {
            if ((rowdiff==1 && coldiff ==0) || (coldiff == 1 && rowdiff == 0))
            {
               board[rows1][col1] = tile;
               board[rows2][col2] = -1;
            }
        }
    }
}",0
wli798,1696217863,2,"#include <stdio.h> 
#include <stdlib.h>
#define NUM_ROWS 4 
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{

    int rows1, col1, rows2, col2;
    FindTile(board, -1, &rows1, &col1);
    FindTile(board, tile, &rows2, &col2);

    int i, j, rowdiff, coldiff;
    
    rowdiff = abs(rows2-rows1);
    coldiff = abs(col2-col1);
    
    for (i = 0; i < NUM_ROWS; i++) {
        for (j = 0; j < NUM_COLS; j++) {
            if ((rowdiff==1 && coldiff ==0) || (coldiff == 1 && rowdiff == 0))
            {
               board[rows1][col1] = tile;
               board[rows2][col2] = -1;
            }
        }
    }
}",1
wlin709,1696240942,1,"#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

#define NUM_ROWS 4 
#define NUM_COLS 4  

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) 
{
    int targetRow;
    int targetCol;
    int emptyRow;
    int emptyCol;
    
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &targetRow, &targetCol);
    
    if ((targetRow == emptyRow + 1 && targetCol == emptyCol) || 
        (targetRow == emptyRow - 1 && targetCol == emptyCol) || 
        (targetRow == emptyRow && targetCol == emptyCol + 1) || 
        (targetRow == emptyRow && targetCol == emptyCol - 1)) 
    {
        int temp = board[targetRow][targetCol];
        board[targetRow][targetCol] = board[emptyRow][emptyCol];
        board[emptyRow][emptyCol] = temp;
    }
}
",1
wliy226,1696223117,1,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int targetRow, targetCol, emptyRow, emptyCol;

    // Find the position of the empty tile and the target tile
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &targetRow, &targetCol);

    // Calculate the differences in row and column positions
    int rowDifference = targetRow - emptyRow;
    int colDifference = targetCol - emptyCol;

    // Check if the move is valid (target tile and empty tile are adjacent)
    if ((rowDifference == 1 && colDifference == 0) || (rowDifference == -1 && colDifference == 0) ||
        (rowDifference == 0 && colDifference == 1) || (rowDifference == 0 && colDifference == -1)) {

        // Perform the tile move by swapping positions
        board[emptyRow][emptyCol] = tile;
        board[targetRow][targetCol] = -1;
    }
}
",1
wmas516,1695614130,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
	int newRow, newCol, curRow, curCol;
	FindTile(board, tile, &newRow, &newCol);
	FindTile(board, -1, &curRow, &curCol);
	if ((pow(newRow - curRow,2)+pow(newCol-curCol,2))==1){
		board[newRow][newCol]= -1;
		board[curRow][curCol] = tile;
	}
	return;
}",1
wwan296,1695770544,1,"#include <stdio.h>
#include <stdlib.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col;
    FindTile(board, -1, &row, &col);
    int nrow, ncol;
    FindTile(board, tile, &nrow, &ncol);
    if ((abs(nrow - row) == 1 && ncol == col) || (nrow == row && abs(ncol - col) == 1)){
        board[row][col] = tile;
        board[nrow][ncol] = -1;
    }
    return;
}",1
wwon485,1695789226,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	// Checks if the number is within the bounds
	if (tile < 1 || tile > 15) {
		return;
	}

	int emptyRow, emptyCol, tileRow, tileCol; 
	FindTile(board, -1, &emptyRow, &emptyCol);
	FindTile(board, tile, &tileRow, &tileCol);

	// Checks the left side of the tile
	if (emptyCol - 1 == tileCol && emptyRow == tileRow) {
		board[emptyRow][emptyCol] = tile;
		board[tileRow][tileCol] = -1;
	} else if (emptyCol + 1 == tileCol && emptyRow == tileRow) {
		board[emptyRow][emptyCol] = tile;
		board[tileRow][tileCol] = -1;
	} else if (emptyRow - 1 == tileRow && emptyCol == tileCol) {
		board[emptyRow][emptyCol] = tile;
		board[tileRow][tileCol] = -1;
	} else if (emptyRow + 1 == tileRow && emptyCol == tileCol) {
		board[emptyRow][emptyCol] = tile;
		board[tileRow][tileCol] = -1;
	}
}",1
wwu295,1696099885,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, i, j;
	int *rowPoint = &row;
	int *colPoint = &col;

	FindTile(board, tile, rowPoint, colPoint);
	for (j = -1; j < 2; j += 2) {
		if ((col + j == -1) || (col + j == 4)) {
			continue;
		}
		if (board[row][col + j] == -1) {
			board[row][col + j] = board[row][col];
			board[row][col] = -1;
		}
	}
	for (i = -1; i < 2; i += 2) {
		if ((row + i == -1) || (row + i == 4)) {
			continue;
		}
		if (board[row + i][col] == -1) {
			board[row + i][col] = board[row][col];
			board[row][col] = -1;
		}
	}
}",1
wyu523,1695766892,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col;
    FindTile(board, -1, &row, &col);
    if (board[row][col+1]==tile){
        if (col<3){
            board[row][col]=tile;
            board[row][col+1]=-1;
            return;
        }
    }

    if (board[row][col-1]==tile){
        if (col>0){
            board[row][col]=tile;
            board[row][col-1]=-1;
            return;
        }
    }
    if (board[row+1][col]==tile){
        if (row<3){
            board[row][col]=tile;
            board[row+1][col]=-1;
            return;
        }
    }
    if (board[row-1][col]==tile){
        if (row>0){
            board[row][col]=tile;
            board[row-1][col]=-1;
            return;
        }
    }
    
    return;
}",1
wyua331,1696234096,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col;

    FindTile(board, -1, &row, &col);
    int rowem=row;
    int colem=col;

    FindTile(board, tile, &row, &col);
    int diffr=abs(rowem-row);
    int diffc=abs(colem-col);

    if((diffr<=1)&&(diffc<=1))
    {
        board[rowem][colem]=tile;
        board[row][col]=-1;

    }


}",1
wzha508,1696130410,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int Rows, Column, eR, eC, place;

    FindTile(board, tile, &Rows, &Column);
    FindTile(board, -1, &eR, &eC);

    
    if (Column > 0)
    {
        if (eC == Column - 1 && eR == Rows)
        {
            place = board[Rows][Column];
            board[Rows][Column] = board[eR][eC];
            board[eR][eC] = place;
        }
    }

  
    if (Column < 3)
    {
        if (eC == Column + 1 && eR == Rows)
        {
            place = board[Rows][Column];
            board[Rows][Column] = board[eR][eC];
            board[eR][eC] = place;
        }
    }

   
    if (Rows > 0)
    {
        if (eR == Rows - 1 && eC == Column)
        {
            place = board[Rows][Column];
            board[Rows][Column] = board[eR][eC];
            board[eR][eC] = place;
        }
    }

 
    if (Rows < 3)
    {
        if (eR == Rows + 1 && eC == Column)
        {
            place = board[Rows][Column];
            board[Rows][Column] = board[eR][eC];
            board[eR][eC] = place;
        }
    }

}",1
xche362,1695878041,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    
    int row,col;
    FindTile(board, -1, &row, &col);
    int nrow,ncol;
    FindTile(board, tile, &nrow, &ncol);
    
    board[row][col]=tile;
    board[nrow][ncol]=-1;
    return;
}",0
xche362,1695878538,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    
    int row,col;
    FindTile(board, -1, &row, &col);
    int nrow,ncol;
    FindTile(board, tile, &nrow, &ncol);
    if (abs(nrow-row)==1 && abs(ncol-col)==1){
      board[row][col]=tile;
      board[nrow][ncol]=-1;
      return;
    {
}
",0
xche362,1695878694,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    
    int row,col;
    FindTile(board, -1, &row, &col);
    int nrow,ncol;
    FindTile(board, tile, &nrow, &ncol);
    if ((nrow-row ==1)&&(ncol-col)==1)
      board[row][col]=tile;
      board[nrow][ncol]=-1;
      return;
    {
}
",0
xche362,1695878704,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    
    int row,col;
    FindTile(board, -1, &row, &col);
    int nrow,ncol;
    FindTile(board, tile, &nrow, &ncol);
    if ((nrow-row ==1)&&(ncol-col)==1)){
      board[row][col]=tile;
      board[nrow][ncol]=-1;
      return;
    {
}
",0
xche362,1695878720,5,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    
    int row,col;
    FindTile(board, -1, &row, &col);
    int nrow,ncol;
    FindTile(board, tile, &nrow, &ncol);
    
      board[row][col]=tile;
      board[nrow][ncol]=-1;
      return;
    
}
",0
xche362,1695888241,6,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    
    int row,col;
    FindTile(board, -1, &row, &col);
    int nrow,ncol;
    FindTile(board, tile, &nrow, &ncol);
    if ((row-nrow==1 && col-ncol==1) || (row-nrow==1 && ncol-col==1) || (nrow-row==1 && col-ncol==1)||(nrow-row==1 && ncol-col==1)){
        board[row][col]=tile;
        board[nrow][ncol]=-1;
        return;
    }
    else{
        board[row][col]=-1;
        board[nrow][ncol]=tile;
        return;
    }
}
    ",0
xkan320,1695720496,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col;
    FindTile(board, tile, &row, &col);
    
    
    if(board[row][col-1] == -1){
        board[row][col-1] = board[row][col];
        board[row][col] = -1;
    }else if (board[row][col+1] == -1){
        board[row][col+1] = board[row][col];
        board[row][col] = -1;
    }else if (board[row-1][col] == -1){
        board[row-1][col] = board[row][col];
        board[row][col] = -1;
    }else if (board[row+1][col] == -1){
        board[row+1][col] = board[row][col];
        board[row][col] = -1;
    }
    
}",0
xkan320,1695723839,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowTile, colTile, rowEmpty, colEmpty;
    FindTile(board, tile, &rowTile, &colTile);
    FindTile(board, -1, &rowEmpty, &colEmpty);
    
    int tmp;
    if (abs(rowTile-rowEmpty)+abs(colTile-colEmpty) == 1){
        tmp = board[rowTile][colTile];
        board[rowTile][colTile] = board[rowEmpty][colEmpty];
        board[rowEmpty][colEmpty] = tmp;
    }
}",1
xli330,1695852211,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int emptyRowPos, emptyColPos, tileRowPos, tileColPos, distance;

	FindTile(board, -1, &emptyRowPos, &emptyColPos);
	FindTile(board, tile, &tileRowPos, &tileColPos);
	// printf(""tile is at: %d %d\n"", tileRowPos, tileColPos);

	// If user entered ""-1"".
	if ( (tileRowPos == emptyRowPos) && (tileColPos == emptyColPos) ) {
		// printf(""you entered -1\n"");
		return;
	}

	// If the tile is not on the same row or same column with the empty square.
	if ( (tileRowPos != emptyRowPos) && (tileColPos != emptyColPos) ) {
		// printf(""not on a same line\n"");
		return;
	}

	// If the tile and the empty square are on the same row.
	if (tileRowPos == emptyRowPos) {

		// If tile is not next to empty square horizontally.
		distance = tileColPos - emptyColPos;
		if (distance != 1 && distance != -1) {
			return;
		}
	}

	// If the tile and the empty square are on the same col.
	if (tileColPos == emptyColPos) {

		// If tile is not next to empty square vertically.
		distance = tileRowPos - emptyRowPos;
		if (distance != 1 && distance != -1) {
			return;
		}
	}

	// Copy the value in the tile to the empty square.
	board[emptyRowPos][emptyColPos] = board[tileRowPos][tileColPos];
	
	// The tile becomes the new empty square.
	board[tileRowPos][tileColPos] = -1;
}",1
xlia603,1696208271,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int EmpRow, EmpCol;
    int TileRow, TileCol;
    FindTile(board, -1, &EmpRow, &EmpCol);
    FindTile(board, tile, &TileRow, &TileCol);
    
    
    if(abs(TileRow - EmpRow) + abs(TileCol - EmpCol) == 1){
        board[TileRow][TileCol] = -1;
        board[EmpRow][EmpCol] = tile;
        return;
            
    }
}",1
xmet073,1696239504,1,"

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol, tileRow, tileCol;

    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);

    if ((tileRow == emptyRow && (tileCol == emptyCol - 1 || tileCol == emptyCol + 1)) ||
        (tileCol == emptyCol && (tileRow == emptyRow - 1 || tileRow == emptyRow + 1))) {
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}",1
xsny378,1696227191,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int Range_R, Range_C;
    int r, c;
    int Rows, Columns;
    FindTile(board, tile, &Rows, &Columns);
    FindTile(board, -1, &r, &c);

    Range_C = Columns - c;
    Range_R = Rows - r;

    if ((Range_R >= -1 && Range_R <= 1) && (Range_C >= -1 && Range_C <= 1))
    {
        int Array = board[Rows][Columns];
        board[Rows][Columns] = board[r][c];
        board[r][c] = Array;
    }
    else
    {
        return;
    }
}
",1
xtan207,1696242506,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int i;
    int j;
    int move_i;
    int move_j;
    
    FindTile(board, tile, &i, &j); 
    FindTile(board, -1, &move_i, &move_j); 
    
    if((i == move_i && (j == move_j + 1 || j == move_j - 1)) || 
       (j == move_j && (i == move_i + 1 || i == move_i - 1))) {

        board[move_i][move_j] = board[i][j];
        board[i][j] = -1;
    }
}",1
xugn489,1695685123,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row_space, col_space;
	int row_tile, col_tile;
	int row_adjacent = 0, col_adjacent = 0;
	
	FindTile(board, -1, &row_space, &col_space);
	FindTile(board, tile, &row_tile, &col_tile);
	if (row_space == row_tile || row_space == row_tile + 1 || row_space == row_tile -1) {
		row_adjacent = 1;
	}
	if (col_space == col_tile || col_space == col_tile + 1 || col_space == col_tile -1) {
		col_adjacent = 1;
	}
	if (row_adjacent == 1 && col_adjacent == 1) {
		board[row_space][col_space] = tile;
		board[row_tile][col_tile] = -1;
	}
}",1
yayo322,1696227933,1,"void Swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}


void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRow, tileCol, emptyRow, emptyCol;
    
    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol);
    
    
    if ((abs(tileRow - emptyRow) == 1 && tileCol == emptyCol) || 
        (abs(tileCol - emptyCol) == 1 && tileRow == emptyRow)) {
        
        Swap(&board[tileRow][tileCol], &board[emptyRow][emptyCol]);
    }
}",1
ybha528,1696199812,1,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

{

    int rowPos = 0;
    int colPos = 0;
    int rowSelected = 0;
    int colSelected = 0;


    FindTile(board, -1, &rowPos, &colPos);
    FindTile(board, tile, &rowSelected, &colSelected);

    int rowDiff = rowPos - rowSelected;
    int colDiff = colPos - colSelected;

    if (((rowDiff == 1 && colDiff == 0) || rowDiff == -1 && colDiff == 0) || (rowDiff == 0 && colDiff == 1) || (rowDiff == 0 && colDiff == -1))
    {
        board[rowPos][colPos] = tile;
        board[rowSelected][colSelected] = -1;
        }
}",0
ybha528,1696221422,2,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    
    int rowPos;
    int colPos;
    int row;
    int col;
    
    
    FindTile(board, -1, &row, &col);
    FindTile(board, tile, &rowPos, &colPos);
    
    
    
    int rowDiff = rowPos - row;
    int colDiff = colPos - col;


   if (((rowDiff == 1 && colDiff == 0) || (rowDiff == -1 && colDiff == 0) || (rowDiff == 0 && colDiff == 1) || (rowDiff == 0 && colDiff == -1)))
    {
        int temp = board[rowPos][colPos];
        board[rowPos][colPos] = board[row][col];
        board[row][col] = temp;
        }

}",1
ycho749,1695940729,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col;
    FindTile(board, tile, &row, &col);
    printf(""Tile(%d) is located at - row: %d | col: %d \n"", tile, row, col);
    printf(""Checking is tile is adjacent to the empty square..."");
 
    if(isValidPos(row, col-1, NUM_ROWS, NUM_COLS))
    {
        //move left
        if(board[row][col-1] == -1)
        {
            int temp;
            temp = board[row][col-1];
            board[row][col-1] = board[row][col];
            board[row][col] = temp;
        }
    }
 
    if(isValidPos(row, col+1, NUM_ROWS, NUM_COLS))
    {
        //move right
        if(board[row][col+1] == -1)
        {
            int temp;
            temp = board[row][col+1];
            board[row][col+1] = board[row][col];
            board[row][col] = temp;
        }
    }
 
    if(isValidPos(row-1, col, NUM_ROWS, NUM_COLS))
    {
        //move top
        if(board[row-1][col] == -1)
        {
            int temp;
            temp = board[row-1][col];
            board[row-1][col] = board[row][col];
            board[row][col] = temp;
        }
    }
 
    if(isValidPos(row+1, col, NUM_ROWS, NUM_COLS))
    {
        //move left
        if(board[row+1][col] == -1)
        {
            int temp;
            temp = board[row+1][col];
            board[row+1][col] = board[row][col];
            board[row][col] = temp;
        }
    }
 
}
 
void FindTile(int board[NUM_ROWS][NUM_COLS], int tileToFind, int *rowPos, int *colPos)
{
    for(int i = 0; i < NUM_ROWS; i++)
    {
        for(int j = 0; j < NUM_COLS; j++)
        {
            if(board[i][j] == tileToFind)
            {
                *rowPos = i;
                *colPos = j;  
            }
        }
    }
 
}
 
 
int isValidPos(int i, int j, int n, int m)
{
    if (i < 0 || j < 0 || i > n - 1 || j > m - 1)
        return 0;
    return 1;
}
 
void PrintBoard(int board[NUM_ROWS][NUM_COLS])
{
    for(int i = 0; i < NUM_ROWS; i++)
    {
        printf(""\n"");
        for(int j = 0; j < NUM_COLS; j++)
        {
            if(board[i][j]==-1){
                printf(""_ "");
            }else{
                printf(""%d "",board[i][j]);
            }
            
        }
    }
}",0
ycho749,1695949975,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowTilePos = 0;
    int colTilePos = 0;
    FindTile(board,tile,&rowTilePos,&colTilePos);

    int rowEmptyPos = 0;
    int colEmptyPos = 0;
    FindTile(board,-1,&rowEmptyPos,&colEmptyPos);

    if ((rowEmptyPos == rowTilePos && (colEmptyPos == colTilePos + 1 || colEmptyPos == colTilePos - 1)) || 
        (colEmptyPos == colTilePos && (rowEmptyPos == rowTilePos + 1 || rowEmptyPos== rowTilePos -1))) {
        board[rowEmptyPos][colEmptyPos] = board[rowTilePos][colTilePos];
        board[rowTilePos][colTilePos] = -1; 
     }
}",1
ycho760,1696241092,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowTile,colTile,rowEmpty,colEmpty;
	FindTile(board, tile, &rowTile, &colTile);
	FindTile(board, -1, &rowEmpty, &colEmpty);
	if (rowTile == rowEmpty + 1 && colTile == colEmpty || rowTile == rowEmpty - 1 && colTile == colEmpty || rowTile == rowEmpty && colTile == colEmpty + 1 || rowTile == rowEmpty && colTile == colEmpty - 1) {
		board[rowTile][colTile] = -1;
		board[rowEmpty][colEmpty] = tile;
	}

}",0
ycho760,1696241237,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowTile,colTile,rowEmpty,colEmpty;
	FindTile(board, tile, &rowTile, &colTile);
	FindTile(board, -1, &rowEmpty, &colEmpty);
	if ((rowTile == rowEmpty + 1 && colTile == colEmpty) || (rowTile == rowEmpty - 1 && colTile == colEmpty) || (rowTile == rowEmpty && colTile == colEmpty + 1) || (rowTile == rowEmpty && colTile == colEmpty - 1)) {
		board[rowTile][colTile] = -1;
		board[rowEmpty][colEmpty] = tile;
	}

}",1
ydai729,1696239611,1,"#include <stdio.h>


// Function to find the tile and return its row and column positions
void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos) {
    for (int row = 0; row < NUM_ROWS; row++) {
        for (int col = 0; col < NUM_COLS; col++) {
            if (board[row][col] == tile) {
                // Tile found, store the row and column positions
                *rowPos = row;
                *colPos = col;
                return;  // Exit the function
            }
        }
    }

    // Tile not found, set both positions to -1 to indicate not found
    *rowPos = -1;
    *colPos = -1;
}

// Function to make a move by swapping the specified tile with the empty square
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int rowPosition, colPosition;
    FindTile(board, tile, &rowPosition, &colPosition);

    // Check if the tile is adjacent to the empty square
    if (rowPosition != -1 && colPosition != -1) {
        // Check if the tile is above, below, left, or right of the empty square
        if ((rowPosition == rowPosition - 1 && colPosition == colPosition) ||  // Above
            (rowPosition == rowPosition + 1 && colPosition == colPosition) ||  // Below
            (rowPosition == rowPosition && colPosition == colPosition - 1) ||  // Left
            (rowPosition == rowPosition && colPosition == colPosition + 1)) {  // Right

            // Swap the specified tile with the empty square
            int emptyRow, emptyCol;
            FindTile(board, -1, &emptyRow, &emptyCol);
            board[emptyRow][emptyCol] = tile;
            board[rowPosition][colPosition] = -1;
        }
    }
}

int main() {
    int board[NUM_ROWS][NUM_COLS] = {
        {1, 2, 3},
        {4, -1, 6},
        {7, 8, 5}
    };

    int tileToMove = 6;

    // Display the initial board
    printf(""Initial Board:\n"");
    for (int row = 0; row < NUM_ROWS; row++) {
        for (int col = 0; col < NUM_COLS; col++) {
            printf(""%2d "", board[row][col]);
        }
        printf(""\n"");
    }

    // Make the move
    MakeMove(board, tileToMove);

    // Display the updated board after the move
    printf(""\nUpdated Board:\n"");
    for (int row = 0; row < NUM_ROWS; row++) {
        for (int col = 0; col < NUM_COLS; col++) {
            printf(""%2d "", board[row][col]);
        }
        printf(""\n"");
    }

    return 0;
}
",0
ydai729,1696239656,2,"#include <stdio.h>


// Function to find the tile and return its row and column positions
void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos) {
    for (int row = 0; row < NUM_ROWS; row++) {
        for (int col = 0; col < NUM_COLS; col++) {
            if (board[row][col] == tile) {
                // Tile found, store the row and column positions
                *rowPos = row;
                *colPos = col;
                return;  // Exit the function
            }
        }
    }

    // Tile not found, set both positions to -1 to indicate not found
    *rowPos = -1;
    *colPos = -1;
}
    // Make the move
    MakeMove(board, tileToMove);

    // Display the updated board after the move
    printf(""\nUpdated Board:\n"");
    for (int row = 0; row < NUM_ROWS; row++) {
        for (int col = 0; col < NUM_COLS; col++) {
            printf(""%2d "", board[row][col]);
        }
        printf(""\n"");
    }

    return 0;
}
",0
ydai729,1696239690,3,"#include <stdio.h>
// Function to find the tile and return its row and column positions
void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos) {
    for (int row = 0; row < NUM_ROWS; row++) {
        for (int col = 0; col < NUM_COLS; col++) {
            if (board[row][col] == tile) {
                // Tile found, store the row and column positions
                *rowPos = row;
                *colPos = col;
                return;  // Exit the function
            }
        }
    }

",0
ydai729,1696239723,4,"#include <stdio.h>
// Function to find the tile and return its row and column positions
void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos) {
    for (int row = 0; row < NUM_ROWS; row++) {
        for (int col = 0; col < NUM_COLS; col++) {
            if (board[row][col] == tile) {
                // Tile found, store the row and column positions
                *rowPos = row;
                *colPos = col;
                return;  // Exit the function
            }
        }
    }
 // Tile not found, set both positions to -1 to indicate not found
    *rowPos = -1;
    *colPos = -1;
}
",0
ydai729,1696239866,5,"#include <stdio.h>
/ Function to find the tile and return its row and column positions
void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos) {
    for (int row = 0; row < NUM_ROWS; row++) {
        for (int col = 0; col < NUM_COLS; col++) {
            if (board[row][col] == tile) {
                // Tile found, store the row and column positions
                *rowPos = row;
                *colPos = col;
                return;  // Exit the function
            }
        }
    }

    // Tile not found, set both positions to -1 to indicate not found
    *rowPos = -1;
    *colPos = -1;
}

// Function to make a move by swapping the specified tile with the empty square
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int rowPosition, colPosition;
    FindTile(board, tile, &rowPosition, &colPosition);

",0
ydai729,1696239929,6,"#include <stdio.h>
/ Function to find the tile and return its row and column positions
void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos) {
    for (int row = 0; row < NUM_ROWS; row++) {
        for (int col = 0; col < NUM_COLS; col++) {
            if (board[row][col] == tile) {
                // Tile found, store the row and column positions
                *rowPos = row;
                *colPos = col;
                return;  // Exit the function
            }
        }
    }

    // Tile not found, set both positions to -1 to indicate not found
    *rowPos = -1;
    *colPos = -1;
}

",0
ydai729,1696239999,7,"#include <stdio.h>
/ Function to find the tile and return its row and column positions
void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos) {
    for (int row = 0; row < NUM_ROWS; row++) {
        for (int col = 0; col < NUM_COLS; col++) {
            if (board[row][col] == tile) {
                // Tile found, store the row and column positions
                *rowPos = row;
                *colPos = col;
                return;  // Exit the function
            }
        }
    }

    // Tile not found, set both positions to -1 to indicate not found
    *rowPos = -1;
    *colPos = -1;
}
printf(""\nUpdated Board:\n"");
    for (int row = 0; row < NUM_ROWS; row++) {
        for (int col = 0; col < NUM_COLS; col++) {
            printf(""%2d "", board[row][col]);
        }
        printf(""\n"");
    }

    return 0;
}
",0
ydai729,1696240123,8,"#include <stdio.h>

// Function to find the tile and return its row and column positions
void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos) {
    for (int row = 0; row < NUM_ROWS; row++) {
        for (int col = 0; col < NUM_COLS; col++) {
            if (board[row][col] == tile) {
                // Tile found, store the row and column positions
                *rowPos = row;
                *colPos = col;
                return;  // Exit the function
            }
        }
    }

    // Tile not found, set both positions to -1 to indicate not found
    *rowPos = -1;
    *colPos = -1;
}

// Function to make a move by swapping the specified tile with the empty square
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int rowPosition, colPosition;
    FindTile(board, tile, &rowPosition, &colPosition);

    // Check if the tile is adjacent to the empty square
    if (rowPosition != -1 && colPosition != -1) {
        // Check if the tile is above, below, left, or right of the empty square
        if ((rowPosition == rowPosition - 1 && colPosition == colPosition) ||  // Above
            (rowPosition == rowPosition + 1 && colPosition == colPosition) ||  // Below
            (rowPosition == rowPosition && colPosition == colPosition - 1) ||  // Left
            (rowPosition == rowPosition && colPosition == colPosition + 1)) {  // Right

            // Swap the specified tile with the empty square
            int emptyRow, emptyCol;
            FindTile(board, -1, &emptyRow, &emptyCol);
            board[emptyRow][emptyCol] = tile;
            board[rowPosition][colPosition] = -1;
        }
    }
}
",0
ydai729,1696240294,9,"#include <stdio.h>

// Function to find the tile and return its row and column positions
void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos) {
    for (int row = 0; row < NUM_ROWS; row++) {
        for (int col = 0; col < NUM_COLS; col++) {
            if (board[row][col] == tile) {
                // Tile found, store the row and column positions
                *rowPos = row;
                *colPos = col;
                return;  // Exit the function
            }
        }
    }

    // Tile not found, set both positions to -1 to indicate not found
    *rowPos = -1;
    *colPos = -1;
}

",0
ydai729,1696240517,10,"#include <stdio.h>

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int rowPosition, colPosition;
    FindTile(board, tile, &rowPosition, &colPosition);

    int emptyRow, emptyCol;
    FindTile(board, -1, &emptyRow, &emptyCol);

    // Check if the tile is adjacent to the empty square
    if ((rowPosition == emptyRow && colPosition == emptyCol - 1) ||  // Left
        (rowPosition == emptyRow && colPosition == emptyCol + 1) ||  // Right
        (rowPosition == emptyRow - 1 && colPosition == emptyCol) ||  // Above
        (rowPosition == emptyRow + 1 && colPosition == emptyCol)) {  // Below

        // Swap the specified tile with the empty square
        board[emptyRow][emptyCol] = tile;
        board[rowPosition][colPosition] = -1;
    }
}

",1
ydar075,1696584982,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
	int emptyRow, emptyCol;
	int tileRow, tileCol;

	FindTile(board, -1, &emptyRow, &emptyCol);
	FindTile(board, tile, &tileRow, &tileCol);

	if ((tileRow == emptyRow && (tileCol == emptyCol + 1 || tileCol == emptyCol - 1)) ||
		(tileCol == emptyCol && (tileRow == emptyRow + 1 || tileRow == emptyRow - 1))) {
		board[emptyRow][emptyCol] = board[tileRow][tileCol];
		board[tileRow][tileCol] = -1;
	}
	else {
		return;
	}
}",1
yfan919,1696184594,1,"#include <stdio.h>

int MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

{
    int i = 0;
    int j = 0;
    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if (board[i][j] == tile){
                board[i][j+1] = board[i][j];
                board[i][j] = _;
            }
        }
    }
    return board;
}",0
yfan919,1696184620,2,"#include <stdio.h>

int MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

{
    int i = 0;
    int j = 0;
    char a = _;
    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if (board[i][j] == tile){
                board[i][j+1] = board[i][j];
                board[i][j] = a;
            }
        }
    }
    return board;
}",0
yfan919,1696184645,3,"#include <stdio.h>

int MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

{
    int i = 0;
    int j = 0;
    char a = ('_');
    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if (board[i][j] == tile){
                board[i][j+1] = board[i][j];
                board[i][j] = a;
            }
        }
    }
    return board;
}",0
yfan919,1696184654,4,"#include <stdio.h>

int MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

{
    int i = 0;
    int j = 0;
    char a = ('_');
    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if (board[i][j] == tile){
                board[i][j+1] = board[i][j];
                board[i][j] = a;
            }
        }
    }
    return *board;
}",0
yfan919,1696184664,5,"#include <stdio.h>

int MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

{
    int i = 0;
    int j = 0;
    char a = ('_');
    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if (board[i][j] == tile){
                board[i][j+1] = board[i][j];
                board[i][j] = a;
            }
        }
    }
    return board;
}",0
yfan919,1696184680,6,"#include <stdio.h>

int MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

{
    int i = 0;
    int j = 0;
    char a = ('_');
    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if (board[i][j] == tile){
                board[i][j+1] = board[i][j];
                board[i][j] = a;
            }
        }
    }
    return int board;
}",0
yfan919,1696184691,7,"#include <stdio.h>

int MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

{
    int i = 0;
    int j = 0;
    char a = ('_');
    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if (board[i][j] == tile){
                board[i][j+1] = board[i][j];
                board[i][j] = a;
            }
        }
    }
    return (int)board;
}",0
yfan919,1696184735,8,"#include <stdio.h>

int MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

{
    int i = 0;
    int j = 0;
    int a = '_';
    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if (board[i][j] == tile){
                board[i][j+1] = board[i][j];
                board[i][j] = a;
            }
        }
    }
    return board;
}",0
yfan919,1696184777,9,"#include <stdio.h>

int MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

{
    int i = 0;
    int j = 0;
    int a = '_';
    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if (board[i][j] == tile){
                board[i][j+1] = board[i][j];
                board[i][j] = a;
            }
        }
    }
    return board[NUM_ROWS][NUM_COLS];
}",0
yfan919,1696184827,10,"#include <stdio.h>

int MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

{
    int i = 0;
    int j = 0;
    char a = '_';
    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if (board[i][j] == tile){
                board[i][j+1] = board[i][j];
                board[i][j] = a;
            }
        }
    }
    return board[NUM_ROWS][NUM_COLS];
}",0
yfan919,1696185133,11,"#include <stdio.h>

int MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

{
    int i = 0;
    int j = 0;
    char a = '_';
    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if (board[i][j] == tile){
                printf('_');
            }
            board[i][j+1] = tile;
            
        }
    }
    return board[NUM_ROWS][NUM_COLS];
}",0
yfan919,1696185152,12,"#include <stdio.h>

int MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

{
    int i = 0;
    int j = 0;
    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if (board[i][j] == tile){
                printf('_');
            }
            board[i][j+1] = tile;
            
        }
    }
    return board[NUM_ROWS][NUM_COLS];
}",0
yfan919,1696185229,13,"#include <stdio.h>

int MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

{
    int i = 0;
    int j = 0;
    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if (board[i][j] == tile){
                printf('_');
                board[i][j+1] = tile;
            }
            
            
        }
    }
    return board[NUM_ROWS][NUM_COLS];
}",0
yfan919,1696185400,14,"#include <stdio.h>

int MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

{
    int i = 0;
    int j = 0;
    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if (board[i][j] == tile){
                board[i][j]('_');
                board[i][j+1] = tile;
            }
            
            
        }
    }
    return board[NUM_ROWS][NUM_COLS];
}",0
yfan919,1696185409,15,"#include <stdio.h>

int MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

{
    int i = 0;
    int j = 0;
    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if (board[i][j] == tile){
                board[i][j]=('_');
                board[i][j+1] = tile;
            }
            
            
        }
    }
    return board[NUM_ROWS][NUM_COLS];
}",0
yfan919,1696185580,16,"#include <stdio.h>

int MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

{
    int i = 0;
    int j = 0;
    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if (board[i][j] == tile){
                board[i][j] = char('_');
                board[i][j+1] = tile;
            }
            
            
        }
    }
    return board[NUM_ROWS][NUM_COLS];
}",0
yfan919,1696185589,17,"#include <stdio.h>

int MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

{
    int i = 0;
    int j = 0;
    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if (board[i][j] == tile){
                board[i][j] = (char)('_');
                board[i][j+1] = tile;
            }
            
            
        }
    }
    return board[NUM_ROWS][NUM_COLS];
}",0
yfan919,1696185724,18,"#include <stdio.h>

int MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

{
    int i = 0;
    int j = 0;
    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if (board[i][j] == tile){
                board[i][j] = -1;
                board[i][j+1] = tile;
            }
            
            
        }
    }
    return board[NUM_ROWS][NUM_COLS];
}",0
yfan919,1696185765,19,"#include <stdio.h>

int MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

{
    int i = 0;
    int j = 0;
    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if (board[i][j] == tile){
                board[i][j] = -1;
            }
            board[i][j]=tile;
            
        }
    }
    return board[NUM_ROWS][NUM_COLS];
}",0
yfan919,1696185774,20,"#include <stdio.h>

int MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

{
    int i = 0;
    int j = 0;
    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if (board[i][j] == tile){
                board[i][j] = -1;
            }
            board[i][j+1]=tile;
            
        }
    }
    return board[NUM_ROWS][NUM_COLS];
}",0
yfan919,1696185788,21,"#include <stdio.h>

int MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

{
    int i = 0;
    int j = 0;
    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if (board[i][j] == tile){
                board[i][j] = -1;
                board[i][j+1]=tile;
            }
            
            
        }
    }
    return board[NUM_ROWS][NUM_COLS];
}",0
yfan919,1696185879,22,"#include <stdio.h>

int MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

{
    int i = 0;
    int j = 0;
    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if (board[i][j] == tile){
                board[i][j+1]=tile;
                board[i][j] = -1;
                
            }
            
            
        }
    }
    return board[NUM_ROWS][NUM_COLS];
}",0
yfan919,1696186329,23,"#include <stdio.h>

int MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

{
    int i = 0;
    int j = 0;
    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if (board[i][j] == tile){
                board[i][j+1]=tile;
                board[i][j] = -1;
                return board[i][j];
                return board[i][j+1];
                
            }
            
            
        }
    }
    return board[NUM_ROWS][NUM_COLS];
}",0
yfan919,1696186368,24,"#include <stdio.h>

int MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

{
    int i = 0;
    int j = 0;
    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if (board[i][j] == tile){
                board[i+1][j]=tile;
                board[i][j] = -1;
                return board[i][j];
                return board[i+1][j];
                
            }
            
            
        }
    }
    return board[NUM_ROWS][NUM_COLS];
}",0
yfan919,1696186468,25,"#include <stdio.h>

int MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

{
    int i = 0;
    int j = 0;
    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if (board[i][j] == tile){
                board[i+1][j]=tile;
                board[i][j] = -1;
                return board[i][j];
                return board[i+1][j];
                
            }
            if (board[i][j]==-1)
            board[i][j]=('-1');
            
            
        }
    }
    return board[NUM_ROWS][NUM_COLS];
}",0
yfan919,1696186479,26,"#include <stdio.h>

int MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

{
    int i = 0;
    int j = 0;
    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if (board[i][j] == tile){
                board[i+1][j]=tile;
                board[i][j] = -1;
                return board[i][j];
                return board[i+1][j];
                
            }
            if (board[i][j]==-1)
            board[i][j]= -1;
            
            
        }
    }
    return board[NUM_ROWS][NUM_COLS];
}",0
yfan919,1696186519,27,"#include <stdio.h>

int MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

{
    int i = 0;
    int j = 0;
    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if (board[i][j] == tile){
                board[i+1][j]=tile;
                board[i][j] = -1;
                return board[i][j];
                return board[i+1][j];
                
            }
            if (board[i][j]==-1)
            return -1;
            
            
        }
    }
    return board[NUM_ROWS][NUM_COLS];
}",0
yfan919,1696186530,28,"#include <stdio.h>

int MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

{
    int i = 0;
    int j = 0;
    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if (board[i][j] == tile){
                board[i+1][j]=tile;
                board[i][j] = -1;
                return board[i][j];
                return board[i+1][j];
                
            }
            if (board[i][j]==-1)
            return int '-1';
            
            
        }
    }
    return board[NUM_ROWS][NUM_COLS];
}",0
yfan919,1696186536,29,"#include <stdio.h>

int MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

{
    int i = 0;
    int j = 0;
    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if (board[i][j] == tile){
                board[i+1][j]=tile;
                board[i][j] = -1;
                return board[i][j];
                return board[i+1][j];
                
            }
            if (board[i][j]==-1)
            return  '-1';
            
            
        }
    }
    return board[NUM_ROWS][NUM_COLS];
}",0
yfan919,1696186564,30,"#include <stdio.h>

int MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

{
    int i = 0;
    int j = 0;
    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if (board[i][j] == tile){
                board[i+1][j]=tile;
                board[i][j] = -1;
                return board[i][j];
                return board[i+1][j];
                
            }
            if (board[i][j]==-1)
            return board[i][j];
            
            
        }
    }
    return board[NUM_ROWS][NUM_COLS];
}",0
yfan919,1696186758,31,"#include <stdio.h>

int MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

{
    int i = 0;
    int j = 0;
    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if (board[i][j] == tile){
                board[i+1][j]=tile;
                board[i][j] = -1;
                return board[i][j];
                return board[i+1][j];
                
            }
            if (board[i][j]==-1)
            return int(-1);
            
            
        }
    }
    return board[NUM_ROWS][NUM_COLS];
}",0
yfan919,1696186887,32,"#include <stdio.h>

int MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

{
    int i = 0;
    int j = 0;
    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if (board[i][j] == tile){
                board[i+1][j]=tile;
                board[i][j] = -1;
                return board[i][j];
                return board[i+1][j];
                
            }
            if (board[i][j]==-1)
            board[i][j] = ''\0';
            return board[i][j];
            
            
        }
    }
    return board[NUM_ROWS][NUM_COLS];
}",0
yfan919,1696186901,33,"#include <stdio.h>

int MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

{
    int i = 0;
    int j = 0;
    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if (board[i][j] == tile){
                board[i+1][j]=tile;
                board[i][j] = -1;
                return board[i][j];
                return board[i+1][j];
                
            }
            if (board[i][j]==-1)
            board[i][j] = '\0';
            return board[i][j];
            
            
        }
    }
    return board[NUM_ROWS][NUM_COLS];
}",0
yfan919,1696186966,34,"#include <stdio.h>

int MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

{
    int i = 0;
    int j = 0;
    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if (board[i][j]==-1){
                board[i][j] = '\0';
                return board[i][j];
            }
            if (board[i][j] == tile){
                board[i+1][j]=tile;
                board[i][j] = -1;
                return board[i][j];
                return board[i+1][j];
                
            }
            
            
            
        }
    }
    return board[NUM_ROWS][NUM_COLS];
}",0
yfan919,1696187202,35,"#include <stdio.h>

int MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

{
    int i = 0;
    int j = 0;
    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if (board[i][j]==tile && board[i-1][j]==-1){
                board[i][j] = -1;
                board[i-1][j] = tile;
                return board[i][j];
                return board[i-1][j];
            }
            if (board[i][j] == tile && board[i+1][j]==-1){
                board[i+1][j]=tile;
                board[i][j] = -1;
                return board[i][j];
                return board[i+1][j];
                
            }
            
            
            
        }
    }
    return board[NUM_ROWS][NUM_COLS];
}",0
yfan919,1696187280,36,"#include <stdio.h>

int MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

{
    int i = 0;
    int j = 0;
    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if (board[i][j]==tile && board[i-1][j]==-1){
                board[i][j] = -1;
                board[i-1][j] = tile;
                return board[i][j];
                return board[i-1][j];
            }
            if (board[i][j] == tile && board[i+1][j]==-1){
                board[i+1][j]=tile;
                board[i][j] = -1;
                return board[i][j];
                return board[i+1][j];
            }
            if (board[i][j] == tile && board[i][j+1]==-1){
                board[i][j+1]=tile;
                board[i][j] = -1;
                return board[i][j];
                return board[i][j+1];
            }
            if (board[i][j] == tile && board[i][j-1]==-1){
                board[i][j-1]=tile;
                board[i][j] = -1;
                return board[i][j];
                return board[i][j-1];
            }
            
            
            
        }
    }
    return board[NUM_ROWS][NUM_COLS];
}",0
yfan919,1696187428,37,"#include <stdio.h>

int MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)

{
    int i = 0;
    int j = 0;
    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if (board[i][j]==tile && board[i-1][j]==-1){
                board[i][j] = -1;
                board[i-1][j] = tile;
                return board[i][j];
                return board[i-1][j];
            }
            if (board[i][j] == tile && board[i+1][j]==-1){
                board[i+1][j]=tile;
                board[i][j] = -1;
                return board[i][j];
                return board[i+1][j];
            }
            if (board[i][j] == tile && board[i][j+1]==-1){
                board[i][j+1]=tile;
                board[i][j] = -1;
                return board[i][j];
                return board[i][j+1];
            }
            if (board[i][j] == tile && board[i][j-1]==-1){
                board[i][j-1]=tile;
                board[i][j] = -1;
                return board[i][j];
                return board[i][j-1];
                
            }
            if (board[i][j] == tile && board[i+1][j+1]==-1){
                board[i+1][j+1]=tile;
                board[i][j] = -1;
                return board[i][j];
                return board[i+1][j+1];
            }
            if (board[i][j] == tile && board[i+1][j-1]==-1){
                board[i+1][j-1]=tile;
                board[i][j] = -1;
                return board[i][j];
                return board[i+1][j-1];
            }
            if (board[i][j] == tile && board[i+1][j]==-1){
                board[i-1][j+1]=tile;
                board[i][j] = -1;
                return board[i][j];
                return board[i-1][j+1];
            }
            if (board[i][j] == tile && board[i+1][j-1]==-1){
                board[i-1][j-1]=tile;
                board[i][j] = -1;
                return board[i][j];
                return board[i-1][j-1];
            }
            
            
            
        }
    }
    return board[NUM_ROWS][NUM_COLS];
}",0
yfen481,1695699985,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row,col;
    int tileRow=-1,tileCol=-1,emptyRow=-1,emptyCol=-1;
    FindTile(board, tile, &row, &col);
    tileRow=row;
    tileCol=col;
    
    FindTile(board, -1, &row, &col);
    emptyRow=row;
    emptyCol=col;
    
    if (board[tileRow-1][tileCol]==board[emptyRow][emptyCol] || board[tileRow+1][tileCol]==board[emptyRow][emptyCol] || board[tileRow][tileCol-1]==board[emptyRow][emptyCol] || board[tileRow][tileCol+1]==board[emptyRow][emptyCol]){
        board[emptyRow][emptyCol]=tile;
        board[tileRow][tileCol]=-1;

    }
    return;
}",0
yfen481,1695775016,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int tileRow = -1, tileCol = -1, emptyRow = -1, emptyCol = -1, space;
    if (tile>0){
    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol);

    if ((tileRow == emptyRow && (tileCol == emptyCol + 1 || tileCol == emptyCol - 1)) ||
        (tileCol == emptyCol && (tileRow == emptyRow + 1 || tileRow == emptyRow - 1))) {
            space=board[emptyRow][emptyCol];
            board[emptyRow][emptyCol] = tile;
            board[tileRow][tileCol] = space;
    }
    return;
}
}",1
yhaf839,1695790921,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    
    int emptyrow;
    int emptycol;
    int tilerow;
    int tilecol;
    
FindTile(board, -1, &emptyrow, &emptycol);
FindTile(board, tile, &tilerow, &tilecol);
    
    if (((tilerow == emptyrow + 1 || tilerow == emptyrow - 1) && emptycol == tilecol) || ((tilecol == emptycol + 1 || tilecol == emptycol - 1) && emptyrow == tilerow)) {
        
        board[emptyrow][emptycol] = tile;
        board[tilerow][tilecol] = -1;
    }
}
",1
yilm466,1695883515,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int i,j,row,col;

    int tile_row, tile_col, emp_tile_row, emp_tile_col;

    FindTile(board, tile, &tile_row, &tile_col);
    FindTile(board, -1, &emp_tile_row, &emp_tile_col);

    if ((tile_row == emp_tile_row + 1) || (tile_row == emp_tile_row - 1) || (tile_col == emp_tile_col + 1) || (tile_col == emp_tile_col - 1)){
        int x = tile_row;
        int y = tile_col;

        int x_empt = emp_tile_row;
        int y_empt = emp_tile_col;
        board[x][y] = -1;
        board[x_empt][y_empt] = tile;

    }


    for (i = 0; i<NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            
        }
    }


}",0
yilm466,1695883610,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int tile_row, tile_col, emp_tile_row, emp_tile_col;

    FindTile(board, tile, &tile_row, &tile_col);
    FindTile(board, -1, &emp_tile_row, &emp_tile_col);

    if ((tile_row == emp_tile_row + 1) || (tile_row == emp_tile_row - 1) || (tile_col == emp_tile_col + 1) || (tile_col == emp_tile_col - 1)){
        int x = tile_row;
        int y = tile_col;

        int x_empt = emp_tile_row;
        int y_empt = emp_tile_col;
        board[x][y] = -1;
        board[x_empt][y_empt] = tile;

    }
    }",0
yilm466,1696233891,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int tile_row, tile_col, emp_tile_row, emp_tile_col;
    FindTile(board, tile, &tile_row, &tile_col);
    FindTile(board, -1, &emp_tile_row, &emp_tile_col);
    if (tile_row == emp_tile_row)
    {
        if (tile_col - emp_tile_col == 1 || emp_tile_col - tile_col == 1)
        {

            board[tile_row][tile_col] = -1;
            board[emp_tile_row][emp_tile_col] = tile;
            return;
        }
    }

    if (tile_col == emp_tile_col)
    {
        if (tile_row - emp_tile_row == 1 || emp_tile_row - tile_row == 1)
        {
            board[tile_row][tile_col] = -1;
            board[emp_tile_row][emp_tile_col] = tile;
            return;
        }
    }
}

    }",0
yilm466,1696233938,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int tile_row, tile_col, emp_tile_row, emp_tile_col;
    FindTile(board, tile, &tile_row, &tile_col);
    FindTile(board, -1, &emp_tile_row, &emp_tile_col);
    if (tile_row == emp_tile_row)
    {
        if (tile_col - emp_tile_col == 1 || emp_tile_col - tile_col == 1)
        {

            board[tile_row][tile_col] = -1;
            board[emp_tile_row][emp_tile_col] = tile;
            return;
        }
    }

    if (tile_col == emp_tile_col)
    {
        if (tile_row - emp_tile_row == 1 || emp_tile_row - tile_row == 1)
        {
            board[tile_row][tile_col] = -1;
            board[emp_tile_row][emp_tile_col] = tile;
            return;
        }
    }
}
",1
yjun129,1695681122,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j;
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == -1) {
				if (board[i + 1][j] == tile)
				{
					board[i][j] = board[i + 1][j];
					board[i + 1][j] = -1;
				}
				else if (board[i + 1][j + 1] == tile) {
					board[i][j] = board[i + 1][j + 1];
					board[i + 1][j + 1] = -1;
				}
				else if (board[i - 1][j] == tile) {
					board[i][j] = board[i - 1][j];
					board[i - 1][j] = -1;
				}
				else if (board[i - 1][j + 1] == tile) {
					board[i][j] = tile;
					board[i - 1][j + 1] = -1;
				}
				else if (board[i][j + 1] == tile) {
					board[i][j] = board[i][j + 1];
					board[i][j + 1] = -1;
				}
				else if (board[i][j - 1] == tile) {
					board[i][j] = board[i][j - 1];
					board[i][j - 1] = -1;
				}
				else if (board[i - 1][j - 1] == tile) {
					board[i][j] = board[i - 1][j - 1];
					board[i - 1][j - 1] = -1;
				}
				else if (board[i + 1][j - 1] == tile) {
					board[i][j] = board[i + 1][j - 1];
					board[i + 1][j - 1] = -1;
				}
				return;
			}
		}
	}
}",0
yjun129,1695681674,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j;
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == -1){
				if (board[i + 1][j] == tile)
				{
					board[i][j] = board[i + 1][j];
					board[i + 1][j] = -1;
				}
				else if (board[i - 1][j] == tile) {
					board[i][j] = board[i - 1][j];
					board[i - 1][j] = -1;
				}
				else if (board[i][j + 1] == tile) {
					board[i][j] = board[i][j + 1];
					board[i][j + 1] = -1;
				} 
				else if (board[i][j - 1] == tile) {
					board[i][j] = board[i][j - 1];
					board[i][j - 1] = -1;
				}
				return;
				}
		}
	}
}",0
yjun129,1695691438,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j;
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == -1) {
				/*1*/
				if (i != 0 && j != 0 && i != NUM_ROWS - 1 && j != NUM_COLS - 1) {
					if (board[i + 1][j] == tile){
						board[i][j] = board[i + 1][j];
						board[i + 1][j] = -1;
					}
					else if (board[i - 1][j] == tile) {
						board[i][j] = board[i - 1][j];
						board[i - 1][j] = -1;
					}
					else if (board[i][j + 1] == tile) {
						board[i][j] = board[i][j + 1];
						board[i][j + 1] = -1;
					}
					else if (board[i][j - 1] == tile) {
						board[i][j] = board[i][j - 1];
						board[i][j - 1] = -1;
					}
				}
				/*2*/
				else if (i == 0 && j != 0 && j != NUM_COLS - 1) {
					if (board[i + 1][j] == tile) {
						board[i][j] = board[i + 1][j];
						board[i + 1][j] = -1;
					}
					else if (board[i][j + 1] == tile) {
						board[i][j] = board[i][j + 1];
						board[i][j + 1] = -1;
					}
					else if (board[i][j - 1] == tile) {
						board[i][j] = board[i][j - 1];
						board[i][j - 1] = -1;
					}
				}
				/*3*/
				else if (i != 0 && j == 0 && i != NUM_ROWS - 1) {
					if (board[i + 1][j] == tile) {
						board[i][j] = board[i + 1][j];
						board[i + 1][j] = -1;
					}
					else if (board[i - 1][j] == tile) {
						board[i][j] = board[i - 1][j];
						board[i - 1][j] = -1;
					}
					else if (board[i][j + 1] == tile) {
						board[i][j] = board[i][j + 1];
						board[i][j + 1] = -1;
					}
				}
				/*4*/
				else if (i == 0 && j == 0) {
					if (board[i + 1][j] == tile) {
						board[i][j] = board[i + 1][j];
						board[i + 1][j] = -1;
					}
					else if (board[i][j + 1] == tile) {
						board[i][j] = board[i][j + 1];
						board[i][j + 1] = -1;
					}
				}
				/*5*/
				else if (i == 0 && j == NUM_COLS - 1) {
					if (board[i + 1][j] == tile) {
						board[i][j] = board[i + 1][j];
						board[i + 1][j] = -1;
					}
					else if (board[i][j - 1] == tile) {
						board[i][j] = board[i][j - 1];
						board[i][j - 1] = -1;
					}
				}
				/*6*/
				else if (i != 0 && j == NUM_COLS -1 && i != NUM_ROWS - 1) {
					if (board[i + 1][j] == tile) {
						board[i][j] = board[i + 1][j];
						board[i + 1][j] = -1;
					}
					else if (board[i - 1][j] == tile) {
						board[i][j] = board[i - 1][j];
						board[i - 1][j] = -1;
					}
					else if (board[i][j - 1] == tile) {
						board[i][j] = board[i][j - 1];
						board[i][j - 1] = -1;
					}
				}
				/*7*/
				else if (i == NUM_ROWS - 1 && j == 0) {;
					if (board[i - 1][j] == tile) {
						board[i][j] = board[i - 1][j];
						board[i - 1][j] = -1;
					}
					else if (board[i][j + 1] == tile) {
						board[i][j] = board[i][j + 1];
						board[i][j + 1] = -1;
					}
				}
				/*8*/
				else if (i == NUM_ROWS - 1 && j != 0 && j != NUM_COLS - 1) {
					if (board[i - 1][j] == tile) {
						board[i][j] = board[i - 1][j];
						board[i - 1][j] = -1;
					}
					else if (board[i][j + 1] == tile) {
						board[i][j] = board[i][j + 1];
						board[i][j + 1] = -1;
					}
					else if (board[i][j - 1] == tile) {
						board[i][j] = board[i][j - 1];
						board[i][j - 1] = -1;
					}
				}
				/*9*/
				else if (i == NUM_ROWS - 1 && j == NUM_COLS - 1) {
					if (board[i - 1][j] == tile) {
						board[i][j] = board[i - 1][j];
						board[i - 1][j] = -1;
					}
					else if (board[i][j - 1] == tile) {
						board[i][j] = board[i][j - 1];
						board[i][j - 1] = -1;
					}
				}
			}
		}
	}
}",0
yjun129,1695692461,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i, j;
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == -1) {
					/* 4 2 5
					   3 1 6
					   7 8 9 */

					   /*1*/
				if (i != 0 && j != 0 && i != NUM_ROWS - 1 && j != NUM_COLS - 1) {
					if (board[i + 1][j] == tile) {
						board[i][j] = board[i + 1][j];
						board[i + 1][j] = -1;
					}
					else if (board[i - 1][j] == tile) {
						board[i][j] = board[i - 1][j];
						board[i - 1][j] = -1;
					}
					else if (board[i][j + 1] == tile) {
						board[i][j] = board[i][j + 1];
						board[i][j + 1] = -1;
					}
					else if (board[i][j - 1] == tile) {
						board[i][j] = board[i][j - 1];
						board[i][j - 1] = -1;
					}
				}
				/*2*/
				else if (i == 0 && j != 0 && j != NUM_COLS - 1) {
					if (board[i + 1][j] == tile) {
						board[i][j] = board[i + 1][j];
						board[i + 1][j] = -1;
					}
					else if (board[i][j + 1] == tile) {
						board[i][j] = board[i][j + 1];
						board[i][j + 1] = -1;
					}
					else if (board[i][j - 1] == tile) {
						board[i][j] = board[i][j - 1];
						board[i][j - 1] = -1;
					}
				}
				/*3*/
				else if (i != 0 && j == 0 && i != NUM_ROWS - 1) {
					if (board[i + 1][j] == tile) {
						board[i][j] = board[i + 1][j];
						board[i + 1][j] = -1;
					}
					else if (board[i - 1][j] == tile) {
						board[i][j] = board[i - 1][j];
						board[i - 1][j] = -1;
					}
					else if (board[i][j + 1] == tile) {
						board[i][j] = board[i][j + 1];
						board[i][j + 1] = -1;
					}
				}
				/*4*/
				else if (i == 0 && j == 0) {
					if (board[i + 1][j] == tile) {
						board[i][j] = board[i + 1][j];
						board[i + 1][j] = -1;
					}
					else if (board[i][j + 1] == tile) {
						board[i][j] = board[i][j + 1];
						board[i][j + 1] = -1;
					}
				}
				/*5*/
				else if (i == 0 && j == NUM_COLS - 1) {
					if (board[i + 1][j] == tile) {
						board[i][j] = board[i + 1][j];
						board[i + 1][j] = -1;
					}
					else if (board[i][j - 1] == tile) {
						board[i][j] = board[i][j - 1];
						board[i][j - 1] = -1;
					}
				}
				/*6*/
				else if (i != 0 && j == NUM_COLS - 1 && i != NUM_ROWS - 1) {
					if (board[i + 1][j] == tile) {
						board[i][j] = board[i + 1][j];
						board[i + 1][j] = -1;
					}
					else if (board[i - 1][j] == tile) {
						board[i][j] = board[i - 1][j];
						board[i - 1][j] = -1;
					}
					else if (board[i][j - 1] == tile) {
						board[i][j] = board[i][j - 1];
						board[i][j - 1] = -1;
					}
				}
				/*7*/
				else if (i == NUM_ROWS - 1 && j == 0) {
					;
					if (board[i - 1][j] == tile) {
						board[i][j] = board[i - 1][j];
						board[i - 1][j] = -1;
					}
					else if (board[i][j + 1] == tile) {
						board[i][j] = board[i][j + 1];
						board[i][j + 1] = -1;
					}
				}
				/*8*/
				else if (i == NUM_ROWS - 1 && j != 0 && j != NUM_COLS - 1) {
					if (board[i - 1][j] == tile) {
						board[i][j] = board[i - 1][j];
						board[i - 1][j] = -1;
					}
					else if (board[i][j + 1] == tile) {
						board[i][j] = board[i][j + 1];
						board[i][j + 1] = -1;
					}
					else if (board[i][j - 1] == tile) {
						board[i][j] = board[i][j - 1];
						board[i][j - 1] = -1;
					}
				}
				/*9*/
				else if (i == NUM_ROWS - 1 && j == NUM_COLS - 1) {
					if (board[i - 1][j] == tile) {
						board[i][j] = board[i - 1][j];
						board[i - 1][j] = -1;
					}
					else if (board[i][j - 1] == tile) {
						board[i][j] = board[i][j - 1];
						board[i][j - 1] = -1;
					}
				}
				return;
			}
		}
	}
}",1
ykwa219,1696152284,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;
	int row1, col1;
	FindTile(board, tile, &row1, &col1);
	FindTile(board, -1, &row, &col);
	if ((row1 - row) == 1 || (row1 - row) == -1 || (col1 - col) == 1 || (col1 - col) == -1) {
		int a = board[row][col];
		int b = board[row1][col1];
		int* c = &board[row][col];
		int* d = &board[row1][col1];
		*c = b;
		*d = a;
	}
	if ((col == 0 && col1 == 3) || (col == 3 && col1 == 0)) {
		int a = board[row][col];
		int b = board[row1][col1];
		int* c = &board[row][col];
		int* d = &board[row1][col1];
		*c = b;
		*d = a;
	}
}",1
ylee818,1696145814,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int curow;
    int curcol;
    int nextrow;
    int nextcol;
    
    
    FindTile(board, -1, &nextrow, &nextcol);
    FindTile(board, tile, &curow, &curcol);
    

    if ((nextrow == curow && (nextcol == curcol - 1 || nextcol == curcol + 1)) ||
        (nextcol == curcol && (nextrow == curow - 1 || nextrow == curow + 1))) {

        board[nextrow][nextcol] = tile;
        board[curow][curcol] = -1;
    }
    
    return;
    
}",1
yrah128,1696105721,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol;
    int tileRow, tileCol;

    // Find the positions of the empty square (-1) and the specified tile
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);

    // Check if the tile and empty square are adjacent (horizontally or vertically)
    if ((abs(emptyRow - tileRow) == 1 && emptyCol == tileCol) ||
        (abs(emptyCol - tileCol) == 1 && emptyRow == tileRow)) {
        // Swap the tile and the empty square
        int temp = board[emptyRow][emptyCol];
        board[emptyRow][emptyCol] = board[tileRow][tileCol];
        board[tileRow][tileCol] = temp;
    }
}",1
ysun512,1695894541,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int noR, noC, tileR, tileC;

    for (int row = 0; row < NUM_ROWS; row++) {
        for (int col = 0; col < NUM_COLS; col++) {
            if (board[row][col] == tile) {
                tileR = row;
                tileC = col;
            }

            if (board[row][col] == -1) {
                noR = row;
                noC = col;
            }
        }
    }

    if ((tileR == noR && (tileC == noC + 1 || tileC == noC - 1)) || (tileC == noC && (tileR == noR + 1 || tileR == noR - 1))) {
        board[noR][noC] = tile;
        board[tileR][tileC] = -1;
    }
}",1
ytho155,1695722787,1,"#include <stdio.h>
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row, col, row1, col1;

    // Find the position of the empty tile (-1)
    FindTile(board, -1, &row, &col);

    // Check if the selected tile can be moved
    if (tile == -1) {
        printf(""Invalid move: You cannot move the empty tile.\n"");
        return;
    }

    FindTile(board, tile, &row1, &col1);

    // Check if the selected tile is adjacent to the empty tile
    if ((row == row1 || row == row1+1 || row == row1-1 ) && (col == col1 || col == col1+1 || col == col1-1)){
        // Swap the empty tile (-1) and the selected tile
        board[row][col] = tile;
        board[row1][col1] = -1;
    } else {
        printf(""Invalid move: You can only move adjacent tiles.\n"");
    }
}
",0
ytho155,1695722948,2,"#include <stdio.h>
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row, col, row1, col1;

    // Find the position of the empty tile (-1)
    FindTile(board, -1, &row, &col);

    // Check if the selected tile can be moved
    if (tile == -1) {
        return;
    }

    FindTile(board, tile, &row1, &col1);

    // Check if the selected tile is adjacent to the empty tile
    if ((row == row1 || row == row1+1 || row == row1-1 ) && (col == col1 || col == col1+1 || col == col1-1)){
        // Swap the empty tile (-1) and the selected tile
        board[row][col] = tile;
        board[row1][col1] = -1;
    } else {
        return;
    }
}
",1
ytse120,1695632883,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int origRow,origCol,newRow,newCol;
	for (int i = 0; i<NUM_ROWS; i++) {
		for (int j = 0; j<NUM_COLS; j++) {
			if (board[i][j] == -1) {
				origRow = i;
				origCol = j;
			}
		}
	}

	for (int i = 0; i<NUM_ROWS; i++) {
		for (int j = 0; j<NUM_COLS; j++) {
			if (board[i][j] == tile) {
				newRow = i;
				newCol = j;
			}
		}
	}
	board[origRow][origCol] = tile;
	board[newRow][newCol] = -1;
}",0
ytse120,1695633206,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int origRow,origCol,newRow,newCol;
	for (int i = 0; i<NUM_ROWS; i++) {
		for (int j = 0; j<NUM_COLS; j++) {
			if (board[i][j] == -1) {
				origRow = i;
				origCol = j;
			}
		}
	}
	for (int i = 0; i<NUM_ROWS; i++) {
		for (int j = 0; j<NUM_COLS; j++) {
			if (board[i][j] == tile) {
				newRow = i;
				newCol = j;
			}
		}
	}
	if (((newRow == origRow) && ((newCol == origCol - 1) || (newCol == origCol + 1))) || ((newCol == origCol) && ((newRow == origRow - 1) || (newCol == origRow + 1)))) {
		board[origRow][origCol] = tile;
		board[newRow][newCol] = -1;	
	}
}",0
ytse120,1695633300,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int origRow,origCol,newRow,newCol;
	for (int i = 0; i<NUM_ROWS; i++) {
		for (int j = 0; j<NUM_COLS; j++) {
			if (board[i][j] == -1) {
				origRow = i;
				origCol = j;
			}
		}
	}
	for (int i = 0; i<NUM_ROWS; i++) {
		for (int j = 0; j<NUM_COLS; j++) {
			if (board[i][j] == tile) {
				newRow = i;
				newCol = j;
			}
		}
	}
	if (((newRow == origRow) && ((newCol == origCol - 1) || (newCol == origCol + 1))) || ((newCol == origCol) && ((newRow == origRow - 1) || (newRow == origRow + 1)))) {
		board[origRow][origCol] = tile;
		board[newRow][newCol] = -1;	
	}
}",1
yxie884,1695680341,1,"//Author: Jessica Xie

#include <stdio.h>
#include <stdlib.h>
#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
/*variables:
- board = the 2-dimensional array representing the board (board)
- tile = the value of the tile being searched for */
{

    int i, j, row, col, newrow, newcol, rowdiff, coldiff;
    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){
            if (board[i][j] == tile)
            {
            newrow = i;
            newcol = j;
            }
            
            else if (board[i][j] == -1)
            {
            row = i;
            col = j;
            }

            rowdiff = row - newrow;
            rowdiff = abs(rowdiff);

            coldiff = col - newcol;
            coldiff = abs(coldiff);
            
            if ((rowdiff == 1)&&(coldiff == 0)){
                board[row][col] = tile;
                board[newrow][newcol] = -1;
            } 
            else if ((rowdiff == 0)&&(coldiff == 1)){
                board[row][col] = tile;
                board[newrow][newcol] = -1;
            } 
        }
    }
}
",0
yxie884,1695696987,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
/*variables:
- board = the 2-dimensional array representing the board (board)
- tile = the value of the tile being searched for */
{

int i, j, row, col, newrow, newcol, rowdiff, coldiff;

FindTile(board, -1, &row, &col);
FindTile(board, tile, &newrow, &newcol);

    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){

            rowdiff = row - newrow;
            coldiff = col - newcol;
            
            if ((rowdiff == 1)&&(coldiff == 0)){
                board[row][col] = tile;
                board[newrow][newcol] = -1;
            } 
            else if ((rowdiff == 0)&&(coldiff == 1)){
                board[row][col] = tile;
                board[newrow][newcol] = -1;
            } 
        }
    }
}",0
yxie884,1695697460,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
/*variables:
- board = the 2-dimensional array representing the board (board)
- tile = the value of the tile being searched for */
{

int i, j, row, col, newrow, newcol, rowdiff, coldiff;

FindTile(board, -1, &row, &col);
FindTile(board, tile, &newrow, &newcol);

    for (i = 0; i < NUM_ROWS; i++){
        for (j = 0; j < NUM_COLS; j++){

            rowdiff = row - newrow;
            coldiff = col - newcol;
            
            if ((rowdiff == 1 || rowdiff == -1)&&(coldiff == 0)){
                board[row][col] = tile;
                board[newrow][newcol] = -1;
            } 
            if ((rowdiff == 0)&&(coldiff == 1 || coldiff == -1)){
                board[row][col] = tile;
                board[newrow][newcol] = -1;
            } 
        }
    }
}",1
yyin299,1695871570,1,"#include <stdio.h>
#define NUM_ROWS 4
#define NUM_COLS 4
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row;
    int col;
    FindTile(board, tile, &row, &col);
    if ((row * 4 + col)%4 == 0)
    {
        if (board[row - 1][col] == -1)
        {
            board[row][col] = -1;
            board[row - 1][col] = tile;
        }
        else if(board[row + 1][col] == -1)
        {
            board[row][col] = -1;
            board[row + 1][col] = tile;
        }
        else if(board[row][col + 1] == -1)
        {
            board[row][col] = -1;
            board[row][col + 1] = tile;
        }
    }
    else if((row * 4 + col)%4 == 3)
    {
        if (board[row - 1][col] == -1)
        {
            board[row][col] = -1;
            board[row - 1][col] = tile;
        }
        else if(board[row + 1][col] == -1)
        {
            board[row][col] = -1;
            board[row + 1][col] = tile;
        }
        else if(board[row][col - 1] == -1)
        {
            board[row][col] = -1;
            board[row][col - 1] = tile;
        }
    }
    else
    {
        if (board[row - 1][col] == -1)
        {
            board[row][col] = -1;
            board[row - 1][col] = tile;
        }
        else if(board[row + 1][col] == -1)
        {
            board[row][col] = -1;
            board[row + 1][col] = tile;
        }
        else if(board[row][col - 1] == -1)
        {
            board[row][col] = -1;
            board[row][col - 1] = tile;
        }
        else if(board[row][col + 1] == -1)
        {
            board[row][col] = -1;
            board[row][col + 1] = tile;
        }
    }
}
",1
yyin440,1695780200,1,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos) {
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == tile) {
                *rowPos = i;
                *colPos = j;
                return;  
            }
        }
    }
   
    *rowPos = -1;
    *colPos = -1;
}",0
yyin440,1696218754,2,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int nor, noc, tiler, tilec;
 for (int row = 0; row < NUM_ROWS; row++) {
        for (int col = 0; col < NUM_COLS; col++) {
            if (board[row][col] == tile) {
                tiler = row;
                tilec = col;
            }

            if (board[row][col] == -1) {
                nor = row;
                noc = col;
            }
        }
    }
 if (((tilec == noc && (tiler == nor + 1 || tiler == nor - 1)) | | tiler == nor && (tilec == noc + 1 || tilec == noc - 1)) ) {
        board[nor][noc] = tile;
        board[tiler][tilec] = -1;
    }
}
",0
yyin440,1696218807,3,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int nor, noc, tiler, tilec;
 for (int row = 0; row < NUM_ROWS; row++) {
        for (int col = 0; col < NUM_COLS; col++) {
            if (board[row][col] == tile) {
                tiler = row;
                tilec = col;
            }

            if (board[row][col] == -1) {
                nor = row;
                noc = col;
            }
        }
    }
 if (((tilec == noc && (tiler == nor + 1 || tiler == nor - 1)) || tiler == nor && (tilec == noc + 1 || tilec == noc - 1)) ) {
        board[nor][noc] = tile;
        board[tiler][tilec] = -1;
    }
}
",0
yyin440,1696219734,4,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int nor, noc, tiler, tilec;
 for (int row = 0; row < NUM_ROWS; row++) {
        for (int col = 0; col < NUM_COLS; col++) {
            if (board[row][col] == tile) {
                tiler = row;
                tilec = col;
            }

            if (board[row][col] == -1) {
                nor = row;
                noc = col;
            }
        }
    }
if (((tilec == noc && (tiler == nor + 1 || tiler == nor - 1)) || 
     (tiler == nor && (tilec == noc + 1 || tilec == noc - 1)))) {
    board[nor][noc] = tile;
    board[tiler][tilec] = -1;
}

    }
}
",0
yyin440,1696219878,5,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int nor, noc, tiler, tilec;

    for (int row = 0; row < NUM_ROWS; row++) {
        for (int col = 0; col < NUM_COLS; col++) {
            if (board[row][col] == tile) {
                tiler = row;
                tilec = col;
            }

            if (board[row][col] == -1) {
                nor = row;
                noc = col;
            }
        }
    }

    if (((tilec == noc && (tiler == nor + 1 || tiler == nor - 1)) || 
         (tiler == nor && (tilec == noc + 1 || tilec == noc - 1)))) {
        board[nor][noc] = tile;
        board[tiler][tilec] = -1;
    }
}
",1
yzhe520,1695730093,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int Row, Col, r, c;

	//find the location of the tile to be moved
	FindTile(board, tile, &Row, &Col);

	//find the location of the empty space
	FindTile(board, -1, &r, &c);

	//Test if the empty space is below  the tile
	if ((r == Row + 1) && (c == Col)) 
	{
		//swap them

		Row = Row + 1;
		r = r - 1;
		//write out the new positions
		board[r][c] = -1;
		board[Row][Col] = tile;
		return;
	}

	//if the empty space is above the tile
	if ((r == Row - 1) && (c == Col)) 
	{
		//swap them
		Row = Row - 1;
		r = r + 1;
		//write out the new positions
		board[r][c] = -1;
		board[Row][Col] = tile;
		return;
	}

	//if the empty space is on the right side the tile
	if ((r == Row) && (c == Col + 1)) {
		//swap them
		Col = Col + 1;
		c = c - 1;
		//write out the new positions
		board[r][c] = -1;
		board[Row][Col] = tile;
		return;
	}

	//if the empty space is on the left side the tile
	if ((r == Row) && (c == Col - 1)) {
		//swap them
		Col = Col - 1;
		c = c + 1;
		//write out the new positions
		board[r][c] = -1;
		board[Row][Col] = tile;
		return;
		
	}
}",1
zche975,1696236898,1,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void PrintBoard(int board[NUM_ROWS][NUM_COLS]) {
    for (int i = 0; i < NUM_ROWS; i++) {
        for (int j = 0; j < NUM_COLS; j++) {
            if (board[i][j] == -1) {
                printf(""_ "");
            } else {
                printf(""%2d "", board[i][j]);
            }
        }
        printf(""\n"");
    }
}

void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos) {
    for (int row = 0; row < NUM_ROWS; row++) {
        for (int col = 0; col < NUM_COLS; col++) {
            if (board[row][col] == tile) {
                *rowPos = row;
                *colPos = col;
                return;
            }
        }
    }

    *rowPos = -1;
    *colPos = -1;
}

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRow, tileCol, emptyRow, emptyCol;

    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol);

    if ((tileRow == emptyRow && (tileCol == emptyCol - 1 || tileCol == emptyCol + 1)) ||
        (tileCol == emptyCol && (tileRow == emptyRow - 1 || tileRow == emptyRow + 1))) {
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}",0
zche975,1696236958,2,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos) {
    for (int row = 0; row < NUM_ROWS; row++) {
        for (int col = 0; col < NUM_COLS; col++) {
            if (board[row][col] == tile) {
                *rowPos = row;
                *colPos = col;
                return;
            }
        }
    }

    *rowPos = -1;
    *colPos = -1;
}

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol, tileRow, tileCol;

    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);

    if ((tileRow == emptyRow && (tileCol == emptyCol - 1 || tileCol == emptyCol + 1)) ||
        (tileCol == emptyCol && (tileRow == emptyRow - 1 || tileRow == emptyRow + 1))) {
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}

void PrintBoard(int board[NUM_ROWS][NUM_COLS]) {
    for (int row = 0; row < NUM_ROWS; row++) {
        for (int col = 0; col < NUM_COLS; col++) {
            if (board[row][col] == -1) {
                printf(""_  "");
            } else {
                printf(""%2d "", board[row][col]);
            }
        }
        printf(""\n"");
    }
}",0
zche975,1696236996,3,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void FindTile(int board[NUM_ROWS][NUM_COLS], int tile, int *rowPos, int *colPos);

void PrintBoard(int board[NUM_ROWS][NUM_COLS]);

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol, tileRow, tileCol;

    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);

    if ((tileRow == emptyRow && (tileCol == emptyCol - 1 || tileCol == emptyCol + 1)) ||
        (tileCol == emptyCol && (tileRow == emptyRow - 1 || tileRow == emptyRow + 1))) {
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}",1
zcol623,1695726800,1,"//Author:zcol623
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowPos;
	int colPos;
	int emptyRow; 
	int emptyCol;
	
	FindTile(board, tile, &rowPos, &colPos);//Get position of tile the user wants to move
	FindTile(board, -1, &emptyRow, &emptyCol);//Get position of empty space

	//Check if the tile is adjacent to the empty space
	if (rowPos == emptyRow && (colPos == emptyCol + 1 || colPos == emptyCol - 1) ||colPos == emptyCol && (rowPos == emptyRow + 1 || rowPos == emptyRow - 1)) 
	{
		//Swap the tile with the empty sqaure
		board[emptyRow][emptyCol] = tile;
		board[rowPos][colPos] = -1;
	}
}",0
zcol623,1695727562,2,"//Author:zcol623
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int rowPos, colPos, emptyRow, emptyCol;

	FindTile(board, tile, &rowPos, &colPos);//Get position of tile the user wants to move
	FindTile(board, -1, &emptyRow, &emptyCol);//Get position of empty space

	//Check if the tile is adjacent to the empty space
	if (rowPos == emptyRow && (colPos == emptyCol + 1 || colPos == emptyCol - 1)){
		//Swap the tile with the empty sqaure if the empty square is beside it
		board[emptyRow][emptyCol] = tile;
		board[rowPos][colPos] = -1;
	}
	else if (colPos == emptyCol && (rowPos == emptyRow + 1 || rowPos == emptyRow - 1)) {
		//Swap the tile with the empty sqaure if the empty square is above or below it
		board[emptyRow][emptyCol] = tile;
		board[rowPos][colPos] = -1;
	}
}",1
zfu276,1696075355,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row, col;
	int i,j;
    
    FindTile(board, -1, &row, &col);
	FindTile(board, tile, &i, &j);

 
    if ((row == i - 1 && col == j) ||
    	(row == i + 1 && col == j) ||
        (row == i && col == j - 1) ||
        (row == i && col == j + 1))  {
        
        board[row][col] = board[i][j];
		board[i][j] = -1;
    }
}",1
zgab423,1696241877,1,"#include <stdio.h>

#define NUM_ROWS 4
#define NUM_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int empty_rows;
    int empty_cols;
    int tile_rows;
    int tile_cols;

    FindTile(board, -1, &empty_rows, &empty_cols);
    FindTile(board, tile, &tile_rows, &tile_cols);
    
    if (((empty_rows == tile_rows) && ((empty_cols == tile_cols - 1) || (empty_cols == tile_cols + 1))) || ((empty_cols == tile_cols) && ((empty_rows == tile_rows - 1) || (empty_rows == tile_rows + 1)))) {
   
        int boardPlaceholder = board[empty_rows][empty_cols];
        board[empty_rows][empty_cols] = board[tile_rows][tile_cols];
        board[tile_rows][tile_cols] = boardPlaceholder;
    }
}

",1
zgar110,1696233926,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol, tileRow, tileCol;
    
 
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);
  if ((abs(tileRow - emptyRow) == 1 && tileCol == emptyCol) ||
        (abs(tileCol - emptyCol) == 1 && tileRow == emptyRow)) {
      
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}",1
zgin653,1695629685,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    int gapRow,gapCol,numRow,numCol,temp;

    FindTile(board,-1,&gapRow, &gapCol);
    FindTile(board, tile, &numRow,&numCol);

    if (gapRow - numRow == 1 || gapRow - numRow == -1 || gapCol - numCol == 1 || gapCol - numCol == -1){
        board[gapRow][gapCol] = board[numRow][numCol];
        board[numRow][numCol] = -1;
    }
}",0
zgin653,1695629716,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    int gapRow,gapCol,numRow,numCol;

    FindTile(board,-1,&gapRow, &gapCol);
    FindTile(board, tile, &numRow,&numCol);

    if (gapRow - numRow == 1 || gapRow - numRow == -1 || gapCol - numCol == 1 || gapCol - numCol == -1){
        board[gapRow][gapCol] = board[numRow][numCol];
        board[numRow][numCol] = -1;
    }
}",0
zgin653,1695630237,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    int gapRow,gapCol,numRow,numCol;

    FindTile(board,-1,&gapRow, &gapCol);
    FindTile(board, tile, &numRow,&numCol);

    if (((gapRow - numRow == 1 || gapRow - numRow == -1) && !(gapCol - numCol == 1 || gapCol - numCol == -1)) || (!(gapRow - numRow == 1 || gapRow - numRow == -1) && (gapCol - numCol == 1 || gapCol - numCol == -1))){
        board[gapRow][gapCol] = board[numRow][numCol];
        board[numRow][numCol] = -1;
    }
}",0
zgin653,1695630811,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile){
    int gapRow,gapCol,numRow,numCol;

    FindTile(board,-1,&gapRow, &gapCol);
    FindTile(board, tile, &numRow,&numCol);

    if (((gapRow - numRow == 1 || gapRow - numRow == -1) && gapCol - numCol == 0) || (gapRow - numRow == 0 && (gapCol - numCol == 1 || gapCol - numCol == -1))){
        board[gapRow][gapCol] = board[numRow][numCol];
        board[numRow][numCol] = -1;
    }
}",1
zguo839,1696213480,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow;
    int emptyCol;
    int tileRow;
    int tileCol;
     do {
        FindTile(board, -1, &emptyRow, &emptyCol); 
        FindTile(board, tile, &tileRow, &tileCol); 
        
         if ((abs(tileRow - emptyRow) == 1 && tileCol == emptyCol) || 
            (abs(tileCol - emptyCol) == 1 && tileRow == emptyRow)) {
              board[emptyRow][emptyCol] = tile;
            board[tileRow][tileCol] = -1;
            break; 
        }
    } while (1); 
}",0
zguo839,1696213624,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow;
    int emptyCol;
    int tileRow;
    int tileCol;

    while (1) {
        FindTile(board, -1, &emptyRow, &emptyCol);
        FindTile(board, tile, &tileRow, &tileCol);

        if ((abs(tileRow - emptyRow) == 1 && tileCol == emptyCol) ||
            (abs(tileCol - emptyCol) == 1 && tileRow == emptyRow)) {
            board[emptyRow][emptyCol] = tile;
            board[tileRow][tileCol] = -1;
            break;
        }
    }
}
",0
zguo839,1696213961,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow,emptyCol,tileRow,tileCol;
  while (1) {
        FindTile(board, -1, &emptyRow, &emptyCol);
        FindTile(board, tile, &tileRow, &tileCol);

        if ((abs(tileRow - emptyRow) == 1 && tileCol == emptyCol) ||
            (abs(tileCol - emptyCol) == 1 && tileRow == emptyRow)) {
            board[emptyRow][emptyCol] = tile;
            board[tileRow][tileCol] = -1;
            break;
        }
    }
}
",0
zguo839,1696215120,4,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol, tileRow, tileCol;

    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);

    while (!((abs(tileRow - emptyRow) == 1 && tileCol == emptyCol) ||
             (abs(tileCol - emptyCol) == 1 && tileRow == emptyRow))) {
        printf(""Invalid move! Please enter a valid tile to move: "");
        scanf(""%d"", &tile);
        FindTile(board, tile, &tileRow, &tileCol);
    }

    board[emptyRow][emptyCol] = tile;
    board[tileRow][tileCol] = -1;
}

",0
zguo839,1696215939,5,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int emptyRow, emptyCol, tileRow, tileCol;
    
    FindTile(board, -1, &emptyRow, &emptyCol);
    FindTile(board, tile, &tileRow, &tileCol);
    
    // Check if the tile is adjacent to the empty square
    if ((abs(tileRow - emptyRow) == 1 && tileCol == emptyCol) ||
        (abs(tileCol - emptyCol) == 1 && tileRow == emptyRow)) {
        // Swap the specified tile with the empty square
        board[emptyRow][emptyCol] = tile;
        board[tileRow][tileCol] = -1;
    }
}

",1
zliu381,1695955451,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col;
	int rempty, cempty;
	FindTile(board, tile, &row, &col);
	FindTile(board, -1, &rempty, &cempty);
	if (row > 0) {
		if (board[row - 1][col] == -1) {
			board[row][col] = -1;
			board[row - 1][col] = tile;
		}
	}
	if (row < NUM_ROWS-1) {
		if (board[row + 1][col] == -1) {
			board[row][col] = -1;
			board[row + 1][col] = tile;
		}
	}
	if (col > 0) {
		if (board[row][col-1] == -1) {
			board[row][col] = -1;
			board[row][col-1] = tile;
		}
	}
	if (col < NUM_ROWS-1) {
		if (board[row][col + 1] == -1) {
			board[row][col] = -1;
			board[row][col + 1] = tile;
		}
	}
}",1
zliu578,1696040130,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i;
	int j;
	int poR;
	int poC;
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == tile) {
				poR = i;
				poC = j;
			}
		}
	}
	if (board[poR + 1][poC] == -1) {
		board[poR + 1][poC] = board[poR][poC];
		board[poR][poC] = -1;
	}
	else if (board[poR + 1][poC + 1] == -1) {
		board[poR + 1][poC + 1] = board[poR][poC];
		board[poR][poC] = -1;
	}
	else if (board[poR - 1][poC] == -1) {
		board[poR - 1][poC] = board[poR][poC];
		board[poR][poC] = -1;
	}
	else if (board[poR - 1][poC - 1] == -1) {
		board[poR - 1][poC - 1] = board[poR][poC];
		board[poR][poC] = -1;
	}
	else {
		board[poR][poC] = board[poR][poC];
	}
}",0
zliu578,1696040624,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i;
	int j;
	int poR;
	int poC;
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == tile) {
				poR = i;
				poC = j;
			}
		}
	}
	if (board[poR - 1][poC] == -1) {
		board[poR - 1][poC] = board[poR][poC];
		board[poR][poC] = -1;
	}
	else if (board[poR][poC - 1] == -1) {
		board[poR][poC - 1] = board[poR][poC];
		board[poR][poC] = -1;
	}
	else if (board[poR + 1][poC] == -1) {
		board[poR + 1][poC] = board[poR][poC];
		board[poR][poC] = -1;
	}
	else if (board[poR][poC + 1] == -1) {
		board[poR][poC + 1] = board[poR][poC];
		board[poR][poC] = -1;
	}
	else {
		board[poR][poC] = board[poR][poC];
	}
}",0
zliu578,1696041527,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int i;
	int j;
	int poR;
	int poC;
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == tile) {
				poR = i;
				poC = j;
			}
		}
	}
	if (board[poR - 1][poC] == -1 && poR - 1 >= 0) {
		board[poR - 1][poC] = board[poR][poC];
		board[poR][poC] = -1;
	}
	else if (board[poR][poC - 1] == -1 && poC - 1 >= 0) {
		board[poR][poC - 1] = board[poR][poC];
		board[poR][poC] = -1;
	}
	else if (board[poR + 1][poC] == -1 && poR + 1 >= 0) {
		board[poR + 1][poC] = board[poR][poC];
		board[poR][poC] = -1;
	}
	else if (board[poR][poC + 1] == -1 && poC + 1 >= 0) {
		board[poR][poC + 1] = board[poR][poC];
		board[poR][poC] = -1;
	}
	else {
		board[poR][poC] = board[poR][poC];
	}
}",1
zpen457,1696064446,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int rowPosTo, colPosTo;
    FindTile(board, tile, &rowPosTo, &colPosTo);
    
    int rowPos, colPos;
    FindTile(board, -1, &rowPos, &colPos);
    
    if (rowPos == rowPosTo){
        int diff;
        diff = colPosTo - colPos;
        if (diff == 1 || diff == -1)
        {
            board[rowPos][colPos] = board[rowPosTo][colPosTo];
            board[rowPosTo][colPosTo] = -1;
        }
    }
    else if (colPos == colPosTo){
        int diff;
        diff = rowPosTo - rowPos;
        if (diff == 1 || diff == -1){
            board[rowPos][colPos] = board[rowPosTo][colPosTo];
            board[rowPosTo][colPosTo] = -1;
        }
    }
}",1
zqia091,1696233118,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) 
{
    int tRow, tCol, eRow, eCol;
    FindTile(board, tile, &tRow, &tCol);
    FindTile(board, -1, &eRow, &eCol);
    
    if ((tRow==eRow&&abs(tCol-eCol)==1) ||
        (tCol==eCol&&abs(tRow-eRow)==1)) 
    {
        board[eRow][eCol]=tile;
        board[tRow][tCol]=-1;
    }
}",1
zshi453,1695625627,1,"#include <stdio.h>
#include <stdlib.h>
#define NUM_ROWS 4
#define NUM_COLS 4
int* MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
  int i, j,emptyrow,emptycol,tilerow,tilecol,rowdiff,coldiff;
  for (i = 0; i < NUM_ROWS; ++i){
      for (j = 0; j < NUM_COLS; ++j){
	  if (board[i][j] == tile)
	    {
	      tilerow = i;
	      tilecol = j;
	    }
	    else if (board[i][j] == -1)
	    {
	        emptyrow = i;
	        emptycol = j;
	    }
	}
    }
    rowdiff = tilerow - emptyrow;
    rowdiff = abs(rowdiff);
    coldiff = tilecol - emptycol;
    coldiff = abs(coldiff);
    if ((rowdiff == 1) && (coldiff == 1)){
        board[tilerow][tilecol] = '_'; 
        board[emptyrow][emptycol] = tile;
    } 
    else {
        board[emptyrow][emptycol] = '_';
    }
}
",0
zshi453,1695677641,2,"#include <stdio.h>
#include <stdlib.h>
#define NUM_ROWS 4
#define NUM_COLS 4
int* MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
  int i, j,emptyrow,emptycol,tilerow,tilecol,rowdiff,coldiff;
  for (i = 0; i < NUM_ROWS; ++i){
      for (j = 0; j < NUM_COLS; ++j){
	  if (board[i][j] == tile)
	    {
	      tilerow = i;
	      tilecol = j;
	    }
	    else if (board[i][j] == -1)
	    {
	        emptyrow = i;
	        emptycol = j;
	    }
	}
    }
    rowdiff = tilerow - emptyrow;
    rowdiff = abs(rowdiff);
    coldiff = tilecol - emptycol;
    coldiff = abs(coldiff);
    if (((rowdiff == 1) && (coldiff == 0))||((rowdiff == 0) && (coldiff == 1))){
        board[emptyrow][emptycol] = tile;
        board[tilerow][tilecol] = -1;
    }
}",0
zshi453,1695678492,3,"#include <stdlib.h>
#include <stdio.h>
#define NUM_ROWS 4
#define NUM_COLS 4
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
  int i, j,emptyrow,emptycol,tilerow,tilecol,rowdiff,coldiff;
  for (i = 0; i < NUM_ROWS; ++i){
      for (j = 0; j < NUM_COLS; ++j){
	  if (board[i][j] == tile)
	    {
	      tilerow = i;
	      tilecol = j;
	    }
	    else if (board[i][j] == -1)
	    {
	        emptyrow = i;
	        emptycol = j;
	    }
	}
    }
    rowdiff = tilerow - emptyrow;
    rowdiff = abs(rowdiff);
    coldiff = tilecol - emptycol;
    coldiff = abs(coldiff);
    if (((rowdiff == 1) && (coldiff == 0))||((rowdiff == 0) && (coldiff == 1))){
        board[emptyrow][emptycol] = tile;
        board[tilerow][tilecol] = -1;
    }
}",1
zvor566,1695972836,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row, col, emptyRow, emptyCol;

	FindTile(board, tile, &row, &col);
	FindTile(board, -1, &emptyRow, &emptyCol);
	if (((emptyRow == row + 1) && (emptyCol == col)) ||
		((emptyRow == row - 1) && (emptyCol == col)) ||
		((emptyCol == col + 1) && (emptyRow == row)) ||
		((emptyCol == col - 1) && (emptyRow == row))) {
		board[row][col] = -1;
		board[emptyRow][emptyCol] = tile;
	}

}",1
zwan373,1695719051,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRow, tileCol;
    FindTile(board, tile, tileRow, tileCol);
    int emptyRow, emptyCol;
    FindTile(board, -1, emptyRow, emptyCol);
    if ((tileRow == emptyRow && abs(tileCol - emptyCol) == 1) ||
        (tileCol == emptyCol && abs(tileRow - emptyRow) == 1)) {
        board[tileRow][tileCol] = -1;
        board[emptyRow][emptyCol] = tile;
    }
}",0
zwan373,1695769783,2,"#include <stdio.h>
    #define NUM_ROWS 4
    #define NUM_COLS 4
   void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRow, tileCol;
    FindTile(board, tile, &tileRow, &tileCol);

    int emptyRow, emptyCol;
    FindTile(board, -1, &emptyRow, &emptyCol);
    if ((tileRow == emptyRow && abs(tileCol - emptyCol) == 1) ||
        (tileCol == emptyCol && abs(tileRow - emptyRow) == 1))
    {
        board[tileRow][tileCol] = -1;
        board[emptyRow][emptyCol] = tile;
    }
}",1
zwon694,1695699497,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
	int row_empty, col_empty;
	int row_tile, col_tile;
	int i, j;
	int max = NUM_ROWS - 1;
	FindTile(board, -1, &row_empty, &col_empty);

// identify where the specified tile is
	for (i = 0; i < NUM_ROWS; i++) {
		for (j = 0; j < NUM_COLS; j++) {
			if (board[i][j] == tile) {
				row_tile = i;
				col_tile = j;
			}
		}
	}

// only check adjacent tiles

	if ((row_empty == 0) && (col_empty == 0)) { 
// top left corner
		if ((board[row_empty + 1][col_empty]) == tile) {
			board[row_empty][col_empty] = tile;
			board[row_tile][col_tile] = -1;

		} else if ((board[row_empty][col_empty + 1]) == tile) {
			board[row_empty][col_empty] = tile;
			board[row_tile][col_tile] = -1;
		}

	} else if ((col_empty == 0) && (row_empty == max)) {
// bottom left corner
		if ((board[row_empty][col_empty + 1]) == tile) {
			board[row_empty][col_empty] = tile;
			board[row_tile][col_tile] = -1;

		} else if ((board[row_empty - 1][col_empty]) == tile) {
			board[row_empty][col_empty] = tile;
			board[row_tile][col_tile] = -1;
		}

	} else if ((row_empty == 0) && (col_empty == max)) {
// top right corner
		if ((board[row_empty + 1][col_empty]) == tile) {
			board[row_empty][col_empty] = tile;
			board[row_tile][col_tile] = -1;

		} else if ((board[row_empty][col_empty - 1]) == tile) {
			board[row_empty][col_empty] = tile;
			board[row_tile][col_tile] = -1;
		}

	} else if ((row_empty == max) && ((col_empty == max))) {
// bottom right corner
		if ((board[row_empty - 1][col_empty]) == tile) {
			board[row_empty][col_empty] = tile;
			board[row_tile][col_tile] = -1;			
		} else if ((board[row_empty][col_empty - 1]) == tile) {
			board[row_empty][col_empty] = tile;
			board[row_tile][col_tile] = -1;					
		}

	} else if (row_empty == 0) {
// top border
		if ((board[row_empty + 1][col_empty]) == tile) {
			board[row_empty][col_empty] = tile;
			board[row_tile][col_tile] = -1;

		} else if ((board[row_empty][col_empty + 1]) == tile) {
			board[row_empty][col_empty] = tile;
			board[row_tile][col_tile] = -1;

		} else if ((board[row_empty][col_empty - 1]) == tile) {
			board[row_empty][col_empty] = tile;
			board[row_tile][col_tile] = -1;
		}

	} else if (col_empty == 0) {
// left border
		if ((board[row_empty + 1][col_empty]) == tile) {
			board[row_empty][col_empty] = tile;
			board[row_tile][col_tile] = -1;

		} else if ((board[row_empty][col_empty + 1]) == tile) {
			board[row_empty][col_empty] = tile;
			board[row_tile][col_tile] = -1;

		} else if ((board[row_empty - 1][col_empty]) == tile) {
			board[row_empty][col_empty] = tile;
			board[row_tile][col_tile] = -1;
		}

	} else if (row_empty == max) {
// bottom border
		if ((board[row_empty - 1][col_empty]) == tile) {
			board[row_empty][col_empty] = tile;
			board[row_tile][col_tile] = -1;			
		} else if ((board[row_empty][col_empty - 1]) == tile) {
			board[row_empty][col_empty] = tile;
			board[row_tile][col_tile] = -1;			
		} else if ((board[row_empty][col_empty + 1]) == tile) {
			board[row_empty][col_empty] = tile;
			board[row_tile][col_tile] = -1;			
		}		

	} else if (col_empty == max) {
// right border
		if ((board[row_empty - 1][col_empty]) == tile) {
			board[row_empty][col_empty] = tile;
			board[row_tile][col_tile] = -1;			
		} else if ((board[row_empty][col_empty - 1]) == tile) {
			board[row_empty][col_empty] = tile;
			board[row_tile][col_tile] = -1;			
		} else if ((board[row_empty + 1][col_empty]) == tile) {
			board[row_empty][col_empty] = tile;
			board[row_tile][col_tile] = -1;			
		}		

	} else {
// in the middle
		if ((board[row_empty + 1][col_empty]) == tile) {
			board[row_empty][col_empty] = tile;
			board[row_tile][col_tile] = -1;	

		} else if ((board[row_empty - 1][col_empty]) == tile) {
			board[row_empty][col_empty] = tile;
			board[row_tile][col_tile] = -1;		

		} else if ((board[row_empty][col_empty + 1]) == tile) {
			board[row_empty][col_empty] = tile;
			board[row_tile][col_tile] = -1;	

		} else if ((board[row_empty][col_empty - 1]) == tile) {
			board[row_empty][col_empty] = tile;
			board[row_tile][col_tile] = -1;		

		}
	}
}",1
zwu591,1695961986,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{	
	int emptyRow, emptyCol, row, col;
	FindTile(board, tile, &row, &col);
	FindTile(board, -1, &emptyRow, &emptyCol);

	if (emptyRow == row && (emptyCol == col - 1 || emptyCol == col + 1)) {
		board[row][col] = -1;
		board[emptyRow][emptyCol] = tile;
	} else if (emptyCol == col && (emptyRow == row - 1 || emptyRow == row + 1)) {
		board[row][col] = -1;
		board[emptyRow][emptyCol] = tile;
	}
}",1
zyah987,1696152004,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tile_row, tile_col, empty_row, empty_col;
    
    FindTile(board, tile, &tile_row, &tile_col);
    FindTile(board, -1, &empty_row, &empty_col);
  
    
    int row_diff = tile_row - empty_row;
    int col_diff = tileCol - emptyCol;
    
    if((row_diff == 0 && (col_diff == 1 || col_diff == -1)) || 
       (col_diff == 0 && (row_diff == 1 || row_diff == -1))) {
        board[tile_row][tile_col] = -1;
        board[empty_row][empty_col] = tile;
    }
}
",0
zyah987,1696152026,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tile_row, tile_col, empty_row, empty_col;
    
    FindTile(board, tile, &tile_row, &tile_col);
    FindTile(board, -1, &empty_row, &empty_col);
  
    
    int row_diff = tile_row - empty_row;
    int col_diff = tile_col - empty_col;
    
    if((row_diff == 0 && (col_diff == 1 || col_diff == -1)) || 
       (col_diff == 0 && (row_diff == 1 || row_diff == -1))) {
        board[tile_row][tile_col] = -1;
        board[empty_row][empty_col] = tile;
    }
}
",1
zyao804,1695699244,1,"#include <stdio.h>
#include <stdlib.h>
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row,col,empty_row,empty_col;
    FindTile(board,tile,&row,&col);
    FindTile(board,-1,&empty_row,&empty_col);
    if (abs(empty_row-row) == 1 || abs(empty_col-col) == 1)
    {
        board[empty_row][empty_col] = tile;
        board[row][col] = -1;
    }
}",0
zyao804,1695700074,2,"#include <stdio.h>
#include <stdlib.h>
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row,col,empty_row,empty_col;
    FindTile(board,tile,&row,&col);
    FindTile(board,-1,&empty_row,&empty_col);
    if (abs(empty_row-row) == 1 || abs(empty_col-col) == 1)
    {
        if (row == empty_row || col == empty_col)
        {
           board[empty_row][empty_col] = tile;
           board[row][col] = -1; 
        }
    }
}
",1
zyu100,1695698482,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile)
{
    int row1,row2,col1,col2,row,col;
    if (tile>0){
         FindTile(board, -1, &row, &col);
         row1=row;
         col1=col;
         
         FindTile(board, tile, &row, &col);
         row2=row;
         col2=col;
         
       if ((row1-row2==1 || row2-row1==1) && col1==col2){
          int change= board[row1][col1];
          board[row1][col1]=board[row2][col2];
          board[row2][col2]=change;
       }
       if ((col1-col2==1 || col2-col1==1) && row1==row2){
           int change= board[row1][col1];
          board[row1][col1]=board[row2][col2];
          board[row2][col2]=change;
    }
    return;
}
}
",1
zzho965,1696239998,1,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int rowPos, colPos;
    FindTile(board, tile, &rowPos, &colPos); 

    
    if ((rowPos - 1 >= 0 && board[rowPos - 1][colPos] == -1) ||      // Check above
        (rowPos + 1 < NUM_ROWS && board[rowPos + 1][colPos] == -1) ||
        (colPos - 1 >= 0 && board[rowPos][colPos - 1] == -1) ||
        (colPos + 1 < NUM_COLS && board[rowPos][colPos + 1] == -1)) { 

        board[rowPos][colPos] = -1;
        board[rowPos + 1][colPos] = tile;
    } 
    else {
    }
}",0
zzho965,1696243645,2,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int rowPos, colPos;
    FindTile(board, tile, &rowPos, &colPos); 
   
    if (rowPos - 1 >= 0 && board[rowPos - 1][colPos] == -1) {
        board[rowPos][colPos ] = -1;
        board[rowPos - 1][colPos] = tile;
        }
        
    else if (rowPos + 1 < NUM_ROWS && board[rowPos + 1][colPos] == -1) {
        board[rowPos][colPos ] = -1;
        board[rowPos + 1][colPos] = tile;
        }
        
    else if (colPos - 1 >= 0 && board[rowPos][colPos - 1] == -1) { 
        board[rowPos][colPos ] = -1;
        board[rowPos][colPos - 1] = tile;
        }
        
    else if (colPos + 1 < NUM_COLS && board[rowPos][colPos + 1] == -1) { 
        board[rowPos][colPos ] = -1;
        board[rowPos][colPos - 1] = tile;
        }


    else {
        
    }
}
",0
zzho965,1696243729,3,"void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int rowPos, colPos;
    FindTile(board, tile, &rowPos, &colPos); 
   
    if (rowPos - 1 >= 0 && board[rowPos - 1][colPos] == -1) {
        board[rowPos][colPos ] = -1;
        board[rowPos - 1][colPos] = tile;
        }
        
    else if (rowPos + 1 < NUM_ROWS && board[rowPos + 1][colPos] == -1) {
        board[rowPos][colPos ] = -1;
        board[rowPos + 1][colPos] = tile;
        }
        
    else if (colPos - 1 >= 0 && board[rowPos][colPos - 1] == -1) { 
        board[rowPos][colPos ] = -1;
        board[rowPos][colPos - 1] = tile;
        }
        
    else if (colPos + 1 < NUM_COLS && board[rowPos][colPos + 1] == -1) { 
        board[rowPos][colPos ] = -1;
        board[rowPos][colPos + 1] = tile;
        }


    else {
        
    }
}
",1
zzol692,1696232739,1,"//Author: Zara Zoll
//The function should swap the specified tile with the empty square.  
//Of course, this is only possible if the two squares are adjacent.  
//If the specified tile is not next to the empty square then it cannot be moved
void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int row, col;
    FindTile(board, tile, &row, &col);

    if (row == -1 || col == -1 ||
        (row > 0 && board[row - 1][col] == -1) ||
        (row < NUM_ROWS - 1 && board[row + 1][col] == -1) || 
        (col > 0 && board[row][col - 1] == -1) ||   
        (col < NUM_COLS - 1 && board[row][col + 1] == -1)) { 

        return;
    }

    board[row][col] = -1;
    board[rowPos][colPos] = tile;
}",0
zzol692,1696237873,2,"//Author: Zara Zoll
//The function should swap the specified tile with the empty square.  
//Of course, this is only possible if the two squares are adjacent.  
//If the specified tile is not next to the empty square then it cannot be moved
#include <stdio.h>
#include <stdlib.h>

#define NUM_ROWS 4
#define Num_COLS 4

void MakeMove(int board[NUM_ROWS][NUM_COLS], int tile) {
    int tileRow, tileCol, emptyRow, emptyCol;

    FindTile(board, tile, &tileRow, &tileCol);
    FindTile(board, -1, &emptyRow, &emptyCol);

    int rowDiff = abs(tileRow - emptyRow);
    int colDiff = abs(tileCol - emptyCol);

    if ((rowDiff == 1 && colDiff == 0) || (rowDiff == 0 && colDiff == 1)) {

        int temp = board[emptyRow][emptyCol];
        board[emptyRow][emptyCol] = board[tileRow][tileCol];
        board[tileRow][tileCol] = temp;
    }
}
",1
